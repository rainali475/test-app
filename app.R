if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

pkgs <- c("shiny", "shinyBS", "shinythemes", "caret", "sortable", "mgcv", "igraph", 
          "umap", "dplyr", "purrr", "plotly", "shinyWidgets", "shinyjs", "DT", "reshape2", 
          "rclipboard", "shinyFiles")
bioc_pkgs <- c("recount3", "rhdf5", "GenomicRanges", "ComplexHeatmap", 
               "InteractiveComplexHeatmap", "TSCAN", 
               "topGO", "limma", "GenomicAlignments", "DESeq2", "preprocessCore")

req_pkgs <- sapply(pkgs, function(pkg) {! requireNamespace(pkg, quietly = TRUE)})
if (any(req_pkgs)) 
  install.packages(pkgs[req_pkgs], dependencies = TRUE)
req_bioc_pkgs <- sapply(bioc_pkgs, function(pkg) {! requireNamespace(pkg, quietly = TRUE)})
if (any(req_bioc_pkgs)) 
  BiocManager::install(bioc_pkgs[req_bioc_pkgs])

suppressMessages(library(shiny))
suppressMessages(library(shinyBS))
suppressMessages(library(shinythemes))
suppressMessages(library(recount3))
suppressMessages(library(rhdf5))
suppressMessages(library(GenomicRanges))
# suppressMessages(library(BSgenome.Hsapiens.UCSC.hg38))
# suppressMessages(library(rtracklayer))
suppressMessages(library(caret))
suppressMessages(library(sortable))
suppressMessages(library(ComplexHeatmap))
suppressMessages(library(InteractiveComplexHeatmap))
suppressMessages(library(mgcv))
#suppressMessages(library(mclust))
suppressMessages(library(TSCAN))
suppressMessages(library(igraph))
#suppressMessages(library(factoextra))
suppressMessages(library(umap))
suppressMessages(library(dplyr))
suppressMessages(library(purrr))
suppressMessages(library(topGO))
#suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(limma))
suppressMessages(library(plotly))
suppressMessages(library(shinyWidgets))
suppressMessages(library(shinyjs))
#suppressMessages(library(Rsamtools))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(DT))
suppressMessages(library(reshape2))
suppressMessages(library(rclipboard))
suppressMessages(library(DESeq2))
suppressMessages(library(preprocessCore))
suppressMessages(library(shinyFiles))

#options(shiny.error = browser)
options(timeout = 800)

# Load popover contents
popover_contents <- readRDS(url("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/popover_contents.rds"))
#popover_contents <- readRDS("popover_contents.rds")

# Get genomic ranges from file
genomic_ranges <- read.delim("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/BIRD_output_ranges.txt")
#genomic_ranges <- read.delim("../app files/BIRD_output_ranges.txt")

bird_ranges <- GRanges(seqnames = genomic_ranges$Chromosome, 
                       ranges = IRanges(start = genomic_ranges$Start, 
                                        end = genomic_ranges$End))

il6_range <- bird_ranges[595879:595884]

chromosomes <- paste0("chr", c(1:22, "X"))

# Get max ranges for each chromosome
chr_max_ranges <- data.frame(matrix(ncol = 2, nrow = 0))
for (chr in chromosomes) {
  chr_start <- min(genomic_ranges[genomic_ranges$Chromosome == chr, "Start"])
  chr_end <- max(genomic_ranges[genomic_ranges$Chromosome == chr, "End"])
  chr_max_ranges <- rbind(chr_max_ranges, c(chr_start, chr_end))
}
colnames(chr_max_ranges) <- c("start", "end")
rownames(chr_max_ranges) <- chromosomes

# Get GRangesList of BIRD genomic ranges split by chromosome
chr_ranges <- split(bird_ranges, seqnames(bird_ranges))

# Get data.frame matching BIRD genomic ranges to nearest gene
gbin_tss <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gbin_tss.txt')
#gbin_tss <- read.delim('../app files/gbin_tss.txt')

# Get data.frame matching genes to their TSS's
gene_tss <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gene_tss.txt')
#gene_tss <- read.delim('../app files/gene_tss.txt')

# Get data.frame matching diseases/traits to gbins
snp_gbin <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/snp_gbin.txt')
#snp_gbin <- read.delim('../app files/snp_gbin.txt')

# Get data.frame matching gbins to diseases/traits
gbin_snp <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gbin_snp.txt')
#gbin_snp <- read.delim('../app files/gbin_snp.txt')

# Get data.frame of overall sample prediction means
#sample_avgs <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/sample_avgs.txt')
#sample_avgs <- read.delim('../app files/sample_avgs.txt')

# Set recount3 url
recount3_url <- "https://recount-opendata.s3.amazonaws.com/recount3/release"

# Get study batch info
studies_batch <- read.delim("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/studies_batch.txt")
#studies_batch <- read.delim("../app files/studies_batch.txt")

# Create temporary directory to hold all temporary files generated by this Shiny session
tmp_dir <- tempfile(pattern = "pddb")
dir.create(tmp_dir)
# rds_path <- tempfile(pattern = "rds", tmpdir = tmp_dir)
# dir.create(rds_path, showWarnings = FALSE)

# Read samples table
all_samples_df <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/samples_df.txt')
#all_samples_df <- read.delim('../app files/samples_df.txt')

# Read projects table
proj_df <- read.delim('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/proj_df.txt')
#proj_df <- read.delim('../app files/proj_df.txt')
proj_df$file_source <- as.factor(proj_df$file_source)

# Read annotations (mapping between ENSEMBL and SYMBOL)
annots <- readRDS(url("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/annots.rds"))

# Max number of clusters for genomic bin clustering used in pseudo time accessibility
max_n_gbin <- 20

# Max number of sample clusters for differential test
diff_max_n_sample_clust <- 10

ui <- fluidPage(
  
  rclipboardSetup(),
  
  theme = shinytheme("united"),
  
  title = "BIRD RNA-Seq Database", 
  
  navbarPage(
    title = "BIRD RNA-Seq Database", 
    
    tabPanel(
      title = "Input Selection", 
      
      div(style = "display: inline-block;vertical-align: middle;", h2("Input Selection")), 
      div(style = "display: inline-block;vertical-align: middle;", 
          bsButton(
            "input_selection_page_info", 
            label = "", 
            icon = icon("info"), 
            style = "info", 
            size = "extra-small"
          )), 
      bsPopover(
        id = "input_selection_page_info",
        title = "<h3>Input selection steps</h3>",
        content = do.call(paste0, 
                          popover_contents$input_selection_page_info),
        placement = "right",
        trigger = "focus",
        options = list(container = "body", 
                       html = TRUE)
      ),
      
      tabsetPanel(
        # Tab panel for sample upload and selection
        tabPanel(
          title = "Select or upload sample", 
          tags$div(
            style = "margin-bottom:50px; margin-top:50px;",
            sidebarLayout(
              sidebarPanel(
                uiOutput("sample_add_method_ui"), 
                actionButton("show_sel_samples_table", "Show selected samples table", style = "width: 100%; border: 1px solid white;"), 
                bsTooltip(
                  "show_sel_samples_table", 
                  title = "You will be able to subset the selected samples in this table", 
                  placement = "right",
                  options = list(container = "body", 
                                 html = TRUE)
                ),
                actionButton("clear_sel_samples", "Clear sample selection", style = "width: 100%; border: 1px solid white;")
              ), 
              mainPanel(
                uiOutput("sample_add_ui")
              )
            )
          )
        ), 
        
        # Tab panel for genomic range selection
        tabPanel(
          title = "Sample range selection", 
          tags$div(
            style = "margin-bottom:50px; margin-top:50px;",
            
            # Show number of selected bins
            htmlOutput("n_bins_msg"), 
            
            # Panel for range selection for all samples
            selectInput(
              inputId = "all_sel_method",
              label = tags$span("Range Selection Mode",
                                bsButton("range_sel_method_info", 
                                         label = "", 
                                         icon = icon("info"), 
                                         style = "info", 
                                         size = "extra-small")), 
              choices = c("Use default range", "Use entire BIRD range", "BED input", "Manual")
            ),
            bsPopover(
              id = "range_sel_method_info",
              title = "<h4>Range selection methods</h4>",
              content = do.call(paste0, 
                                popover_contents$range_sel_method_info),
              placement = "right",
              trigger = "focus",
              options = list(container = "body", 
                             html = TRUE)
            ),
            
            # Default range
            conditionalPanel(
              condition = "input.all_sel_method == 'Use default range'", 
              p("The following bins are selected: "),
              HTML(paste0("<p>", 
                          paste(paste(seqnames(il6_range), 
                                      start(il6_range), 
                                      '-', 
                                      end(il6_range)), 
                                collapse = '<br>'), 
                          "</p>"))
            ),
            
            # BIRD range
            conditionalPanel(
              condition = "input.all_sel_method == 'Use entire BIRD range'", 
              downloadButton("download_bird_range_bed", "Download BIRD output range BED")
            ),
            
            # BED input
            conditionalPanel(
              condition = "input.all_sel_method == 'BED input'", 
              fileInput("all_bed", 
                        label = "Choose BED file")
            ), 
            
            # Manual selection
            conditionalPanel(
              condition = "input.all_sel_method == 'Manual'", 
              sidebarLayout(
                sidebarPanel(
                  checkboxInput(
                    "all_sel_all_chr", 
                    label = "Select all chromosomes", 
                    value = FALSE
                  ),
                  checkboxGroupInput(
                    "all_sel_chr", 
                    label = h5("Select chromosome"), 
                    choices = chromosomes), 
                  width = 3
                ), 
                mainPanel(
                  # Add one check box for each chromosome
                  lapply(c(1:22, "X"), function(i) {
                    default_min <- chr_max_ranges[paste0("chr", i), "start"]
                    default_max <- chr_max_ranges[paste0("chr", i), "end"]
                    conditionalPanel(
                      condition = paste0("input.all_sel_chr.includes('chr", i, "')"),
                      fluidRow(
                        column(
                          3, 
                          numericInput(paste0("gr", i, "min"), 
                                       "Min", 
                                       default_min)
                        ), 
                        column(
                          6, 
                          sliderInput(
                            paste0("all_genomic_range", i), 
                            label = h5(paste("Chromosome", i, "Range")), 
                            min = default_min, 
                            max = default_max, 
                            value = c(default_min, default_max))
                        ),
                        column(
                          3, 
                          numericInput(paste0("gr", i, "max"), 
                                       "Max", 
                                       default_max)
                        )
                      )
                    )
                  })
                )
              )
            )
          )
        )
      )
    ), 
    
    # Prediction download
    navbarMenu(
      title = "Prediction Download", 
      
      # Tab panel for txt prediction download
      tabPanel(
        title = "txt download", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("txt Download")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "txt_download_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "txt_download_page_info",
          title = "<h3>BIRD prediction txt/zip formats</h3>",
          content = do.call(paste0, 
                            popover_contents$txt_download_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        
        uiOutput("download_zip_txt_ui")
      ), 
      
      # Tab panel for bigwig prediction download/link
      tabPanel(
        title = "BigWig download", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("BigWig Download")), 
        
        uiOutput("download_bw_ui"), 
        
        br(), 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("Display in UCSC Genome Browser Track Hub")), 
        
        uiOutput("ucsc_hub_ui")
      ), 
      
      # Tab panel for rds prediction download
      tabPanel(
        title = "rds download", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("rds Download")), 
        
        uiOutput("download_rds_ui")
      )
    ), 
    
    # Visualization
    navbarMenu(
      title = "Prediction Visualization", 
      # Tab panel for PCA
      tabPanel(
        title = "PCA and pseudo-time", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("PCA and pseudo-time analysis")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "pca_pt_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "pca_pt_page_info",
          title = "<h3>PCA and pseudo-time analysis</h3>",
          content = do.call(paste0, 
                            popover_contents$pca_pt_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        
        uiOutput('pca_page_ui')
      ), 
      
      # Tab panel for heat map
      tabPanel(
        title = "Heat Map", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("BIRD predictions heat map")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "heatmap_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "heatmap_page_info",
          title = "<h3>BIRD predictions heat map</h3>",
          content = do.call(paste0, 
                            popover_contents$heatmap_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        
        uiOutput("heatmap_page_ui")
      ), 
      
      # Tab panel for differential analysis
      tabPanel(
        title = "Group differential analysis", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("Group differential analysis")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_page_info",
          title = "<h3>Differential analysis steps</h3>",
          content = do.call(paste0, 
                            popover_contents$diff_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        
        uiOutput("diff_page_ui")
      ), 
      
      # Tab panel for disease SNP accessibility ranking
      tabPanel(
        title = "Disease SNP analysis", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("Disease SNP analysis")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "snp_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "snp_page_info",
          title = "<h3>Disease SNP analysis</h3>",
          content = do.call(paste0, 
                            popover_contents$snp_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        
        uiOutput("disease_page_ui")
      )
    )
  )
)

server <- function(input, output, session) {
  
  # Render UI for sample selection method
  output$sample_add_method_ui <- renderUI({
    method_choices <- list(
      "Select from prediction database" = "sel_db"
      # "Upload text file (under construction)" = "upload_txt", 
      # "Upload bam file (under construction)" = "upload_bam"
    )
    is_local <- Sys.getenv('SHINY_PORT') == ""
    if (is_local) {
      method_choices <- list(
        "Select from prediction database" = "sel_db",
        "Select from local path" = "sel_loc_path"
        # "Upload text file (under construction)" = "upload_txt", 
        # "Upload bam file (under construction)" = "upload_bam"
      )
    }
    tagList(
      selectInput(
        "sample_add_method", 
        label = tags$span("Add sample by: ", 
                          bsButton("sample_add_method_info", 
                                   label = "", 
                                   icon = icon("info"), 
                                   style = "info", 
                                   size = "extra-small")), 
        choices = method_choices
      ), 
      bsPopover(
        id = "sample_add_method_info",
        title = "<h4>Sample selection methods and steps</h4>",
        content = do.call(paste0, 
                          popover_contents$sample_add_method_info),
        placement = "right",
        trigger = "focus",
        options = list(container = "body", 
                       html = TRUE)
      ),
    )
  })
  
  if (Sys.getenv('SHINY_PORT') == "") {
    dir_roots <- c(working=paste0(getwd(), "/"))
    if (.Platform$OS.type == "windows") {
      sysdrivereport <- system("wmic logicaldisk get caption", intern = TRUE)
      drives <- substr(sysdrivereport[-c(1, length(sysdrivereport))], 1, 1)
      for (d in drives) {
        dir_roots[d] <- paste0(d, ":/")
      }
    } else {
      # unix OS
      dir_roots["root"] <- "/"
    }
    shinyDirChoose(input, 'loc_path', roots=dir_roots, filetypes=c("", "rds"))
  }
  
  loc_path <- reactiveVal(NULL)
  
  # Render message stating selected local path 
  output$loc_path_msg <- renderText({
    req(input$loc_path)
    if (all(class(input$loc_path) == "list")) {
      loc_path(paste0(dir_roots[input$loc_path$root], do.call(file.path, input$loc_path$path[-1])))
      paste("Selected directory:", loc_path())
    } else {
      loc_path(NULL)
      "No path has been selected. "
    }
  })
  
  # Render UI for sample selection and upload
  output$sample_add_ui <- renderUI({
    req(input$sample_add_method)
    if (input$sample_add_method == "sel_db") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Add samples from database")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "database_sel_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "database_sel_info",
          title = "<h3>BIRD predictions database</h3>",
          content = do.call(paste0, 
                            popover_contents$database_sel_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        HTML("<p>All predictions in database are <b>log<sub>2</sub>-transformed</b>. </p>"),
        tabsetPanel(
          # Tab panel for project selection
          tabPanel(
            title = "Step 1: Project Selection", 
            tags$div(
              style = "margin-top:30px; margin-bottom:30px;", 
              radioButtons(
                "proj_sel_method", 
                "Project selection method: ",
                choices = c("Select from table", "Select with text input"), 
                selected = "Select from table"
              ),
              uiOutput("proj_sel_ui")
            )
          ), 
          
          # Tab panel for samples selection
          tabPanel(
            title = "Step 2: Sample Selection", 
            tags$div(
              style = "margin-top:30px; margin-bottom:30px;", 
              radioButtons(
                "sample_sel_method", 
                "Sample selection method: ",
                choices = c("Select from table", "Select with text input"), 
                selected = "Select from table"
              ),
              uiOutput("sample_sel_ui")
            )
          )
        )
      )
    } else if (input$sample_add_method == "sel_loc_path") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Add samples from local path")), 
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "loc_path_sel_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "loc_path_sel_info",
          title = "<h3>BIRD predictions database</h3>",
          content = do.call(paste0,
                            popover_contents$loc_path_sel_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        HTML("<p>All predictions assumed to be <b>log<sub>2</sub>-transformed</b>. </p>"),
        shinyDirButton('loc_path', 'Select a local directory', 'Please select a directory', FALSE), 
        textOutput("loc_path_msg"), 
        HTML("<p>Please make sure the rds files in your indicated path are <b>downloaded from our 
             database</b> or <b>follow the format requirement</b> listed in the popover content (information icon above). </p>"),
        HTML("<p><b>Please be aware that selecting a new directory will cause all previously selected local samples to be removed from selection. </b></p>"), 
        uiOutput("loc_path_sample_add_ui")
      )
    } else if (input$sample_add_method == "upload_txt") {
      tagList(
        fileInput("sample_add_txt_file", 
                  accept = "text/plain", 
                  multiple = TRUE,
                  label = "Choose text file"), 
        textOutput('sample_add_txt_upload_msg'),
        DT::dataTableOutput("sample_add_txt_upload_table"), 
        selectInput("sample_add_txt_file_transform", 
                    "Transformation applied on values: ", 
                    choices = c("log-transformed", "none")),
        actionButton("submit_sample_add_txt_file", "Confirm samples upload"),
        textOutput("sample_add_txt_submission_msg")
      )
    } else if (input$sample_add_method == "upload_bam") {
      tagList(
        fileInput("sample_add_bam_file", 
                  accept = ".bam", 
                  multiple = TRUE, 
                  label = "Choose BAM files"), 
        DT::dataTableOutput("sample_add_bam_upload_table"), 
        actionButton("submit_add_bam_file", "Confirm samples selection"), 
        textOutput("sample_add_bam_submission_msg")
      )
    }
  })
  
  # Render UI for local path files selection
  output$loc_path_sample_add_ui <- renderUI({
    req(loc_path())
    tabsetPanel(
      # Tab panel for project selection
      tabPanel(
        title = "Step 1: Project Selection", 
        textOutput("loc_proj_rds_msg"),
        tags$div(
          style = "margin-top:30px; margin-bottom:30px;", 
          div(style = "display: inline-block;vertical-align: middle;", h4("Local project selection table")), 
          div(style = "display: inline-block;vertical-align: middle;", bsButton("loc_project_sel_table_info", 
                                                                                label = "", 
                                                                                icon = icon("info"), 
                                                                                style = "info", 
                                                                                size = "extra-small")), 
          bsPopover(
            id = "loc_project_sel_table_info",
            title = "<h4>Project selection table</h4>",
            content = do.call(paste0, 
                              popover_contents$loc_project_sel_table_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          # Display table with project info
          DT::dataTableOutput('loc_proj_table'), 
          actionButton("loc_proj_sel_check", "Check project RDS file"), 
          textOutput("loc_proj_sel_msg")
        )
      ), 
      
      # Tab panel for samples selection
      tabPanel(
        title = "Step 2: Sample Selection", 
        tags$div(
          style = "margin-top:30px; margin-bottom:30px;", 
          radioButtons(
            "loc_sample_sel_method", 
            "Sample selection method: ",
            choices = c("Select from table", "Select with text input"), 
            selected = "Select from table"
          ),
          uiOutput("loc_sample_sel_ui")
        )
      )
    )
  })
  
  # Local path studies
  loc_studies <- reactiveVal(character())
  
  # Update local path studies, clear sample selection table
  observeEvent(loc_path(), {
    # Update local path studies
    rds_files <- list.files(path = loc_path(), pattern = ".rds$")
    studies <- gsub(".rds$", "", rds_files)
    studies <- studies[studies %in% proj_df$project]
    loc_studies(studies)
    # Clear selected local samples
    selected_samples(selected_samples()[selected_samples()$read_from != "local", ])
    # Clear read local studies list and sample selection table
    loc_studies_li(list())
  })
  
  # Render message for rds files read from local path
  output$loc_proj_rds_msg <- renderText({
    # List local path rds
    rds_files <- list.files(path = loc_path(), pattern = ".rds$")
    if (length(rds_files) == 0) {
      return("No valid files found. Please select a different directory. ")
    }
    paste0("The following rds files are found in your selected directory: ", 
           paste(rds_files, collapse = ", "), 
           ". The files matching existing project ids are listed below.")
  })
  
  # Render local project table
  output$loc_proj_table <- DT::renderDataTable(proj_df[proj_df$project %in% loc_studies(), ],
                                               rownames = FALSE,
                                               filter = list(position = 'top', clear = FALSE))
  
  # Message for local project selection
  loc_proj_sel_msg <- reactiveVal(NULL)
  
  # Render message
  output$loc_proj_sel_msg <- renderText({loc_proj_sel_msg()})
  
  # Check selected local projects
  observeEvent(input$loc_proj_sel_check, {
    if (length(input$loc_proj_table_rows_selected) == 0) {
      loc_proj_sel_msg("You have not selected any projects. Please select projects by clicking on the table above. ")
      return(NULL)
    }
    loc_proj_table <- proj_df[proj_df$project %in% loc_studies(), ]
    sel_proj <- loc_proj_table$project[input$loc_proj_table_rows_selected]
    rds_files <- file.path(loc_path(), paste0(sel_proj, ".rds"))
    tot_nsamp <- sum(loc_proj_table$n_samples[input$loc_proj_table_rows_selected])
    expected_read_time <- tot_nsamp * 0.04
    read_min <- floor(expected_read_time / 60)
    read_sec <- signif(((expected_read_time / 60) - read_min) * 60, digits = 1)
    if (read_sec == 60) {
      read_sec <- 0
      read_min <- read_min + 1
    }
    showModal(modalDialog(
      p(paste0("You are about to read the following selected files: ", 
               paste(rds_files, collapse = ", "), 
               ". If these files are full studies downloaded from database, they 
               should together take approximately ", 
               read_min, "m", read_sec, "s to be read. Please be aware that 
               performing this action will cause any previously selected local 
               samples to be removed from sample selection table. ")), 
      actionButton("loc_proj_sel_submit", "Okay"), 
      easyClose = TRUE
    ))
  })
  
  # Local studies matrix
  loc_studies_li <- reactiveVal(list())
  
  # Check selected projects 
  observeEvent(input$loc_proj_sel_submit, {
    loc_proj_table <- proj_df[proj_df$project %in% loc_studies(), ]
    sel_proj <- loc_proj_table$project[input$loc_proj_table_rows_selected]
    rds_files <- file.path(loc_path(), paste0(sel_proj, ".rds"))
    valid_proj <- c()
    # Update local studies matrices
    studies_li <- list()
    for (i in 1:length(sel_proj)) {
      proj_mat <- tryCatch({readRDS(rds_files[i])}, error = function(e) {NULL})
      if (is.null(proj_mat)) next
      if (! inherits(proj_mat, "matrix")) next
      if (mode(proj_mat) != "numeric") next
      if (nrow(proj_mat) != nrow(genomic_ranges)) next
      samps <- colnames(proj_mat)
      if (anyDuplicated(samps) || (length(samps) == 0)) next
      actual_samps <- all_samples_df$sample_id[all_samples_df$project_id == sel_proj[i]]
      if (! all(samps %in% actual_samps)) next
      if (! all(is.finite(proj_mat))) next
      studies_li[[sel_proj[i]]] <- proj_mat
      valid_proj <- c(valid_proj, sel_proj[i])
    }
    loc_studies_li(studies_li)
    loc_proj_sel_msg(
      if (length(valid_proj) == 0) {
        "No valid study RDS files found in selected files. "
      } else {
        paste0("The following studies are read from selected files: ", 
               paste(valid_proj, collapse = ", "))
      }
    )
    # Remove previously selected local samples from selected samples table
    selected_samples(selected_samples()[selected_samples()$read_from != "local", ])
    removeModal()
  })
  
  # Render UI for sample selection
  output$loc_sample_sel_ui <- renderUI({
    if (input$loc_sample_sel_method == "Select from table") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Sample selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("sample_sel_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "sample_sel_table_info",
          title = "<h4>Sample selection table</h4>",
          content = do.call(paste0, 
                            popover_contents$sample_sel_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        # Display table with sample info
        DT::dataTableOutput('loc_sample_table'), 
        actionButton(
          "loc_submit_sample_sel_table", 
          label = "Confirm sample selection"
        ), 
        textOutput("loc_sample_sel_table_submission_msg")
      )
    } else if (input$loc_sample_sel_method == "Select with text input") {
      tagList(
        textAreaInput(
          "loc_sample_sel_text", 
          label = tags$span("Input sample ids (one sample id in each line)", 
                            bsButton("sample_sel_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5
        ),
        bsPopover(
          id = "sample_sel_text_info",
          title = "<h4>Sample selection text</h4>",
          content = do.call(paste0, 
                            popover_contents$sample_sel_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "loc_sample_sel_txt_file", 
          "Upload txt file indicating sample ids", 
          accept = "text/plain"
        ),
        actionButton(
          "loc_submit_sample_sel_text", 
          label = "Confirm sample selection"
        ),
        textOutput("loc_sample_sel_text_submission_msg")
      )
    }
  })
  
  # Define samples data.frame based on user selection
  loc_samples_df <- reactive({
    sel_proj <- names(loc_studies_li())
    df <- all_samples_df[all_samples_df$project_id %in% sel_proj, ]
    df$project_id <- as.factor(df$project_id)
    samples <- unique(unlist(lapply(loc_studies_li(), colnames)))
    df <- df[df$sample_id %in% samples,]
    df
  })
  
  # Render output samples table
  output$loc_sample_table <- DT::renderDataTable({
    if (nrow(loc_samples_df()) > 0) {
      df <- data.frame(loc_samples_df(), selected="")
      df$selected[df$sample_id %in% selected_samples()$sample] <- as.character(icon("check"))
      df$selected <- as.factor(df$selected)
    } else {
      df <- NULL
    }
    DT::datatable(df,
                  rownames = FALSE, 
                  filter = list(position = 'top', clear = FALSE), 
                  escape = FALSE)
  })
  
  # Make proxy for controlling selected rows
  loc_sample_table_proxy <- DT::dataTableProxy("loc_sample_table")
  
  # Update selected samples when data table selection occurs and output message
  loc_sample_sel_table_submission_msg <- reactiveVal("")
  
  # Render sample selection table submission message
  output$loc_sample_sel_table_submission_msg <- renderText({
    loc_sample_sel_table_submission_msg()
  })
  
  # Update selected samples when data table selection occurs
  observeEvent(input$loc_submit_sample_sel_table, {
    if (length(input$loc_sample_table_rows_selected) > 0) {
      # Make samples data.frame from selected samples
      new_samples <- loc_samples_df()[input$loc_sample_table_rows_selected, c('project_id', 'sample_id')]
      colnames(new_samples) <- c('project', 'sample')
      proj_sources <- proj_df[proj_df$project %in% new_samples$project, c('project', 'file_source')]
      proj_sources$file_source <- as.character(proj_sources$file_source)
      new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
      # Re-order columns
      new_samples <- new_samples[, c("file_source", "project", "sample")]
      new_samples$read_from <- "local"
      # Remove redundant sample ids
      redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
      # Update selected samples table
      selected_samples(rbind(selected_samples(), new_samples[! new_samples$sample %in% redundant_ids, ]))
      # Clear samples table selected rows
      loc_sample_table_proxy %>% selectRows(NULL)
      if (length(redundant_ids) > 0) {
        loc_sample_sel_table_submission_msg(
          paste("Samples added to selection. The following samples are already present in the current selection:", 
                paste(redundant_ids, collapse = ", "))
        )
      } else {
        loc_sample_sel_table_submission_msg(paste("Selection successful! Samples added to selection. "))
      }
    }
  })
  
  # Update sample selection text area input value based on uploaded file
  observeEvent(input$loc_sample_sel_txt_file, {
    if (! is.null(input$loc_sample_sel_txt_file)) {
      sample_sel_text <- paste(readLines(input$loc_sample_sel_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "loc_sample_sel_text", 
        value = sample_sel_text
      )
    }
  })
  
  # Render sample selection submission text
  output$loc_sample_sel_text_submission_msg <- renderText({
    loc_sample_sel_text_submission_msg()
  })
  
  # Update submission text based on action button and text evaluation results
  loc_sample_sel_text_submission_msg <- eventReactive(input$loc_submit_sample_sel_text, {
    # Read sample ids from submitted text
    sample_ids <- unlist(strsplit(input$loc_sample_sel_text, split = "\n"))
    sample_ids <- sapply(sample_ids, function(sample_id) {
      sample_id <- gsub(" ", "", sample_id)
      sample_id <- gsub("\t", "", sample_id)
      sample_id
    })
    sample_ids <- sample_ids[sample_ids != ""]
    sample_ids <- unique(sample_ids)
    if (length(sample_ids) == 0) {
      return(paste("Selection failed - input is empty."))
    }
    # Check if sample ids exist
    if (any(! sample_ids %in% loc_samples_df()$sample_id)) {
      bad_samples <- sample_ids[which(! sample_ids %in% loc_samples_df()$sample_id)]
      return(paste0("Selection failed. The following samples are not found in selected projects: ", 
                    paste(unique(bad_samples), collapse = ", ")))
    }
    new_samples <- loc_samples_df()[loc_samples_df()$sample_id %in% sample_ids, c('project_id', 'sample_id')]
    colnames(new_samples) <- c('project', 'sample')
    proj_sources <- proj_df[proj_df$project %in% new_samples$project, c('project', 'file_source')]
    proj_sources$file_source <- as.character(proj_sources$file_source)
    new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
    # Re-order columns
    new_samples <- new_samples[, c("file_source", "project", "sample")]
    new_samples$read_from <- "local"
    # Check if there is any redundant sample ids
    redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
    # Update selected samples table
    selected_samples(rbind(selected_samples(), new_samples[! new_samples$sample %in% redundant_ids, ]))
    if (length(redundant_ids) > 0) {
      return(paste("Samples added to selection. The following samples are already present in the current selection:", 
                   paste(redundant_ids, collapse = ", ")))
    }
    return(paste("Selection completed!"))
  })
  
  # Render UI for project selection
  output$proj_sel_ui <- renderUI({
    if (input$proj_sel_method == "Select from table") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Project selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("project_sel_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "project_sel_table_info",
          title = "<h4>Project selection table</h4>",
          content = do.call(paste0, 
                            popover_contents$project_sel_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        # Display table with project info
        DT::dataTableOutput('proj_table'),
      )
    } else if (input$proj_sel_method == "Select with text input") {
      tagList(
        textAreaInput(
          "proj_sel_text", 
          label = tags$span("Input project ids (one project id in each line)", 
                            bsButton("proj_sel_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5),
        bsPopover(
          id = "proj_sel_text_info",
          title = "<h3>Project selection text</h3>",
          content = do.call(paste0, 
                            popover_contents$proj_sel_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "proj_sel_txt_file", 
          "Upload txt file indicating project ids", 
          accept = "text/plain"
        ),
        actionButton(
          "submit_proj_sel_text", 
          label = "Confirm project selection"
        ),
        textOutput("proj_sel_submission_text")
      )
    }
  })
  
  # Reactive value containing selected projects index
  proj_table_rows_selected <- reactiveVal()
  
  # Render project table
  output$proj_table <- DT::renderDataTable(proj_df,
                                           rownames = FALSE,
                                           filter = list(position = 'top', clear = FALSE))
  
  # Update project selection text area input value based on uploaded file
  observeEvent(input$proj_sel_txt_file, {
    if (! is.null(input$proj_sel_txt_file)) {
      proj_sel_text <- paste(readLines(input$proj_sel_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "proj_sel_text", 
        value = proj_sel_text
      )
    }
  })
  
  # Update selected projects when data table selection occurs
  observeEvent(input$proj_table_rows_selected, ignoreNULL = FALSE, {
    proj_table_rows_selected(input$proj_table_rows_selected)
  })
  
  # Render project selection submission text
  output$proj_sel_submission_text <- renderText({
    proj_sel_submission_text()
  })
  
  # Update submission text based on action button and text evaluation results
  proj_sel_submission_text <- eventReactive(input$submit_proj_sel_text, {
    # Read group ids from submitted text
    proj_ids <- unlist(strsplit(input$proj_sel_text, split = "\n"))
    proj_ids <- sapply(proj_ids, function(proj_id) {
      proj_id <- gsub(" ", "", proj_id)
      proj_id <- gsub("\t", "", proj_id)
      proj_id
    })
    proj_ids <- proj_ids[proj_ids != ""]
    proj_ids <- unique(proj_ids)
    if (length(proj_ids) == 0) {
      return(paste("Selection failed - input is empty."))
    }
    # Check if project ids exist
    if (any(! proj_ids %in% proj_df$project)) {
      bad_proj <- proj_ids[which(! proj_ids %in% proj_df$project)]
      return(paste0("Selection failed. The following projects are not found in database: ", 
                    paste(unique(bad_proj), collapse = ", ")))
    }
    proj_table_rows_selected(which(proj_df$project %in% proj_ids))
    paste("Selection completed!")
  })
  
  # Render UI for sample selection
  output$sample_sel_ui <- renderUI({
    if (input$sample_sel_method == "Select from table") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Sample selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("sample_sel_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "sample_sel_table_info",
          title = "<h4>Sample selection table</h4>",
          content = do.call(paste0, 
                            popover_contents$sample_sel_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        # Display table with sample info
        DT::dataTableOutput('sample_table'), 
        actionButton(
          "submit_sample_sel_table", 
          label = "Confirm sample selection"
        ), 
        textOutput("sample_sel_table_submission_msg")
      )
    } else if (input$sample_sel_method == "Select with text input") {
      tagList(
        textAreaInput(
          "sample_sel_text", 
          label = tags$span("Input sample ids (one sample id in each line)", 
                            bsButton("sample_sel_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5
        ),
        bsPopover(
          id = "sample_sel_text_info",
          title = "<h4>Sample selection text</h4>",
          content = do.call(paste0, 
                            popover_contents$sample_sel_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "sample_sel_txt_file", 
          "Upload txt file indicating sample ids", 
          accept = "text/plain"
        ),
        actionButton(
          "submit_sample_sel_text", 
          label = "Confirm sample selection"
        ),
        textOutput("sample_sel_text_submission_msg")
      )
    }
  })
  
  # Reactive data.frame of selected samples info
  selected_samples <- reactiveVal(setNames(data.frame(matrix(ncol = 4, nrow = 0)), 
                                           c("file_source", "project", "sample", "read_from")))
  
  # Define samples data.frame based on user selection
  samples_df <- reactive({
    selected_proj <- proj_df$project[proj_table_rows_selected()]
    df <- all_samples_df[all_samples_df$project_id %in% selected_proj, ]
    df$project_id <- as.factor(df$project_id)
    df
  })
  
  # Render output samples table
  output$sample_table <- DT::renderDataTable({
    req(samples_df())
    req(nrow(samples_df()) > 0)
    df <- data.frame(samples_df(), selected="")
    df$selected[df$sample_id %in% selected_samples()$sample] <- as.character(icon("check"))
    df$selected <- as.factor(df$selected)
    DT::datatable(df,
                  rownames = FALSE, 
                  filter = list(position = 'top', clear = FALSE), 
                  escape = FALSE)
  })
  
  # Make proxy for controlling selected rows
  sample_table_proxy <- DT::dataTableProxy("sample_table")
  
  # Render sample selection table submission message
  output$sample_sel_table_submission_msg <- renderText({
    sample_sel_table_submission_msg()
  })
  
  # # Show pop-up modal when size of studies to be read exceed threshold
  # observeEvent(input$submit_sample_sel_table, {
  #   if (length(input$sample_table_rows_selected) > 0) {
  #     # Evaluate whether selected studies exceed size thresholds
  #     before_add <- sum(proj_df$n_samples[proj_df$project %in% selected_samples()$project])
  #     add_proj <- samples_df()[input$sample_table_rows_selected, c('project_id')]
  #     after_add <- sum(proj_df$n_samples[proj_df$project %in% setdiff(unique(add_proj), selected_samples()$project)])
  #     read_time <- 0
  #     read_ram <- 0
  #     if ((before_add < 100) && (after_add >= 100)) {
  #       read_time <- ceiling(after_add / 10)
  #       msg <- paste("The samples you selected require reading prediction data from", 
  #                    length(union(unique(add_proj), unique(selected_samples()$project))), 
  #                    "studies, which together includes", after_add, 
  #                    "samples to be read from server. Approximately ")
  #     }
  #   }
  # })
  
  # Whether to show warning for number of selected samples
  sample_sel_limit_warn <- reactiveVal(TRUE)
  
  # Turn off warning when asked to
  observeEvent(input$confirm_warning_msg, {
    if (input$sample_sel_limit_warn_off) {
      sample_sel_limit_warn(FALSE)
    }
    removeModal()
  })
  
  output$runapp_code <- renderText("if(!require(\"shiny\")) install.packages(\"shiny\")\nshiny::runGitHub(\"test-app\", \"rainali475\")")
  
  # Update selected samples when data table selection occurs
  observeEvent(input$submit_sample_sel_table, {
    if (length(input$sample_table_rows_selected) > 0) {
      # Make samples data.frame from selected samples
      new_samples <- samples_df()[input$sample_table_rows_selected, c('project_id', 'sample_id')]
      colnames(new_samples) <- c('project', 'sample')
      proj_sources <- proj_df[proj_df$project %in% new_samples$project, c('project', 'file_source')]
      proj_sources$file_source <- as.character(proj_sources$file_source)
      new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
      # Re-order columns
      new_samples <- new_samples[, c("file_source", "project", "sample")]
      new_samples$read_from <- "database"
      # Remove redundant sample ids
      redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
      # Evaluate whether selected studies exceed size thresholds
      before_add <- sum(proj_df$n_samples[proj_df$project %in% selected_samples()$project])
      after_add <- sum(proj_df$n_samples[proj_df$project %in% union(unique(new_samples$project), selected_samples()$project)])
      if (after_add > 200000) {
        # Exceeded size limit
        showModal(
          modalDialog(
            HTML(paste0("You tried to retrieve a set of studies with more than 200,000 samples in total. 
                        This amount of samples is not suitable for analysis with this app. Please 
                        select fewer studies. ")), 
            easyClose = TRUE, 
            footer = NULL
          )
        )
        sample_sel_table_submission_msg(paste("Selection failed. Study size limit exceeded. Please select fewer studies. "))
        return(NULL)
      }
      if ((after_add > 600) && (Sys.getenv('SHINY_PORT') != "")) {
        # Exceeded size limit for server
        runapp_code <- "if(!require(\"shiny\")) install.packages(\"shiny\")\nshiny::runGitHub(\"test-app\", \"rainali475\")"
        showModal(
          modalDialog(
            HTML(paste0("<p>You tried to retrieve a set of studies with more than 20,000 samples in total, 
              which exceeds the database server's size limit for retrieving data from ftp. To retrieve large studies, 
                         we recommend downloading compressed files of your studies 
                         of interest and reading them from a local path. Please go 
                         to <b>Prediction Download</b>", icon("arrow-right"), 
                        "<b>RDS download</b> to download the compressed prediction 
                         files. Then, run this app from your <b>local host</b>, 
                        go to <b>Input Selection</b> ", icon("arrow-right"), 
                        " <b>Select or upload sample</b> ", icon("arrow-right"), 
                        " <b>Add sample by</b> ", icon("arrow-right"), 
                        " <b>Select from local path</b> to add local samples.</p>")), 
            br(), 
            HTML(paste0("Run the following code in R to start app from local host: ")), 
            verbatimTextOutput("runapp_code"), 
            rclipButton(
              inputId = "runapp_code_copy", 
              label = "Copy code", 
              clipText = runapp_code, 
              icon = icon("clipboard"), 
              style = "border: 1px solid white;"
            ), 
            easyClose = TRUE, 
            footer = NULL
          )
        )
        sample_sel_table_submission_msg(paste("Selection failed. Study size limit exceeded. Please select fewer studies. "))
        return(NULL)
      }
      if (sample_sel_limit_warn()) {
        if (((before_add < 100) && (after_add >= 100)) ||
            ((before_add < 500) && (after_add >= 500)) ||
            ((before_add < 1000) && (after_add >= 1000)) ||
            ((before_add < 5000) && (after_add >= 5000)) ||
            ((before_add < 10000) && (after_add >= 10000))) {
          read_ram <- round(after_add / 100, digits = 1)
          read_min <- floor(after_add / 10 / 60)
          read_sec <- signif(((after_add / 10 / 60) - read_min) * 60, digits = 1)
          if (read_sec == 60) {
            read_sec <- 0
            read_min <- read_min + 1
          }
          msg <- paste0("The set of samples you selected require reading prediction data from ", 
                        length(union(unique(new_samples$project), unique(selected_samples()$project))), 
                        " studies, which together contain ", after_add, 
                        " samples in total. Approximately <b>", read_ram, 
                        "GB</b> of RAM will be needed to read these studies. Data retrieval will take approximately <b>", 
                        read_min, "m", read_sec, "s</b>.")
          if (after_add >= 1000) {
            msg <- paste0(msg, "<br><br>Since you are trying to retrieve large studies, 
                         we recommend downloading compressed files of your studies 
                         of interest and reading them from a local path. Please go 
                         to <b>Prediction Download</b> ", icon("arrow-right"), 
                         " <b>RDS download</b> to download the compressed prediction 
                         files and go to <b>Input Selection</b> ", icon("arrow-right"), 
                         " <b>Select or upload sample</b> ", icon("arrow-right"), 
                         " <b>Add sample by</b> ", icon("arrow-right"), 
                         " <b>Select from local path</b> to add local samples to your selection.")
          }
          showModal(
            modalDialog(
              div(style = "display:inline-block; vertical-align:middle;", h4("Warning")), 
              br(), 
              HTML(msg), 
              checkboxInput(
                "sample_sel_limit_warn_off", 
                "Do not show this warning again", 
                value = FALSE
              ), 
              actionButton("confirm_warning_msg", "Okay"), 
              easyClose = FALSE, 
              footer = NULL
            )
          )
        }
      }
      # Update selected samples table
      selected_samples(rbind(selected_samples(), new_samples[! new_samples$sample %in% redundant_ids, ]))
      # Clear samples table selected rows
      sample_table_proxy %>% selectRows(NULL)
      if (length(redundant_ids) > 0) {
        sample_sel_table_submission_msg(
          paste("Samples added to selection. The following samples are already present in the current selection:", 
                paste(redundant_ids, collapse = ", "))
        )
      } else {
        sample_sel_table_submission_msg(paste("Selection successful! Samples added to selection. "))
      }
    }
  })
  
  # Update selected samples when data table selection occurs and output message
  sample_sel_table_submission_msg <- reactiveVal("")
  
  # Show pop-up modal for displaying selected samples on button click
  observeEvent(input$show_sel_samples_table, {
    showModal(
      modalDialog(
        div(style = "display:inline-block; vertical-align:middle;", h4("Selected samples table")), 
        div(style = "display:inline-block; vertical-align:middle;", 
            bsButton("sel_samples_table_info",
                     label = "", 
                     icon = icon("info"), 
                     style = "info", 
                     size = "extra-small")),
        bsPopover(
          id = "sel_samples_table_info",
          title = "<h4>Managing selected samples</h4>",
          content = do.call(paste0, 
                            popover_contents$sel_samples_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        DT::dataTableOutput("sel_samples_table"),
        actionButton("rm_sel_samples", "Remove selected samples from table"), 
        easyClose = TRUE
      )
    )
  })
  
  # Render selected samples table
  output$sel_samples_table <- DT::renderDataTable(selected_samples(), 
                                                  rownames = FALSE, 
                                                  filter = list(position = 'top', clear = FALSE))
  
  # Update sample selection text area input value based on uploaded file
  observeEvent(input$sample_sel_txt_file, {
    if (! is.null(input$sample_sel_txt_file)) {
      sample_sel_text <- paste(readLines(input$sample_sel_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "sample_sel_text", 
        value = sample_sel_text
      )
    }
  })
  
  # Render sample selection submission text
  output$sample_sel_text_submission_msg <- renderText({
    sample_sel_text_submission_msg()
  })
  
  # Update submission text based on action button and text evaluation results
  sample_sel_text_submission_msg <- eventReactive(input$submit_sample_sel_text, {
    # Read sample ids from submitted text
    sample_ids <- unlist(strsplit(input$sample_sel_text, split = "\n"))
    sample_ids <- sapply(sample_ids, function(sample_id) {
      sample_id <- gsub(" ", "", sample_id)
      sample_id <- gsub("\t", "", sample_id)
      sample_id
    })
    sample_ids <- sample_ids[sample_ids != ""]
    sample_ids <- unique(sample_ids)
    if (length(sample_ids) == 0) {
      return(paste("Selection failed - input is empty."))
    }
    # Check if sample ids exist
    if (any(! sample_ids %in% samples_df()$sample_id)) {
      bad_samples <- sample_ids[which(! sample_ids %in% samples_df()$sample_id)]
      return(paste0("Selection failed. The following samples are not found in selected projects: ", 
                    paste(unique(bad_samples), collapse = ", ")))
    }
    new_samples <- samples_df()[samples_df()$sample_id %in% sample_ids, c('project_id', 'sample_id')]
    colnames(new_samples) <- c('project', 'sample')
    proj_sources <- proj_df[proj_df$project %in% new_samples$project, c('project', 'file_source')]
    proj_sources$file_source <- as.character(proj_sources$file_source)
    new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
    # Re-order columns
    new_samples <- new_samples[, c("file_source", "project", "sample")]
    # Check if there is any redundant sample ids
    redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
    # Update selected samples table
    selected_samples(rbind(selected_samples(), new_samples[! new_samples$sample %in% redundant_ids, ]))
    if (length(redundant_ids) > 0) {
      return(paste("Samples added to selection. The following samples are already present in the current selection:", 
                   paste(redundant_ids, collapse = ", ")))
    }
    return(paste("Selection completed!"))
  })
  
  # User-input txt sample predictions list
  user_txt_pred_list <- reactiveVal(list())
  
  # Define sample selection txt files upload table
  sample_add_txt_upload_table <- reactiveVal(setNames(data.frame(matrix(nrow = 0, ncol = 4)), 
                                                      c("file_name", "project", "sample", "n_bins")))
  
  # Update sample selection txt files table according to upload list
  observeEvent(user_txt_pred_list(), {
    upload_df <- setNames(data.frame(matrix(nrow = 0, ncol = 4)), 
                          c("file_name", "project", "sample", "n_bins"))
    fnames <- names(user_txt_pred_list())
    for (fname in fnames) {
      project <- gsub('\\.txt$', '', fname)
      pred <- user_txt_pred_list()[[fname]]$pred_mat
      samples <- colnames(pred)
      nbins <- nrow(pred)
      df <- data.frame(file_name = fname, 
                       project = project, 
                       sample = samples, 
                       n_bins = nbins)
      upload_df <- rbind(upload_df, df)
    }
    sample_add_txt_upload_table(upload_df)
  })
  
  # Render sample selection txt files table
  output$sample_add_txt_upload_table <- DT::renderDataTable(sample_add_txt_upload_table(), 
                                                            rownames = FALSE, 
                                                            filter = list(position = 'top', clear = FALSE))
  
  # Make proxy for controlling selected rows
  txt_upload_table_proxy <- DT::dataTableProxy("sample_add_txt_upload_table")
  
  # Render sample text file upload text
  output$sample_add_txt_upload_msg <- renderText({
    cat(sample_add_txt_upload_msg())
  })
  
  # Define txt file upload message
  sample_add_txt_upload_msg <- reactiveVal('')
  
  # Update sample selection txt files upload message, list, and table
  observeEvent(input$sample_add_txt_file, {
    txt_handle <- input$sample_add_txt_file
    filenum <- length(txt_handle$datapath)
    if (!is.null(txt_handle)) {
      # Reset upload list and message
      user_txt_pred_list(list())
      sample_add_txt_upload_msg('')
      withProgress(message = 'Reading in txt files',detail="0%",{
        for (i in 1:filenum) {
          txt_info <- list()
          incProgress(1/filenum, detail=paste0(round(i/filenum*100),"%"))
          name <- txt_handle$name[i]
          user_pred <- tryCatch({read.table(txt_handle$datapath[i], header = TRUE, check.names = FALSE)}, 
                                error = function(e) e)
          if (inherits(user_pred, "error")) {
            # Add message and move on to examine next file
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name, 
                                             " cannot be opened/read. Please check file format.", 
                                             "\n"))
            next
          }
          if ((length(colnames(user_pred)) < 4) || (! all(colnames(user_pred)[1:3] == c('Chromosome', "Start", "End")))) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " has invalid format. Please check text file format.", 
                                             "\n"))
            next
          }
          if (! all(user_pred$Chromosome %in% chromosomes)) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " has bad input in Chromosome column. Please check text file format.", 
                                             "\n"))
            next
          }
          if ((! is.integer(user_pred$Start)) || (! is.integer(user_pred$End))) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " has invalid format. Start and End columns must be integers.", 
                                             "\n"))
            next
          }
          if (! all(sapply(user_pred[, 4:ncol(user_pred)], is.numeric))) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " has invalid format. Sample chromatin accessibility values must all be numeric.", 
                                             "\n"))
            next
          }
          if (! all(user_pred[, 2:ncol(user_pred)] >= 0)) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " has invalid values. Genomic positions and chromatin accessibility values must not be negative.", 
                                             "\n"))
            next
          }
          if (any(table(colnames(user_pred)[4:ncol(user_pred)]) > 1)) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " contains redundant sample ids.", 
                                             "\n"))
            next
          }
          pred_matrix <- data.matrix(user_pred[, 4:ncol(user_pred), drop = FALSE])
          gr <- GRanges(seqnames = user_pred$Chromosome, 
                        ranges = IRanges(start = user_pred$Start, 
                                         end = user_pred$End))
          valid_bins <- gr %in% bird_ranges
          if (! all(valid_bins)) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " lines ", 
                                             paste(which(! valid_bins) + 1, collapse = ", "), 
                                             " contain genomic bins that do not match any BIRD prediction bins. ", 
                                             "Please check the BIRD output range file for a list of BIRD output bins.", 
                                             "\n"))
            next
          }
          if (length(unique(gr)) != length(gr)) {
            sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
                                             name,
                                             " contains repeated genomic bins.", 
                                             "\n"))
            next
          }
          txt_info[['gr']] <- gr
          txt_info[['pred_mat']] <- pred_matrix
          txt_info_list <- list()
          txt_info_list[[name]] <- txt_info
          # Add to upload list
          user_txt_pred_list(c(user_txt_pred_list(), txt_info_list))
        }
      })
    }
  })
  
  # User-input txt sample predictions data.frame
  user_txt_pred_df <- reactiveVal(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
  
  # User-input txt sample genomic ranges data.frame
  user_txt_gr_list <- reactiveVal(list())
  
  # Render sample text file selection submission text
  output$sample_add_txt_submission_msg <- renderText({
    sample_add_txt_submission_msg()
  })
  
  # Update submission text based on text upload and evaluation results
  sample_add_txt_submission_msg <- eventReactive(input$submit_sample_add_txt_file, {
    if (nrow(sample_add_txt_upload_table()) == 0) {
      return(paste("Sample selection failed. No txt file has been uploaded. Please upload BAM files first. "))
    }
    if (length(input$sample_add_txt_upload_table_rows_selected) == 0) {
      return(paste("Sample selection failed. No txt file has been selected in the above table. "))
    }
    sel_rows <- sample_add_txt_upload_table()[input$sample_add_txt_upload_table_rows_selected, ]
    # Check for redundant sample ids
    sel_fnames <- sel_rows$file_name
    sel_samples <- sel_rows$sample
    redundant_ids <- selected_samples()$sample[selected_samples()$sample %in% sel_samples]
    if (any(table(sel_samples) > 1)) {
      return(paste("Sample selection failed. Selected samples have redundant ids."))
    }
    if (length(redundant_ids) > 0) {
      return(paste("Sample selection failed. The following sample ids are already present in current selection:", 
                   paste(redundant_ids, collapse = ", ")))
    }
    # Check if project ranges incompatible with already selected project
    for (fname in unique(sel_fnames)) {
      gr <- user_txt_pred_list()[[fname]]$gr
      project <- unique(sel_rows[sel_fnames == fname, 'project'])
      if (project %in% names(user_txt_gr_list())) {
        sel_proj_gr <- user_txt_gr_list()[[project]]
        if ((! all(gr %in% sel_proj_gr)) || (! all(sel_proj_gr %in% gr))) {
          return(paste("Sample selection failed. Project", 
                       project, 
                       "genomic ranges do not match those of selected samples under same project name."))
        }
      }
    }
    # Check if project ranges are the same for same selected project
    sel_projects <- gsub('\\.txt$', '', sel_fnames)
    for (proj in unique(sel_projects)) {
      proj_files <- unique(sel_rows[sel_rows$project == proj, 'file_name'])
      if (length(proj_files) > 1) {
        for (i in 2:length(proj_files)) {
          gr1 <- user_txt_pred_list()[[proj_files[i-1]]]$gr
          gr2 <- user_txt_pred_list()[[proj_files[i]]]$gr
          if ((! all(gr1 %in% gr2)) || (! all(gr2 %in% gr1))) {
            return(paste("Sample selection failed. Project", 
                         project, 
                         "genomic ranges are not consistent."))
          }
        }
      }
    }
    for (fname in unique(sel_fnames)) {
      gr <- user_txt_pred_list()[[fname]]$gr
      file_samples <- sel_rows[sel_fnames == fname, 'sample']
      project <- sel_rows[sel_fnames == fname, 'project']
      pred_matrix <- user_txt_pred_list()[[fname]]$pred_mat[, file_samples, drop = FALSE]
      hits <- findOverlaps(bird_ranges, gr)
      full_pred <- matrix(0, length(bird_ranges), length(file_samples))
      colnames(full_pred) <- colnames(pred_matrix)
      full_pred[hits@from, ] <- pred_matrix
      # Log-transform
      if (input$sample_add_txt_file_transform == 'none') {
        full_pred <- log2(full_pred + 1)
      }
      # Add samples to selected txt samples data.frame
      user_txt_pred_df(cbind(user_txt_pred_df(), full_pred))
      if (! unique(project) %in% names(user_txt_gr_list())) {
        # Add samples range to selected txt samples range list
        new_gr_list <- list()
        new_gr_list[[unique(project)]] <- gr
        user_txt_gr_list(c(user_txt_gr_list(), new_gr_list))
      }
      # Add samples to selected samples table
      selected_samples(rbind(selected_samples(), data.frame(file_source = paste0("user_txt_upload/", fname), 
                                                            project = project, 
                                                            sample = file_samples)))
    }
    # Clear upload table selected rows
    txt_upload_table_proxy %>% selectRows(NULL)
    return(paste("Samples successfully added to selection. "))
  })
  
  # Define sample selection BAM files upload list
  user_bam_upload_list <- reactiveVal(list())
  
  # Define sample selection BAM files upload table
  sample_add_bam_upload_table <- reactiveVal(setNames(data.frame(matrix(nrow = 0, ncol = 4)), 
                                                      c("name", "reads", "type", "n_covered_bins")))
  
  # Update sample selection BAM files table according to upload list
  observeEvent(user_bam_upload_list(), {
    fnames <- names(user_bam_upload_list())
    type <- sapply(fnames, function(x) {user_bam_upload_list()[[x]]$type})
    reads <- sapply(fnames, function(x) {user_bam_upload_list()[[x]]$reads})
    n_covered_bins <- sapply(fnames, function(x) {user_bam_upload_list()[[x]]$n_covered_bins})
    sample_add_bam_upload_table(data.frame(name = fnames, 
                                           reads = reads, 
                                           type = type, 
                                           n_covered_bins = n_covered_bins))
  })
  
  # Render sample selection BAM files table
  output$sample_add_bam_upload_table <- DT::renderDataTable(sample_add_bam_upload_table(), 
                                                            rownames = FALSE, 
                                                            filter = list(position = 'top', clear = FALSE))
  
  # Make proxy for controlling selected rows
  bam_upload_table_proxy <- DT::dataTableProxy("sample_add_bam_upload_table")
  
  # Update sample selection BAM files upload list and table
  observeEvent(input$sample_add_bam_file, {
    bam_handle <- input$sample_add_bam_file
    filenum <- length(bam_handle$datapath)
    if (!is.null(bam_handle)) {
      user_bam_upload_list(list())
      withProgress(message = 'Reading in BAM files',detail="0%",{
        for (i in 1:filenum) {
          bam_info <- list()
          incProgress(1/filenum, detail=paste0(round(i/filenum*100),"%"))
          name <- bam_handle$name[i]
          bamfile <- BamFile(bam_handle$datapath[i])
          tmpsingle <- readGAlignments(bamfile)
          tmppair <- readGAlignmentPairs(bamfile)
          tmppair <- tmppair[!is.na(as.vector(seqnames(tmppair)))]
          pairendtf <- testPairedEndBam(bamfile)
          if (pairendtf) {
            tmp <- tmppair
            startpos <- pmin(start(first(tmp)),start(last(tmp)))
            endpos <- pmax(end(first(tmp)),end(last(tmp)))
            tmp <- GRanges(seqnames=seqnames(tmp),IRanges(start=startpos,end=endpos))
            bam_info[['type']] <- "paired-end"
          } else {
            tmp <- GRanges(tmpsingle)            
            bam_info[['type']] <- "single-end"
          }
          bam_info[['gr']] <- tmp
          bam_info[['reads']] <- length(tmp)
          hits <- findOverlaps(bird_ranges, tmp)
          bam_info[['n_covered_bins']] <- length(unique(hits@from))
          # Update upload list
          bam_info_list <- list()
          bam_info_list[[name]] <- bam_info
          user_bam_upload_list(c(user_bam_upload_list(), bam_info_list))
        }
      })
    }
  })
  
  # User-input BAM sample predictions data.frame
  user_bam_pred_df <- reactiveVal(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
  
  # Render sample BAM file selection submission text
  output$sample_add_bam_submission_msg <- renderText({
    sample_add_bam_submission_msg()
  })
  
  # Update submission text based on BAM upload and evaluation results
  sample_add_bam_submission_msg <- eventReactive(input$submit_add_bam_file, {
    if (nrow(sample_add_bam_upload_table()) == 0) {
      return(paste("Sample selection failed. No BAM file has been uploaded. Please upload BAM files first. "))
    }
    if (length(input$sample_add_bam_upload_table_rows_selected) == 0) {
      return(paste("Sample selection failed. No BAM file has been selected in the above table. "))
    }
    sel_rows <- sample_add_bam_upload_table()[input$sample_add_bam_upload_table_rows_selected, ]
    # Check for redundant sample ids
    sel_fnames <- sel_rows$name
    # Remove .bam extension
    sel_samples <- gsub(".bam", "", sel_fnames)
    redundant_ids <- selected_samples()$sample[selected_samples()$sample %in% sel_samples]
    if (length(redundant_ids) > 0) {
      return(paste("Sample selection failed. The following sample ids are already present in current selection:", 
                   paste(redundant_ids, collapse = ", ")))
    }
    # Check for samples outside of BIRD prediction range
    empty_samples <- sel_rows[sel_rows$n_covered_bins == 0, 'name']
    empty_samples <- gsub(".bam", "", empty_samples)
    if (length(empty_samples) > 0) {
      return(paste("Sample selection failed. The following samples have 0 reads mapped to BIRD output genomic bins:", 
                   paste(empty_samples, collapse = ", ")))
    }
    # Add samples to selected samples table
    selected_samples(rbind(selected_samples(), data.frame(file_source = "user_bam_upload", 
                                                          project = "bam_upload", 
                                                          sample = sel_samples)))
    # Add samples to uploaded BAM predictions data.frame
    log_pred_df <- sapply(sel_fnames, function(fname) {
      counts <- countOverlaps(bird_ranges, user_bam_upload_list()[[fname]]$gr)
      log2(counts + 1)
    })
    colnames(log_pred_df) <- sel_samples
    user_bam_pred_df(cbind(user_bam_pred_df(), log_pred_df))
    # Clear upload table selected rows
    bam_upload_table_proxy %>% selectRows(NULL)
    return(paste("Samples successfully added to selection. "))
  })
  
  # Remove selected rows from samples table upon button click
  observeEvent(input$rm_sel_samples, {
    if (length(input$sel_samples_table_rows_selected) > 0) {
      rm_rows <- selected_samples()[input$sel_samples_table_rows_selected, ]
      selected_samples(selected_samples()[- input$sel_samples_table_rows_selected, ])
      if (any(startsWith(rm_rows$file_source, "user_txt_upload/"))) {
        rm_projects <- unique(rm_rows[startsWith(rm_rows$file_source, "user_txt_upload/"), "project"])
        rm_samples <- rm_rows[startsWith(rm_rows$file_source, "user_txt_upload/"), "sample"]
        # Remove projects from selected txt samples range list
        updated_gr_list <- user_txt_gr_list()
        updated_gr_list[rm_projects[! rm_projects %in% selected_samples()$project]] <- NULL
        user_txt_gr_list(updated_gr_list)
        # Remove samples from selected txt samples data.frame
        keep_samples <- ! (colnames(user_txt_pred_df()) %in% rm_samples)
        user_txt_pred_df(user_txt_pred_df()[, keep_samples, drop = FALSE])
      } 
      if (any(rm_rows$file_source == "user_bam_upload")) {
        rm_samples <- rm_rows[rm_rows$file_source == "user_bam_upload", "sample"]
        keep_samples <- ! (colnames(user_bam_pred_df()) %in% rm_samples)
        user_bam_pred_df(user_bam_pred_df()[, keep_samples, drop = FALSE])
      }
    }
  })
  
  # Clear selected samples on button click pop-up
  observeEvent(input$clear_sel_samples, {
    showModal(modalDialog(
      p("Clear all selected samples?"), 
      actionButton("clear_sel_samples_confirm", "Yes")
    ))
  })
  
  # Clear selected samples on button click
  observeEvent(input$clear_sel_samples_confirm, {
    selected_samples(setNames(data.frame(matrix(ncol = 3, nrow = 0)), 
                              c("file_source", "project", "sample")))
    user_txt_gr_list(list())
    user_txt_pred_df(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
    user_bam_pred_df(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
    removeModal()
  })
  
  output$download_bird_range_bed <- downloadHandler(
    filename = "BIRD_range.bed", 
    content = function(file) {
      write.table(genomic_ranges, file, quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
    }
  )
  
  # Toggle select all box for all samples ranges in Sample Range Selection Tab
  observe({
    updateCheckboxGroupInput(
      session,
      "all_sel_chr", 
      selected = if (input$all_sel_all_chr) chromosomes
    )
  })
  
  # Update slider range based on numeric input
  lapply(c(1:22, "X"), function(i) {
    observeEvent(input[[paste0("gr", i, "min")]] | input[[paste0("gr", i, "max")]], {
      updateSliderInput(inputId = paste0("all_genomic_range", i), 
                        value = c(input[[paste0("gr", i, "min")]], input[[paste0("gr", i, "max")]]))
    })
  })
  
  # Custom input ranges from range selection tab
  custom_gr <- reactive({
    if (input$all_sel_method == 'Use default range') {
      # Default ranges is around IL6 gene
      return(il6_range)
    } 
    if (input$all_sel_method == 'Use entire BIRD range') {
      # All BIRD output ranges
      return(bird_ranges)
    } 
    if (input$all_sel_method == 'Manual') {
      gr <- GRanges()
      for (chr in input$all_sel_chr) {
        # Get user queried chromosome range from slider input
        range <- input[[paste0("all_genomic_range", sub("chr", "", chr))]]
        chr_gr <- GRanges(seqnames = chr, 
                          ranges = IRanges(start = range[1], end = range[2]))
        gr <- suppressWarnings(c(gr, chr_gr))
      }
      return(gr)
    } 
    # Get custom ranges from BED input
    if (is.null(input$all_bed)) {
      return(GRanges())
    }
    bed_path <- input$all_bed$datapath
    bed_df <- read.table(bed_path)[, 1:3]
    # Check BED file contents
    validate(
      need(all(bed_df[, 1] %in% chromosomes), 
           paste("BED file first column must be chromosomes. Valid values are:", 
                 paste(chromosomes, collapse = ", "))), 
      need(all(bed_df[, 2:3] %% 1 == 0), 
           "BED file second and third columns must be integers")
    )
    return(GRanges(seqnames = bed_df[, 1], 
                   ranges = IRanges(start = bed_df[, 2] + 1, 
                                    end = bed_df[, 3] + 2)))
  })
  
  # Parse genomic bin character vector of format "chr<n> (start-end)" to data.frame
  parse_gbin <- function(gbin_char) {
    range <- sub('chr.*\\(', '', gbin_char)
    range <- sub('\\)', '', range)
    range_list <- strsplit(range, '-')
    start <- unlist(lapply(range_list, function (x) {x[1]}))
    end <- unlist(lapply(range_list, function (x) {x[2]}))
    chromosome <- sub('\\s\\(.*', '', gbin_char)
    data.frame(chromosome = as.factor(chromosome), start = as.integer(start), end = as.integer(end))
  }
  
  n_bins_selected <- reactiveVal(0)
  
  observe({
    n_bins <- 0 
    for (chr in levels(seqnames(custom_gr()))) {
      hits <- findOverlaps(chr_ranges[[chr]], custom_gr())
      n_bins <- n_bins + length(levels(as.factor(hits@from)))
    }
    n_bins_selected(n_bins)
  })
  
  # Message showing number of selected bins
  output$n_bins_msg <- renderUI({
    HTML(paste("<p>The selected genomic positions contain", strong(n_bins_selected()), "BIRD prediction bins. </p>"))
  })
  
  # Reactive value that stores all studies predictions read so far
  studies_mat_li <- reactiveVal(list())
  
  # Read predictions for studies that have not been downloaded yet
  read_studies_pred <- function(studies) {
    studies <- setdiff(studies, names(studies_mat_li()))
    if (length(studies) > 0) {
      showModal(modalDialog("Retrieving predictions...", footer = NULL, easyClose = TRUE, size = "s"))
      pred_li <- lapply(match(studies, studies_batch$study), function(i) {
        rds_url <- paste0("http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b", 
                          studies_batch$batch[i], 
                          "/", studies_batch$study[i], ".rds")
        readRDS(url(rds_url))
      })
      names(pred_li) <- studies
      studies_mat_li(c(studies_mat_li(), pred_li))
      removeModal()
    }
  }
  
  # Get all predictions for selected database samples in data.frame
  get_database_pred_df <- function(custom_range) {
    database_studies <- unique(selected_samples()$project[selected_samples()$read_from == "database"])
    read_studies_pred(database_studies)
    # Subset selected samples and range for each study
    hits <- findOverlaps(bird_ranges, custom_range)
    bird_i <- sort(unique(hits@from))
    if (length(database_studies) == 0) {
      return(genomic_ranges[bird_i, , drop=F])
    }
    all_pred_li <- lapply(as.character(database_studies), function(study) {
      sel_samples <- selected_samples()$sample[(selected_samples()$project == study) & 
                                                 (selected_samples()$read_from == "database")]
      study_mat <- studies_mat_li()[[study]]
      study_mat[bird_i, sel_samples, drop=F]
    })
    pred_mat <- do.call(cbind, all_pred_li)
    all_pred_df <- cbind(genomic_ranges[bird_i, , drop=F], pred_mat)
    return(all_pred_df)
  }
  
  # Get all predictions for selected local samples in matrix
  get_local_pred_mat <- function(custom_range) {
    local_studies <- unique(selected_samples()$project[selected_samples()$read_from == "local"])
    # Subset selected samples and range for each study
    hits <- findOverlaps(bird_ranges, custom_range)
    bird_i <- sort(unique(hits@from))
    all_pred_li <- lapply(as.character(local_studies), function(study) {
      sel_samples <- selected_samples()$sample[(selected_samples()$project == study) & 
                                                 (selected_samples()$read_from == "local")]
      study_mat <- loc_studies_li()[[study]]
      study_mat[bird_i, sel_samples, drop=F]
    })
    pred_mat <- do.call(cbind, all_pred_li)
    return(pred_mat)
  }
  
  # UI for download buttons
  output$download_zip_txt_ui <- renderUI({
    if (sum(selected_samples()$read_from == "database") == 0) {
      textOutput("download_msg_zip_txt")
    } else if (length(custom_gr()) == 0) {
      p("Please select at least 1 genomic bin. ")
    } else {
      tagList(
        textOutput("download_msg_zip_txt"),
        downloadButton("txt_download", "Download txt file"),
        downloadButton("zip_download", "Download zip file")
      )
    }
  })
  
  # UI for download buttons
  output$download_bw_ui <- renderUI({
    if (nrow(selected_samples()) == 0) {
      textOutput("download_msg_bw")
    } else {
      tagList(
        textOutput("download_msg_bw"),
        p("The entire BIRD prediction (with all genomic bins) is written to BigWig output."),
        downloadButton("bw_download", "Download BigWig file")
      )
    }
  })
  
  # UI for UCSC hub session files download
  output$ucsc_hub_ui <- renderUI({
    if (nrow(selected_samples()) == 0) {
      textOutput("download_msg_bw")
    } else {
      tagList(
        p("To show the tracks of selected predictions on our UCSC Genome Browser Hub, 
          you need to upload a session file to UCSC genome browser. "),
        p("Go to ", tags$a(href="https://genome.ucsc.edu/", "https://genome.ucsc.edu/", target="_blank"), 
          " -> My Data -> My Sessions -> Restore Settings -> Use settings from a local file -> submit. "),
        p("Please note that you can view all predictions on all genomic positions 
          on UCSC Genome Browser by toggling display region and subtracks visibility."), 
        radioButtons("ucsc_session_range_type",
                     "Track position: ", 
                     choices = c("First 100,000bp of selected region" = "100kb", 
                                 "Entire selected region in one chromosome" = "1chr", 
                                 "All selected regions" = "all")),
        uiOutput("ucsc_session_range_ui"), 
        downloadButton("ucsc_session_download", "Download session file")
      )
    }
  })
  
  output$ucsc_session_range_ui <- renderUI({
    if (input$ucsc_session_range_type == "100kb") {
      radioButtons("ucsc_session_sel_chr", 
                   "The first 100,000bp of selected range in the following selected 
                   chromosome will be displayed on UCSC genome browser: ", 
                   choices = sort(unique(as.character(seqnames(custom_gr())))), 
                   selected = sort(unique(as.character(seqnames(custom_gr()))))[1])
    } else if (input$ucsc_session_range_type == "1chr") {
      radioButtons("ucsc_session_sel_chr", 
                   "The entire selected selected range in the following selected 
                   chromosome will be displayed on UCSC genome browser: ", 
                   choices = sort(unique(as.character(seqnames(custom_gr())))), 
                   selected = sort(unique(as.character(seqnames(custom_gr()))))[1])
    } else if (input$ucsc_session_range_type == "all") {
      sel_reg <- c("#database hg38", "#shortDesc Selected range of BIRD prediction", "#padding 6")
      sel_chr <- unique(seqnames(custom_gr()))
      region_start <- sapply(sel_chr, function(chr) {
        min(start(custom_gr()[seqnames(custom_gr()) == chr]))
      })
      region_end <- sapply(sel_chr, function(chr) {
        max(end(custom_gr()[seqnames(custom_gr()) == chr]))
      })
      sel_reg <- c(sel_reg, capture.output(write.table(data.frame(sel_chr, region_start, region_end), 
                                                       row.names = F, col.names = F, quote = F)))
      tagList(
        p("After loading the session file on UCSC Genome Browser, please click on 
        multi-region -> Enter custom regions as BED -> paste the following BED 
        file into the text area -> Submit to configure multi-region view. "), 
        rclipButton(
          inputId = "ucsc_session_multi_region_bed_copy", 
          label = "Copy BED3 of all selected regions", 
          clipText = paste(sel_reg, collapse = "\n"), 
          icon = icon("clipboard"), 
          style = "border: 1px solid white;"
        )
      )
    }
  })
  
  # UI for rds download
  output$download_rds_ui <- renderUI({
    if (sum(selected_samples()$read_from == "database") == 0) {
      p("No sample selected. Please select input samples from Input Selection Tab. ")
    } else {
      studies <- unique(selected_samples()$project[selected_samples()$read_from == "database"])
      tagList(
        p(paste("The samples you selected come from the following studies:", 
                paste(studies, collapse = ", "))), 
        downloadButton("rds_download", "Download rds file(s)")
      )
    }
  })
  
  # Txt download
  output$txt_download <- downloadHandler(
    filename = "BIRD_prediction.txt", 
    content = function(file) {
      # Make single txt file
      pred_df <- get_database_pred_df(custom_gr())
      write.table(pred_df, file, row.names = FALSE, quote = FALSE, sep = "\t")
    }
  )
  
  # Zip download
  output$zip_download <- downloadHandler(
    filename = "BIRD_prediction.zip",
    content = function(file) {
      # Make zip file
      # Create temp folder to hold prediction files
      tmp <- tempfile(pattern = "zip", tmpdir = tmp_dir)
      dir.create(tmp)
      tmp_fpaths <- c()
      # Write the appropriate prediction to table
      pred_df <- get_database_pred_df(custom_gr())
      predict_sample <- selected_samples()$sample[selected_samples()$read_from == "database"]
      for (i in 1:length(predict_sample)) {
        sample_id <- predict_sample[i]
        fname <- paste0(sample_id, "_BIRD_prediction", ".txt")
        pred_file <- write.table(pred_df[, c('Chromosome', 'Start', 'End', sample_id)], 
                                 file.path(tmp, fname), row.names = FALSE, quote = FALSE, sep = "\t")
        tmp_fpaths <- append(tmp_fpaths, file.path(tmp, fname))
      }
      zip(zipfile = file, files = tmp_fpaths, extras = '-j')
      unlink(tmp, recursive = TRUE)
    }
  )
  
  # BigWig download
  output$bw_download <- downloadHandler(
    filename = "BIRD_prediction_bw.zip",
    content = function(file) {
      # Make zip file
      # Create temp folder to hold bigwig files (1 file for each sample)
      tmp <- tempfile(pattern = "bigwig", tmpdir = tmp_dir)
      dir.create(tmp)
      tmp_fpaths <- c()
      for (i in 1:nrow(selected_samples())) {
        study <- as.character(selected_samples()$project[i])
        sample <- selected_samples()$sample[i]
        batch <- studies_batch$batch[studies_batch$study == study]
        fname <- paste0(sample, ".bw")
        download.file(paste0("http://jilab.biostat.jhsph.edu/software/PDDB/bigwig/b", batch, "/", sample, ".bw"), 
                      file.path(tmp, fname))
        tmp_fpaths <- append(tmp_fpaths, file.path(tmp, fname))
      }
      zip(zipfile = file, files = tmp_fpaths, extras = '-j')
      unlink(tmp, recursive = TRUE)
    }
  )
  
  # UCSC session file download
  output$ucsc_session_download <- downloadHandler(
    filename = "BIRD_hub_session.txt",
    content = function(file) {
      if (input$ucsc_session_range_type != "all") {
        # Display only 1 chromosome region
        chr <- input$ucsc_session_sel_chr
        if (is.null(chr)) {
          chr <- sort(unique(as.character(seqnames(custom_gr()))))[1]
        }
        if (input$ucsc_session_range_type == "100kb") {
          region_start <- min(start(custom_gr()[seqnames(custom_gr()) == chr]))
          region_end <- region_start + 100000 - 1
        } else if (input$ucsc_session_range_type == "1chr") {
          region_start <- min(start(custom_gr()[seqnames(custom_gr()) == chr]))
          region_end <- max(end(custom_gr()[seqnames(custom_gr()) == chr]))
        }
      } else {
        # Display all selected regions -> only display first 10kb region in session file
        chr <- sort(unique(seqnames(custom_gr())))[1]
        region_start <- min(start(custom_gr()[seqnames(custom_gr()) == chr]))
        region_end <- region_start + 10000 - 1
      }
      hub_id <- "4835692"
      args <- c("c", "clade", "db", "dinkL", "dinkR", "dirty", "g", 
                paste0("hgHubConnect.hub.", hub_id), 
                "hgt_doJsCommand", 
                "hgtgroup_compGeno_close",
                "hgtgroup_denisova_close",
                "hgtgroup_expression_close",
                "hgtgroup_genes_close",
                "hgtgroup_hub_51309_close",
                "hgtgroup_map_close",
                "hgtgroup_neandertal_close",
                "hgtgroup_phenDis_close",
                "hgtgroup_regulation_close",
                "hgtgroup_rep_close",
                "hgtgroup_rna_close",
                "hgtgroup_varRep_close",
                paste0("hub_", hub_id, "_BIRD_predictions.displaySubtracks"),
                "knownGene.label.gene",
                "org",
                "pix",
                "position",
                "trackHubs")
      args <- c(args, paste0("hub_", hub_id, "_", selected_samples()$sample, "_sel"))
      vals <- c(chr, "mammal", "hg38", "2.0", "2.0", "false", 
                paste0("hub_", hub_id, "_BIRD_predictions"), 
                "1", "", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0", "0", "0", 
                "selected", "1", "Human", "1000", 
                paste0(chr, ":", region_start, "-", region_end), 
                hub_id, rep("1", nrow(selected_samples())))
      write.table(data.frame(args=args, vals=vals), file, row.names = F, col.names = F, quote = F)
    }
  )
  
  # RDS file download
  output$rds_download <- downloadHandler(
    filename = {
      proj <- unique(selected_samples()$project[selected_samples()$read_from == "database"])
      if (length(proj) == 1) {
        paste0(proj, ".rds")
      } else {"studies_rds.zip"}
    }, 
    content = function(file) {
      proj <- unique(selected_samples()$project[selected_samples()$read_from == "database"])
      batch <- studies_batch$batch[match(proj, studies_batch$study)]
      if (length(proj) == 1) {
        download.file(paste0("http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b", 
                             batch, "/", proj, ".rds"), file)
      } else {
        # Make zip file
        # Create temp folder to hold prediction files
        tmp <- tempfile(pattern = "rds", tmpdir = tmp_dir)
        dir.create(tmp)
        tmp_fpaths <- c()
        for (i in 1:length(proj)) {
          fname <- paste0(proj[i], ".rds")
          proj_file <- file.path(tmp, fname)
          download.file(paste0("http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b", 
                               batch[i], "/", proj[i], ".rds"), proj_file)
          tmp_fpaths <- append(tmp_fpaths, proj_file)
        }
        zip(zipfile = file, files = tmp_fpaths, extras = '-j')
        unlink(tmp, recursive = TRUE)
      }
    }
  )
  
  db_download_msg <- reactive({
    if (sum(selected_samples()$read_from == "database")) {
      paste0("Download selected genomic ranges of predictions for samples: ", 
             paste(selected_samples()$sample, collapse = ", ")) 
    } else {
      paste("No sample selected from database. Please select input samples from Input Selection Tab with \"Select from prediction database\" option. ")
    }
  })
  
  output$download_msg_zip_txt <- renderText({ 
    if (sum(selected_samples()$read_from == "database")) {
      paste0("Download selected genomic ranges of predictions for samples: ", 
             paste(selected_samples()$sample[selected_samples()$read_from == "database"], collapse = ", ")) 
    } else {
      paste("No sample selected from database. Please select more input samples from Input Selection Tab with \"Select from prediction database\" option. ")
    }
  })
  
  output$download_msg_bw <- renderText({
    if (nrow(selected_samples()) > 0) {
      paste0("Download full predictions for samples: ", 
             paste(selected_samples()$sample, collapse = ", ")) 
    } else {
      paste("No sample selected from database. Please select samples from Input Selection Tab. ")
    }
  })
  
  output$pca_page_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to perform PCA. ")
    } else if (n_bins_selected() < 2) {
      p("You must select at least 2 genomic bins to perform PCA. ")
    } else {
      tagList(
        sliderInput(
          "pca_top_var", 
          label = tags$span("Number of top variance rows to use in PCA computation", 
                            bsButton("pca_top_var_info", 
                                     label = "", 
                                     icon = icon("info"),
                                     style = "info", 
                                     size = "extra-small")), 
          min = 1000, 
          max = 10000, 
          value = 2000, 
          step = 100
        ),
        bsPopover(
          id = "pca_top_var_info",
          title = "<h4>PCA top variance genomic bins</h4>",
          content = do.call(paste0, 
                            popover_contents$pca_top_var_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        tabsetPanel(
          tabPanel(
            "PCA Results", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px",
              uiOutput("pca_ui")
            )
          ), 
          tabPanel(
            "Pseudo-time Analysis", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px",
              uiOutput("pt_options_ui")
            )
          ), 
          tabPanel(
            "Pseudo-time Differential Test", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px",
              uiOutput("pt_diff_ui")
            )
          )
        )
      )
    }
  })
  
  # Predictions as numeric matrix with rows being genomic bins and columns being samples
  pred_mat <- reactive({
    req(nrow(selected_samples()) > 0)
    database_pred_df <- get_database_pred_df(custom_gr())
    local_samps <- selected_samples()[selected_samples()$read_from == "local", c("project", "sample")]
    local_pred_mat <- get_local_pred_mat(custom_gr())
    if (length(local_samps) == 0) {
      # Only have database samples
      pred_mat <- data.matrix(sapply(database_pred_df[, 4:ncol(database_pred_df)], as.numeric))
    } else if (ncol(database_pred_df) > 3) {
      # Have both local and database samples
      pred_mat <- data.matrix(sapply(database_pred_df[, 4:ncol(database_pred_df)], as.numeric))
      pred_mat <- cbind(pred_mat, local_pred_mat)
    } else {
      # Only have local samples
      pred_mat <- local_pred_mat
    }
    chr_loc <- paste0(database_pred_df$Chromosome, ' (', database_pred_df$Start, '-', database_pred_df$End, ')')
    rownames(pred_mat) <- chr_loc
    return(pred_mat)
  })
  
  # Get hyper variance of each row in data
  hypervar_bulk <- function(data){
    
    data <- as.matrix(data)
    
    gene_mean_all <- rowMeans(data)
    gene_var_all <- rowVars(data)
    
    data_filter <- data[gene_mean_all > 0 & gene_var_all > 0,]
    
    gene_mean <- rowMeans(data_filter)
    gene_var <- rowVars(data_filter)
    
    data_fit <- data.frame(X=gene_mean,Y=gene_var)
    
    fit_model <- tryCatch(
      {gam(formula = log2(x=Y) ~ s(log2(x=X)), data = data_fit)}, 
      error = function(e) {
        k <- min(50, min(apply(data_fit, 2, function(x){length(unique(x))})))
        gam(formula = log2(x=Y) ~ s(log2(x=X), k=k), data = data_fit)
      }
    )
    
    gene_var_expect <- 2^(fit_model$fitted.values)
    gene_sd_expect <- sqrt(gene_var_expect)
    
    gene_var_norm <- (data_filter - gene_mean)/gene_sd_expect
    gene_hyper_var <- rowSums(gene_var_norm^2)/(ncol(data_filter) - 1)
    
    result <- data.frame(feature=row.names(data_filter), mean=gene_mean, var=gene_var,
                         var_expect=gene_var_expect,hypervar=gene_hyper_var)
    
    return(result)
  }
  
  # Hyper variance of each row (genomic bin) of prediction
  pred_hypervar <- reactive({
    pred_matrix <- pred_mat()
    showModal(modalDialog("Calculating hyper variance for each row...", footer = NULL, easyClose = TRUE, size = "s"))
    hypervar <- hypervar_bulk(pred_matrix)
    removeModal()
    return(hypervar)
  })
  
  # PCA top variance filtered prediction matrix
  pca_top_var_pred_mat <- reactive({
    # Calculate hyper variance for each bin
    n_top_var <- min(input$pca_top_var, nrow(pred_hypervar()))
    top_var_idx <- base::sort(pred_hypervar()$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    top_var_idx <- base::sort(top_var_idx)
    
    # Filter prediction matrix by top variance rows
    return(pred_mat()[pred_hypervar()$feature[top_var_idx], ])
  })
  
  # Get PCA result
  pca_res_full <- reactive({
    if (! all(is.na(pred_hypervar()))) {
      pred_mat_sorted <- t(pca_top_var_pred_mat())
      
      # Remove near zero variance columns
      if (length(nearZeroVar(pred_mat_sorted)) > 0) {
        pred_mat_sorted <- pred_mat_sorted[, - nearZeroVar(pred_mat_sorted)]
      }
      
      if (any(dim(pred_mat_sorted) == 0)) {
        return(NA)
      }
      
      showModal(modalDialog("Performing PCA...", footer = NULL, easyClose = TRUE, size = "s"))
      pca_result <- prcomp(pred_mat_sorted, 
                           scale = TRUE)
      
      removeModal()
      
      return(pca_result)
    } 
    return(NA)
  })
  
  # Get transformed vectors from PCA result
  pca_res <- reactive({
    if (! all(is.na(pca_res_full()))) {
      res <- data.frame(pca_res_full()$x)
      # Sort result columns by PC
      return(res[, paste0("PC", 1:ncol(res))])
    }
    return(NA)
  })
  
  # Get optimal number of PCs
  opt_n_pc <- reactive({
    sdev <- pca_res_full()$sdev
    # Only consider first 30 PCs
    #sdev <- sdev[1:min(30,length(sdev))]
    x <- 1:length(sdev)
    pcadim <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(sdev~x+x2)$residuals^2)
    }))
    pcadim
  })
  
  # Render panel with PCA results or message if no results can be generated
  output$pca_plot_ui <- renderUI({
    if (all(is.na(pca_res())) || ncol(pca_res()) < 2) {
      p("Too few genomic bins with significant variance.")
    } else {
      tagList(
        h4("PCA plot"),
        plotOutput("pca_plot", brush = "pca_plot_brush", width = 600, height = 500), 
        bsTooltip("pca_plot", 
                  title = "In this PCA plot, each point is a sample you selected. You can brush on this plot to see specific samples information in a table", 
                  placement = "top"),
        actionButton("pca_plot_download", "Download plot"), 
        hr(),
        # Display table with brushed samples
        h4("PCA plot brushed points table"),
        DT::dataTableOutput('pca_brushed')
      )
    }
  })
  
  # Which plot are we downloading
  download_plot <- reactiveVal(NULL)
  
  # Show modal for plot parameter selection
  observeEvent(download_plot(), {
    showModal(
      modalDialog(
        title = "Plot download options", 
        selectInput(
          "plot_download_format", 
          "Format: ", 
          c("png", "tiff", "pdf", "eps")
        ), 
        # Units and color model
        uiOutput("plot_download_format_opt_ui"),
        uiOutput("plot_download_dim_ui"), 
        fluidRow(
          column(
            width = 6, 
            selectInput(
              "plot_download_font", 
              "Font: ", 
              c("Arial"="sans", 
                "Times New Roman"="serif", 
                "Courier"="mono", 
                "Standard Symbols"="symbol")
            )
          ), 
          column(
            width = 6,
            uiOutput("plot_download_ppi_ui")
          )
        ), 
        downloadButton("plot_download", "Confirm and download"), 
        easyClose = FALSE, 
        footer = actionButton("close_plot_download_modal", "Close")
      )
    )
  })
  
  # Render UI for plot download format-specific options
  output$plot_download_format_opt_ui <- renderUI({
    req(input$plot_download_format)
    if (input$plot_download_format %in% c("pdf", "eps")) {
      fluidRow(
        column(
          width = 6, 
          selectInput(
            "plot_download_units", 
            "Units: ", 
            list("inches" = "in", 
                 "cm" = "cm", 
                 "mm" = "mm")
          )
        ), 
        column(
          width = 6, 
          selectInput(
            "plot_download_color_model", 
            "Color model: ", 
            list("RGB" = "srgb", 
                 "CMYK" = "cmyk", 
                 "Grayscale" = "gray")
          )
        )
      )
    } else {
      fluidRow(
        column(
          width = 6, 
          selectInput(
            "plot_download_units", 
            "Units: ", 
            list("pixels" = "px", 
                 "inches" = "in", 
                 "cm" = "cm", 
                 "mm" = "mm")
          )
        )
      )
    }
  })
  
  # Render UI for plot download dimensions
  output$plot_download_dim_ui <- renderUI({
    req(input$plot_download_format)
    dim_min <- 4
    dim_max <- 40
    if (input$plot_download_format %in% c("png", "tiff")) {
      req(input$plot_download_units)
      if (input$plot_download_units == "px") {
        dim_min <- 400
        dim_max <- 4000
      } else if (input$plot_download_units == "cm") {
        dim_min <- 100
        dim_max <- 1000
      } else if (input$plot_download_units == "mm") {
        dim_min <- 1000
        dim_max <- 10000
      }
    }
    default_height <- dim_min * 2
    default_width <- dim_min * 2.5
    fluidRow(
      column(
        width = 6,
        sliderInput(
          "plot_download_width", 
          "Width: ", 
          min = dim_min, 
          max = dim_max, 
          value = default_width
        )
      ), 
      column(
        width = 6,
        sliderInput(
          "plot_download_height", 
          "Height: ", 
          min = dim_min, 
          max = dim_max, 
          value = default_height
        )
      )
    )
  })
  
  # Render ppi selection for all formats except pdf
  output$plot_download_ppi_ui <- renderUI({
    req(input$plot_download_format)
    if (input$plot_download_format %in% c("pdf", "eps")) {
      return(NULL)
    } else {
      selectInput(
        "plot_download_ppi", 
        "Resolution (ppi): ", 
        c(72, 96, 300, 600, 900, 1200)
      )
    }
  })
  
  # Download plot
  output$plot_download <- downloadHandler(
    filename = function() {paste0("plot.", input$plot_download_format)},
    content = function(file) {
      if (input$plot_download_format == "png") {
        png(filename = file, 
            width = input$plot_download_width, 
            height = input$plot_download_height, 
            units = input$plot_download_units, 
            res = input$plot_download_ppi, 
            family = input$plot_download_font)
        print(download_plot())
        dev.off()
      } else if (input$plot_download_format == "tiff") {
        tiff(filename = file, 
            width = input$plot_download_width, 
            height = input$plot_download_height, 
            units = input$plot_download_units, 
            res = input$plot_download_ppi, 
            family = input$plot_download_font)
        print(download_plot())
        dev.off()
      } else if (input$plot_download_format == "pdf") {
        inch_width <- input$plot_download_width
        inch_height <- input$plot_download_height
        if (input$plot_download_units == "px") {
          inch_width <- inch_width / input$plot_download_ppi
          inch_height <- inch_height / input$plot_download_ppi
        } else if (input$plot_download_units == "cm") {
          inch_width <- inch_width / 2.54
          inch_height <- inch_height / 2.54
        } else if (input$plot_download_units == "mm") {
          inch_width <- inch_width / 25.4
          inch_height <- inch_height / 25.4
        }
        pdf(file = file, 
            width = inch_width, 
            height = inch_height, 
            family = input$plot_download_font, 
            colormodel = input$plot_download_color_model)
        print(download_plot())
        dev.off()
      } else if (input$plot_download_format == "eps") {
        inch_width <- input$plot_download_width
        inch_height <- input$plot_download_height
        if (input$plot_download_units == "px") {
          inch_width <- inch_width / input$plot_download_ppi
          inch_height <- inch_height / input$plot_download_ppi
        } else if (input$plot_download_units == "cm") {
          inch_width <- inch_width / 2.54
          inch_height <- inch_height / 2.54
        } else if (input$plot_download_units == "mm") {
          inch_width <- inch_width / 25.4
          inch_height <- inch_height / 25.4
        }
        postscript(file = file, 
                   width = inch_width, 
                   height = inch_height,  
                   family = input$plot_download_font, 
                   colormodel = input$plot_download_color_model)
        print(download_plot())
        dev.off()
      }
    }
  )
  
  # Close plot parameter selection modal when asked to
  observeEvent(input$close_plot_download_modal, {
    download_plot(NULL)
    removeModal()
  })
  
  # PCA plot
  pca_plot <- reactive({
    if (!all(is.na(pca_res())) && ncol(pca_res()) >= 2) {
      top_pcs <- pca_res()[, 1:2]
      proj <- selected_samples()$project
      g <- ggplot(data = top_pcs, 
                  mapping = aes(PC1, PC2, colour = factor(proj))) + geom_point()
      g$labels$colour <- "Project"
      explained_var <- data.frame(t(summary(pca_res_full())$importance))
      explained_var <- explained_var[paste0('PC', 1:2), 'Proportion.of.Variance']
      g <- g + xlab(paste0("PC1 (", explained_var[1]*100, "%)")) + ylab(paste0("PC2 (", explained_var[2]*100, "%)"))
      g
    }
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pca_plot_download, {
    download_plot(pca_plot())
  })
  
  # Render PCA plot
  output$pca_plot <- renderPlot({
    pca_plot()
  })
  
  # Render PCA brushed points table
  observeEvent(input$pca_plot_brush, {
    top_pcs <- pca_res()[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$pca_plot_brush, xvar = "PC1", yvar = "PC2"))
    output$pca_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                              rownames = FALSE,
                                              filter = list(position = 'top', clear = FALSE), 
                                              selection = "none")
  })
  
  pca_var_plot <- reactive({
    explained_var <- data.frame(t(summary(pca_res_full())$importance))
    explained_var <- explained_var[paste0('PC', 1:min(10, nrow(explained_var))), ]
    var_plot <- ggplot(data = explained_var, 
                       mapping = aes(factor(rownames(explained_var), levels = rownames(explained_var)), 
                                     explained_var$Proportion.of.Variance, group=1))
    var_plot <- var_plot + geom_line() + geom_point()
    var_plot <- var_plot + xlab("Principal Components") + ylab("Proportion of Variance Explained")
    var_plot <- var_plot + geom_text(aes(label=explained_var$Proportion.of.Variance), vjust=-0.25)
    var_plot
  })
  
  # Render PCA variance plot
  output$pca_var_plot <- renderPlot({
    pca_var_plot()
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pca_var_plot_download, {
    download_plot(pca_var_plot())
  })
  
  pca_cumvar_plot <- reactive({
    cumvar <- data.frame(t(summary(pca_res_full())$importance))
    cumvar <- cumvar[paste0('PC', 1:min(10, nrow(cumvar))), ]
    cumvar_plot <- ggplot(data = cumvar, 
                          mapping = aes(factor(rownames(cumvar), levels = rownames(cumvar)), 
                                        cumvar$Cumulative.Proportion, group=1))
    cumvar_plot <- cumvar_plot + geom_line() + geom_point()
    cumvar_plot <- cumvar_plot + geom_vline(xintercept = paste0('PC', opt_n_pc()), linetype = "dashed")
    cumvar_plot <- cumvar_plot + xlab("Principal Components") + ylab("Cumulative Proportion of Variance Explained")
    cumvar_plot <- cumvar_plot + geom_text(aes(label=cumvar$Cumulative.Proportion), vjust=-0.25)
    cumvar_plot
  })
  
  # Render PCA cumulative variance plot
  output$pca_cumvar_plot <- renderPlot({
    pca_cumvar_plot()
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pca_cumvar_plot_download, {
    download_plot(pca_cumvar_plot())
  })
  
  # Render PCA results UI panel
  output$pca_ui <- renderUI({
    tagList(selectizeInput(
      "pca_show_graph", 
      label = "Choose graph to display: ", 
      choices = c("PCA Plot", "Explained Variance", "Cumulative Explained Variance"), 
      options = list(placeholder = "", 
                     onInitialize = I('function() { this.setValue(""); }'))
    ),
    uiOutput("pca_graph_ui"))
  })
  
  # PCA graphs
  output$pca_graph_ui <- renderUI({
    req(input$pca_show_graph)
    if (input$pca_show_graph == "PCA Plot") {
      # Output PCA plot
      uiOutput("pca_plot_ui")
    } else if (input$pca_show_graph == "Explained Variance") {
      # Output explained variance plot
      tagList(
        h4("PCA explained variance plot"),
        plotOutput("pca_var_plot"), 
        actionButton("pca_var_plot_download", "Download plot")
      )
    } else {
      # Output cumulative variance plot
      tagList(
        h4("PCA cumulative explained variance plot"), 
        plotOutput("pca_cumvar_plot"), 
        bsTooltip("pca_cumvar_plot", 
                  title = "The dashed line indicates the optimal number of PCs calculated by elbow method", 
                  placement = "top"), 
        actionButton("pca_cumvar_plot_download", "Download plot")
      )
    }
  })
  
  # Update chosen number of PCs on optimal choice check box
  observeEvent(input$use_opt_n_pc, {
    if (input$use_opt_n_pc) {
      updateSliderInput(
        session, 
        "pt_n_pc", 
        value = max(2, opt_n_pc())
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of PCs
  observeEvent(input$pt_n_pc, {
    if (input$pt_n_pc != max(2, opt_n_pc())) {
      updateCheckboxInput(
        session, 
        "use_opt_n_pc", 
        value = FALSE
      )
    }
  })
  
  # Message stating the optimal number of clusters
  output$opt_n_pc_msg <- renderUI({
    HTML(paste("Optimal number of PCs:", strong(opt_n_pc())))
  })
  
  # Render options for pseudo time computation
  output$pt_options_ui <- renderUI({
    if (!all(is.na(pca_res())) && ncol(pca_res()) >= 2) {
      sidebarLayout(
        sidebarPanel(
          tags$div(style = "display:inline-block; vertical-align:middle;", h4("Pseudo-time trajectory computation parameters")), 
          tags$div(style = "display:inline-block; vertical-align:middle;", 
                   bsButton("pt_param_info", 
                            label = "", 
                            icon = icon("info"), 
                            info = "info", 
                            size = "extra-small")), 
          bsPopover("pt_param_info", 
                    title = "<h4>Pseudo-time trajectory computation</h4>", 
                    content = do.call(paste0, popover_contents$pt_param_info), 
                    placement = "right", 
                    trigger = "focus", 
                    options = list(container = "body", 
                                   html = TRUE)),
          wellPanel(
            sliderInput(
              "pt_n_pc", 
              label = "Number of PCs to use for pseudo-time computation: ", 
              min = 2, 
              max = min(30, ncol(pca_res())), 
              value = max(opt_n_pc(), 2), 
              step = 1
            ), 
            bsTooltip("pt_n_pc", 
                      title = "The pseudo-time computation is based on a reduced PCA matrix. ", 
                      placement = "right", 
                      options = list(container = "body")), 
            checkboxInput(
              "use_opt_n_pc", 
              label = "Use optimal number of PCs", 
              value = TRUE
            ),
            htmlOutput('opt_n_pc_msg'), 
            bsTooltip("opt_n_pc_msg", 
                      title = "The number of optimal PCs is computed by elbow method on cumulative explained variance. ", 
                      placement = "right", 
                      options = list(container = "body"))
          ),
          wellPanel(
            sliderInput(
              "pt_range", 
              label = "Number of anchoring clusters for pseudo time: ", 
              min = 2, 
              max = min(15, nrow(pca_res())), 
              value = c(2, min(15, nrow(pca_res()))),
              step = 1
            ), 
            bsTooltip("pt_range", 
                      title = "The anchoring clusters are computed using k-means. ", 
                      placement = "right", 
                      options = list(container = "body")), 
            htmlOutput('opt_n_pt_msg'), 
            bsTooltip("opt_n_pt_msg", 
                      title = "The optimal number of anchoring clusters is selected from the set range of cluster numbers using elbow method. ", 
                      placement = "right", 
                      options = list(container = "body"))
          ),
          wellPanel(uiOutput('pt_sel_traj_ui'))
        ),
        mainPanel(
          fluidRow(
            column(
              width = 4, 
              selectInput(
                "pt_show_panel", 
                label = "Choose pseudo-time analysis result panel to display: ", 
                choices = c("Pseudo-time Trajectory", 
                            "Accessibility along pseudotime", 
                            "Nearest gene expression along pseudotime"), 
                selected = "Pseudo-time Trajectory"
              )
            ), 
            column(
              width = 8, 
              uiOutput("pt_dat_along_pt_ui")
            )
          ),
          uiOutput("pt_ui")
        )
      )
    } else {
      p("You must have valid PCA result before computing pseudo-time sample clusters.")
    }
  })
  
  # Render UI for selecting data type plot along pseudotime
  output$pt_dat_along_pt_ui <- renderUI({
    req(input$pt_dat_along_pt_ui)
    if (input$pt_show_panel == "Accessibility along pseudotime") {
      tagList(
        fluidRow(
          column(
            width = 6, 
            selectInput(
              "pt_chracc_dat_type", 
              "Which accessibility to visualize along pseudotime: ", 
              choices = c("Genomic bin clusters", 
                          "Individual genomic bin", 
                          "Gene average")
            )
          ), 
        )
      )
    } else if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
      tagList(
        fluidRow(
          column(
            width = 6, 
            selectInput(
              "pt_expr_dat_type", 
              "Which expression to visualize along pseudotime: ", 
              choices = c("Genomic bin clusters", 
                          "Individual genomic bin", 
                          "Gene average")
            )
          ), 
        )
      )
    }
  })
  
  # Render pseudo time output UI
  output$pt_ui <- renderUI({
    req(input$pt_show_panel)
    if (input$pt_show_panel == "Pseudo-time Trajectory") {
      # Make plot for pseudo-time trajectory over sample clusters
      tagList(
        h3("Pseudotime trajectory"), 
        downloadButton('pt_traj_samples_order_download', "Download sample ids ordered by pseudo-time"),
        checkboxInput(
          "pt_traj_show_clustering_table", 
          label = "Show clustering table"
        ),
        uiOutput('pt_traj_clustering_table_ui'),
        checkboxInput(
          "pt_traj_show_sample_names", 
          label = "Show sample names in plot"
        ),
        uiOutput('pt_traj_sample_name_size_ui'),
        radioButtons(
          'pt_traj_color', 
          label = "Color by:",
          choices = c("Anchoring clusters", 
                      "Pseudotime")
        ),
        uiOutput('pt_traj_show_side_branch_ui'),
        h4("Pseudotime trajectory plot"),
        plotOutput('pt_traj', brush = 'pt_traj_brush'), 
        actionButton("plot_traj_plot_download", "Download plot"), 
        bsTooltip("pt_traj", 
                  title = "The selected trajectory is shown connecting anchoring clusters. Each data point is a sample. You can brush the points to view their specifics in a table. ", 
                  placement = "top"),
        hr(), 
        h4("Pseudotime trajectory plot brushed points"), 
        DT::dataTableOutput('pt_traj_brushed')
      )
    } else if (input$pt_show_panel == "Accessibility along pseudotime") {
      uiOutput("pt_chracc_ui")
    } else if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
      uiOutput("pt_expr_ui")
    }  
  })
  
  # Render UI for accessibility along pt plots
  output$pt_chracc_ui <- renderUI({
    if (input$pt_chracc_dat_type == "Genomic bin clusters") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Genomic bin clusters accessibility along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_clust_chracc_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_clust_chracc_info", 
                  title = "<h4>Genomic bin clusters chromatin accessibility</h4>", 
                  content = do.call(paste0, popover_contents$gbin_clust_chracc_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          fluidRow(
            column(
              6, 
              sliderInput(
                "pt_n_gbin_clust", 
                label = "Number of genomic bin clusters: ", 
                min = 1, 
                max = min(max_n_gbin, nrow(pred_mat())), 
                value = opt_n_gbin_clust(), 
                step = 1
              ), 
              bsTooltip("pt_n_gbin_clust", 
                        title = "How many clusters do you want to group the top variance bins into? ",
                        placement = "top")
            ), 
            column(
              6, 
              checkboxInput(
                "use_opt_n_gbin_clust", 
                label = "Use optimal number of genomic bin clusters", 
                value = TRUE
              )
            )
          ), 
          htmlOutput('opt_n_gbin_clust_msg'),
          bsTooltip("opt_n_gbin_clust_msg", 
                    title = "The optimal number of genomic bin clusters is determined by elbow method. ",
                    placement = "top"),
          checkboxInput(
            "pt_show_gbin_clust_wss_plot", 
            label = "Show Total Within Cluster Sum of Squares Plot", 
            value = FALSE
          ),
          uiOutput("pt_gbin_clust_wss_plot_ui"),
          checkboxInput(
            "pt_show_gbin_clust_res", 
            label = "Show genomic bin k-means clustering result", 
            value = FALSE
          ), 
          uiOutput("pt_gbin_clust_res_ui")
        ), 
        selectInput(
          'pt_gbin_clust_chracc_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput("pt_gbin_clust_chracc_ui")
      )
    } else if (input$pt_chracc_dat_type == "Individual genomic bin") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Individual genomic bin expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_chracc_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_chracc_info", 
                  title = "<h4>Individual genomic bin chromatin accessibility</h4>", 
                  content = do.call(paste0, popover_contents$gbin_chracc_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        selectInput(
          'pt_gbin_chracc_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gbin_chracc_ui')
      )
    } else if (input$pt_chracc_dat_type == "Gene average") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Gene accessibility along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gene_chracc_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gene_chracc_info", 
                  title = "<h4>Average gene chromatin accessibility</h4>", 
                  content = do.call(paste0, popover_contents$gene_chracc_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          # Select distance limit for mapping bins to nearest genes
          sliderInput("pt_gene_chracc_gene_maxdist", 
                      "Maximum distance limit of bins to nearest gene TSS",
                      min = 0, 
                      max = 1e6, 
                      value = 500, 
                      post = "bp",
                      step = 100), 
          plotlyOutput("pt_gene_chracc_gene_dist_plot")
        ),
        selectInput(
          'pt_gene_chracc_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gene_chracc_ui')
      )
    }
    
  })
  
  # Render UI for expression along pt plots
  output$pt_expr_ui <- renderUI({
    if (input$pt_expr_dat_type == "Genomic bin clusters") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Genomic bin clusters expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_clust_expr_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_clust_expr_info", 
                  title = "<h4>Genomic bin clusters expression</h4>", 
                  content = do.call(paste0, popover_contents$gbin_clust_expr_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          fluidRow(
            column(
              6, 
              sliderInput(
                "pt_n_gbin_clust", 
                label = "Number of genomic bin clusters: ", 
                min = 1, 
                max = min(max_n_gbin, nrow(pred_mat())), 
                value = opt_n_gbin_clust(), 
                step = 1
              ), 
              bsTooltip("pt_n_gbin_clust", 
                        title = "How many clusters do you want to group the top variance bins into? ",
                        placement = "top")
            ), 
            column(
              6, 
              checkboxInput(
                "use_opt_n_gbin_clust", 
                label = "Use optimal number of genomic bin clusters", 
                value = TRUE
              )
            )
          ), 
          htmlOutput('opt_n_gbin_clust_msg'),
          bsTooltip("opt_n_gbin_clust_msg", 
                    title = "The optimal number of genomic bin clusters is determined by elbow method. ",
                    placement = "top"),
          checkboxInput(
            "pt_show_gbin_clust_wss_plot", 
            label = "Show Total Within Cluster Sum of Squares Plot", 
            value = FALSE
          ),
          uiOutput("pt_gbin_clust_wss_plot_ui"),
          checkboxInput(
            "pt_show_gbin_clust_res", 
            label = "Show genomic bin k-means clustering result", 
            value = FALSE
          ), 
          uiOutput("pt_gbin_clust_res_ui")
        ), 
        fluidRow(
          column(
            width = 4, 
            selectInput(
              'pt_gbin_clust_expr_choose_plot', 
              label = "Choose visualization method: ", 
              choices = c("Scatterplot", 
                          "Heatmap")
            )
          ), 
          column(
            width = 4, 
            selectInput(
              "pt_avg_expr_across", 
              "Use average expression across: ",
              c("Bins", "Nearest genes")
            )
          )
        ),
        uiOutput("pt_gbin_clust_expr_ui")
      )
    } else if (input$pt_expr_dat_type == "Individual genomic bin") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Individual genomic bin expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_expr_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_expr_info", 
                  title = "<h4>Individual genomic bin expression</h4>", 
                  content = do.call(paste0, popover_contents$gbin_expr_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        selectInput(
          'pt_gbin_expr_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        wellPanel(
          fluidRow(
            column(
              width = 8,
              sliderInput(
                "pt_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS",
                min = 0, 
                max = 1e6, 
                value = 500, 
                post = "bp",
                step = 100, 
                width = "100%"
              )
            ), 
            column(
              width = 4, 
              checkboxInput(
                "pt_show_gene_dist_plot", 
                "Show distribution of cluster bins distance to genes", 
                value = FALSE
              )
            )
          ),
          uiOutput("pt_gbin_ngene_msg"),
          uiOutput("pt_gbin_expr_gene_dist_plot_ui")
        ),
        uiOutput('pt_gbin_expr_ui')
      )
    } else if (input$pt_expr_dat_type == "Gene average") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Gene expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gene_expr_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gene_expr_info", 
                  title = "<h4>Average gene expression</h4>", 
                  content = do.call(paste0, popover_contents$gene_expr_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          # Select distance limit for mapping bins to nearest genes
          sliderInput("pt_gene_expr_gene_maxdist",
                      "Maximum distance limit of bins to nearest gene TSS",
                      min = 0,
                      max = 1e6,
                      value = 500,
                      post = "bp",
                      step = 100),
          plotlyOutput("pt_gene_expr_gene_dist_plot")
        ),
        selectInput(
          'pt_gene_expr_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gene_expr_ui')
      )
    }
    
  })
  
  # Function adapted from TSCAN for sample clustering based on PCA result
  samples_clust <- reactive({
    set.seed(12345)
    pcareduceres <- pca_res()[, 1:input$pt_n_pc]
    clusternum <- input$pt_range[1]:input$pt_range[2]
    clusternum <- clusternum[clusternum > 1]
    # Find optimal clustering using kmeans and evaluate with total within sum of squares using elbow method
    showModal(modalDialog("Finding sample clusters...", footer = NULL, easyClose = TRUE, size = "s"))
    # Perform kmeans for all cluster numbers
    kmeans_res_list <- lapply(if (nrow(pcareduceres) == max(clusternum)) {clusternum[-c(length(clusternum))]}
                              else {clusternum}, 
                              function(x) {kmeans(pcareduceres, centers = x, nstart=25)})
    if (nrow(pcareduceres) == max(clusternum)) {
      # Each row is its own cluster
      kmeans_res <- list()
      cluster <- 1:nrow(pcareduceres)
      names(cluster) <- row.names(pcareduceres)
      kmeans_res[['cluster']] <- cluster
      centers <- pcareduceres
      row.names(centers) <- as.character(c(1:nrow(pcareduceres)))
      kmeans_res[['centers']] <- centers
      kmeans_res[['tot.withinss']] <- 0
      kmeans_res_list[[length(kmeans_res_list) + 1]] <- kmeans_res
    }
    # Use elbow method to find optimal number of clusters
    wss <- sapply(kmeans_res_list, function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust_i <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    }))
    opt_nclust <- clusternum[opt_nclust_i]
    kmeans_res <- kmeans_res_list[[opt_nclust_i]]
    # Assign id to clusters
    clusterid <- kmeans_res$cluster
    clucenter <- matrix(0, ncol = ncol(pcareduceres), nrow = opt_nclust)
    for (cid in 1:opt_nclust) {
      clucenter[cid, ] <- colMeans(pcareduceres[names(clusterid[clusterid == cid]), , drop = F])
    }
    dp <- as.matrix(dist(clucenter))
    gp <- graph.adjacency(dp, mode = "undirected", weighted = TRUE)
    dp_mst <- minimum.spanning.tree(gp)
    removeModal()
    return(list(pcareduceres = as.matrix(pcareduceres), MSTtree = dp_mst, clusterid = clusterid, clucenter = clucenter))
  })
  
  # Message stating the optimal number of clusters
  output$opt_n_pt_msg <- renderUI({
    HTML(paste("Number of anchoring clusters:", strong(nrow(samples_clust()$clucenter))))
  })
  
  # All possible pseudo-time trajectory starts and ends
  pt_traj_combs <- reactive({
    mclustobj <- samples_clust()
    # Get all combinations of starts and ends of pseudo time paths
    alldeg <- igraph::degree(mclustobj$MSTtree)
    allcomb <- expand.grid(as.numeric(names(alldeg)[alldeg == 1]), as.numeric(names(alldeg)[alldeg == 1]))
    allcomb <- allcomb[allcomb[, 1] != allcomb[, 2], ]
    allcomb
  })
  
  # Optimal pseudo-time trajectory
  main_traj_comb <- reactive({
    mclustobj <- samples_clust()
    clutable <- table(mclustobj$clusterid)
    allcomb <- pt_traj_combs()
    # First column of numres is lengths of paths, 2nd column is total number of cells in clusters covered by paths
    numres <- t(apply(allcomb, 1, function(i) {
      tmp <- as.vector(get.shortest.paths(mclustobj$MSTtree, 
                                          i[1], i[2])$vpath[[1]])
      c(length(tmp), sum(clutable[tmp]))
    }))
    # Get the start and end of optimal path which is longest and covers most cells
    optcomb <- allcomb[order(numres[, 1], numres[, 2], decreasing = T)[1], ]
    optcomb
  })
  
  # Update chosen trajectory on optimal choice check box
  observeEvent(input$use_main_traj, {
    if (input$use_main_traj) {
      updateSelectInput(
        session, 
        "pt_traj_comb", 
        selected = paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to ')
      )
    }
  })
  
  # Update optimal choice check box when user selects a different trajectory
  observeEvent(input$pt_traj_comb, {
    optcombs <- c(paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to '), 
                  paste(main_traj_comb()[, 2], main_traj_comb()[, 1], sep = ' to '))
    if (!(input$pt_traj_comb %in% optcombs)) {
      updateCheckboxInput(
        session, 
        "use_main_traj", 
        value = FALSE
      )
    }
  })
  
  # Message stating the optimal trajectories
  output$main_traj_msg <- renderUI({
    HTML(
      paste("Main trajectories:", 
            strong(paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to ')), 
            "and", 
            strong(paste(main_traj_comb()[, 2], main_traj_comb()[, 1], sep = ' to '))
      )
    )
  })
  
  # Render UI for pseudo-time trajectory selection
  output$pt_sel_traj_ui <- renderUI({
    if (! is.null(samples_clust())) {
      tagList(
        selectInput(
          "pt_traj_comb", 
          label = "Select pseudo-time trajectory: ", 
          choices = paste(pt_traj_combs()[, 1], pt_traj_combs()[, 2], sep = ' to '), 
          selected = paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to ')
        ),
        bsTooltip("pt_traj_comb", 
                  title = "The pseudo-time trajectories are all paths that connect all combinations of leaf pairs in the minimum spanning tree of anchors. ", 
                  placement = "right", 
                  options = list(container = "body")), 
        checkboxInput(
          "use_main_traj", 
          label = "Use main trajectory", 
          value = TRUE
        ),
        htmlOutput('main_traj_msg'),
        bsTooltip("main_traj_msg", 
                  title = "The main trajectories are the ones with longest path length and cover most samples. ", 
                  placement = "right", 
                  options = list(container = "body")), 
      )
    }
  })
  
  # Render anchoring clusters table
  output$pt_traj_clustering_table <- DT::renderDataTable(data.frame(cluster = as.factor(samples_clust()$clusterid), 
                                                                    sample = names(samples_clust()$clusterid)), 
                                                         rownames = FALSE,
                                                         filter = list(position = 'top', clear = FALSE), 
                                                         selection = "none")
  
  # Download clustering table
  output$pt_traj_clustering_table_download <- downloadHandler(
    filename = function() { "Pseudotime_anchoring_clusters_table.txt" },
    content = function(file) {
      write.table(data.frame(cluster = as.factor(samples_clust()$clusterid), 
                             sample = names(samples_clust()$clusterid)),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Render anchoring clusters table UI
  output$pt_traj_clustering_table_ui <- renderUI({
    if (input$pt_traj_show_clustering_table) {
      tagList(
        h4("Anchoring clusters table"),
        downloadButton('pt_traj_clustering_table_download', 'Download clustering table'), 
        DT::dataTableOutput('pt_traj_clustering_table')
      )
    }
  })
  
  # Pseudo time order based on sample clustering result (adapted from TSCANorder)
  pred_order <- reactive({
    mclustobj <- samples_clust()
    set.seed(12345)
    clucenter <- mclustobj$clucenter
    row.names(clucenter) <- paste0("clu", 1:nrow(clucenter))
    clusterid <- mclustobj$clusterid
    pcareduceres <- mclustobj$pcareduceres
    adjmat <- as_adjacency_matrix(mclustobj$MSTtree, sparse = FALSE)
    
    orderinMST <- 1
    clutable <- table(mclustobj$clusterid)
    # Get user selected path
    sel_traj <- as.integer(unlist(strsplit(input$pt_traj_comb, ' to ')))
    MSTorder <- get.shortest.paths(mclustobj$MSTtree, sel_traj[1], sel_traj[2])$vpath[[1]]
    
    TSCAN_order <- NULL
    for (i in 1:(length(MSTorder) - 1)) {
      currentcluid <- MSTorder[i]
      nextcluid <- MSTorder[i + 1]
      currentclucenter <- clucenter[currentcluid, ]
      nextclucenter <- clucenter[nextcluid, ]
      currentreduceres <- pcareduceres[clusterid == currentcluid, ]
      # Avoid vector output
      currentreduceres <- matrix(currentreduceres, nrow = sum(clusterid == currentcluid))
      rownames(currentreduceres) <- rownames(pcareduceres)[clusterid == currentcluid]
      # Get all clusters adjacent to current cluster
      connectcluid <- as.numeric(names(which(adjmat[currentcluid, ] == 1)))
      # Each row is distances from current cluster instance to adjacent cluster centers
      cludist <- sapply(connectcluid, function(x) {
        rowSums(sweep(currentreduceres, 2, clucenter[x, 
        ], "-")^2)
      })
      # Avoid vector output 
      cludist <- matrix(cludist, nrow = nrow(currentreduceres))
      rownames(cludist) <- rownames(currentreduceres)
      # Find closest adjacent cluster for each instance in current cluster
      mindistid <- apply(cludist, 1, which.min)
      # Find current cluster instances closer to next cluster center than to other adjacent clusters (edge cells)
      edgecell <- names(which(mindistid == which(connectcluid == 
                                                   nextcluid)))
      # Sort edge cells by how closely they align with the vector pointing from current cluster to next cluster
      difvec <- nextclucenter - currentclucenter
      tmppos <- pcareduceres[edgecell, ] %*% difvec
      pos <- as.vector(tmppos)
      names(pos) <- edgecell # Changed to get names directly from edgecell instead of tmppos
      # Add sorted edge cells to order
      TSCAN_order <- c(TSCAN_order, names(sort(pos)))
      nextreduceres <- pcareduceres[clusterid == nextcluid, ]
      # Avoid vector output
      nextreduceres <- matrix(nextreduceres, nrow = sum(clusterid == nextcluid))
      rownames(nextreduceres) <- rownames(pcareduceres)[clusterid == nextcluid]
      # Get all clusters adjacent to next cluster
      connectcluid <- as.numeric(names(which(adjmat[nextcluid, ] == 1)))
      # Each row is distances from next cluster instance to adjacent cluster centers
      cludist <- sapply(connectcluid, function(x) {
        rowSums(sweep(nextreduceres, 2, clucenter[x, 
        ], "-")^2)
      })
      # Avoid vector output 
      cludist <- matrix(cludist, nrow = nrow(nextreduceres))
      rownames(cludist) <- rownames(nextreduceres)
      # Find closest adjacent cluster for each instance in next cluster
      mindistid <- apply(cludist, 1, which.min)
      # Find next cluster instances closer to current cluster center than to other adjacent clusters (edge cells)
      edgecell <- names(which(mindistid == which(connectcluid == 
                                                   currentcluid)))
      # Sort edge cells by how closely they align with the vector pointing from current cluster to next cluster
      difvec <- nextclucenter - currentclucenter
      tmppos <- pcareduceres[edgecell, ] %*% difvec
      pos <- as.vector(tmppos)
      names(pos) <- edgecell # Changed to get names directly from edgecell instead of tmppos
      # Add sorted edge cells to order
      TSCAN_order <- c(TSCAN_order, names(sort(pos)))
    }
    data.frame(sample_name = TSCAN_order, State = clusterid[TSCAN_order], 
               Pseudotime = 1:length(TSCAN_order), stringsAsFactors = F)
  })
  
  # Function adapted from TSCAN for plotting pseudo-time trajectory
  plot_traj_clusts <- function (mclustobj, main_traj, show_side_branches = T, show_cell_names = T, cell_name_size = 3) {
    # Create dataframe with each row being a sample containing both PC1 PC2 and cluster
    lib_info_with_pseudo <- data.frame(State = mclustobj$clusterid,
                                       sample_name = names(mclustobj$clusterid))
    lib_info_with_pseudo$State <- factor(lib_info_with_pseudo$State)
    S_matrix <- mclustobj$pcareduceres
    pca_space_df <- data.frame(S_matrix[, 1:2])
    colnames(pca_space_df) <- c("PC1", "PC2")
    pca_space_df$sample_name <- row.names(pca_space_df)
    edge_df <- merge(pca_space_df, lib_info_with_pseudo, by.x = "sample_name",
                     by.y = "sample_name")
    # Plot clusters
    g <- ggplot(data = edge_df, aes(x = PC1, y = PC2))
    g <- g + geom_point(aes(color = State), na.rm = TRUE,
                        size = 5)
    # Plot sample names
    if (show_cell_names) {
      g <- g + geom_text(aes(label = sample_name), size = cell_name_size)
    }
    traj_start <- main_traj[1]
    traj_end <- main_traj[2]
    if (show_side_branches) {
      clucenter <- mclustobj$clucenter[, 1:2]
      mst_lines <- NULL
      mst_edges <- as_edgelist(mclustobj$MSTtree)
      mst_edges <- t(apply(mst_edges, 1, sort))
      for (i in 1:nrow(mst_edges)) {
        mst_lines <- rbind(mst_lines, c(clucenter[as.integer(mst_edges[i, 1]),], clucenter[as.integer(mst_edges[i, 2]), ]))
      }
      mst_lines <- data.frame(x = mst_lines[, 1], xend = mst_lines[, 3], y = mst_lines[, 2], yend = mst_lines[, 4], trajectory = "dashed")
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        edge_line <- sort(c(MSTorder[i], MSTorder[i+1]))
        mst_lines$trajectory[apply(mst_edges, 1, function(x) {all(x == edge_line)})] <- "solid"
      }
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL, linetype = trajectory), 
                            data = mst_lines, size = 1) + scale_linetype_identity()
    } else {
      # Get edges between cluster centers on trajectory
      clucenter <- mclustobj$clucenter[, 1:2]
      clulines <- NULL
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        clulines <- rbind(clulines, c(clucenter[MSTorder[i],], clucenter[MSTorder[i + 1], ]))
      }
      clulines <- data.frame(x = clulines[, 1], xend = clulines[, 3], y = clulines[, 2], yend = clulines[, 4])
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL), data = clulines, size = 1)
    }
    clucenter <- data.frame(x = clucenter[, 1], y = clucenter[,2], id = 1:nrow(clucenter))
    g <- g + geom_text(aes(label = id, x = x, y = y, size = NULL), data = clucenter, size = 10)
    g <- g + guides(colour = guide_legend(override.aes = list(size = 5))) +
      theme(panel.border = element_blank(), axis.line = element_line()) +
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) +
      theme(legend.position = "right", legend.key.size = unit(0.3, "in"), legend.text = element_text(size = 20), legend.title = element_text(size = 20)) +
      theme(legend.key = element_blank()) + theme(panel.background = element_rect(fill = "white")) +
      theme(axis.text.x = element_text(size = 17, color = "darkred"),
            axis.text.y = element_text(size = 17, color = "black"),
            axis.title.x = element_text(size = 20, vjust = -1),
            axis.title.y = element_text(size = 20, vjust = 1),
            plot.margin = unit(c(1, 1, 1, 1), "cm"))
    g
  }
  
  # Function for plotting pseudo-time trajectory colored by pseudo-time
  plot_traj <- function (mclustobj, main_traj, pt, show_side_branches = T, show_cell_names = T, cell_name_size = 3) {
    # Create dataframe with each row being a sample containing both PC1 PC2 and cluster
    lib_info_with_pseudo <- data.frame(State = mclustobj$clusterid, 
                                       sample_name = names(mclustobj$clusterid))
    lib_info_with_pseudo$State <- factor(lib_info_with_pseudo$State)
    pt <- data.frame(pt = 1:length(pt), 
                     sample_name = pt)
    lib_info_with_pseudo <- merge(lib_info_with_pseudo, pt, by="sample_name", all.x=T)
    S_matrix <- mclustobj$pcareduceres
    pca_space_df <- data.frame(S_matrix[, 1:2])
    colnames(pca_space_df) <- c("PC1", "PC2")
    pca_space_df$sample_name <- row.names(pca_space_df)
    edge_df <- merge(pca_space_df, lib_info_with_pseudo, by.x = "sample_name", 
                     by.y = "sample_name")
    # Plot sample points
    g <- ggplot(data = edge_df, aes(x = PC1, y = PC2))
    g <- g + geom_point(aes(color = pt), na.rm = TRUE, size = 5) + 
      scale_colour_gradientn(colours=rainbow(2)) + labs(color = "Pseudotime")
    # Plot sample names
    if (show_cell_names) {
      g <- g + geom_text(aes(label = sample_name), size = cell_name_size)
    }
    traj_start <- main_traj[1]
    traj_end <- main_traj[2]
    if (show_side_branches) {
      clucenter <- mclustobj$clucenter[, 1:2]
      mst_lines <- NULL
      mst_edges <- as_edgelist(mclustobj$MSTtree)
      mst_edges <- t(apply(mst_edges, 1, sort))
      for (i in 1:nrow(mst_edges)) {
        mst_lines <- rbind(mst_lines, c(clucenter[as.integer(mst_edges[i, 1]),], clucenter[as.integer(mst_edges[i, 2]), ]))
      }
      mst_lines <- data.frame(x = mst_lines[, 1], xend = mst_lines[, 3], y = mst_lines[, 2], yend = mst_lines[, 4], trajectory = "dashed")
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        edge_line <- sort(c(MSTorder[i], MSTorder[i+1]))
        mst_lines$trajectory[apply(mst_edges, 1, function(x) {all(x == edge_line)})] <- "solid"
      }
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL, linetype = trajectory), 
                            data = mst_lines, size = 1) + scale_linetype_identity()
    } else {
      # Get edges between cluster centers on trajectory
      clucenter <- mclustobj$clucenter[, 1:2]
      clulines <- NULL
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        clulines <- rbind(clulines, c(clucenter[MSTorder[i],], clucenter[MSTorder[i + 1], ]))
      }
      clulines <- data.frame(x = clulines[, 1], xend = clulines[, 3], y = clulines[, 2], yend = clulines[, 4])
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL), data = clulines, size = 1)
    }
    g <- g + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(legend.position = "right", legend.key.size = unit(0.3, "in"), legend.text = element_text(size = 20), legend.title = element_text(size = 20)) + 
      theme(legend.key = element_blank()) + theme(panel.background = element_rect(fill = "white")) + 
      theme(axis.text.x = element_text(size = 17, color = "darkred"), 
            axis.text.y = element_text(size = 17, color = "black"), 
            axis.title.x = element_text(size = 20, vjust = -1), 
            axis.title.y = element_text(size = 20, vjust = 1), 
            plot.margin = unit(c(1, 1, 1, 1), "cm"))
    g
  }
  
  pt_traj_plot <- reactive({
    sel_traj <- as.integer(unlist(strsplit(input$pt_traj_comb, ' to ')))
    if (input$pt_traj_color == "Anchoring clusters") {
      plot_traj_clusts(samples_clust(), 
                       main_traj = sel_traj, 
                       show_side_branches = (! is.null(input$pt_traj_show_side_branch)) && (input$pt_traj_show_side_branch),
                       show_cell_names = input$pt_traj_show_sample_names, 
                       cell_name_size = input$pt_traj_sample_name_size)
    } else if (input$pt_traj_color == "Pseudotime") {
      plot_traj(samples_clust(), 
                main_traj = sel_traj, 
                pt = pred_order()$sample_name,
                show_side_branches = (! is.null(input$pt_traj_show_side_branch)) && (input$pt_traj_show_side_branch),
                show_cell_names = input$pt_traj_show_sample_names, 
                cell_name_size = input$pt_traj_sample_name_size)
    }
  })
  
  # Render plot for pseudo-time trajectory over sample clusters
  output$pt_traj <- renderPlot({
    pt_traj_plot()
  })
  
  observeEvent(input$plot_traj_plot_download, {
    download_plot(pt_traj_plot())
  })
  
  # Render pseudo-time trajectory brushed points table
  observeEvent(input$pt_traj_brush, {
    top_pcs <- pca_res()[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$pt_traj_brush, xvar = "PC1", yvar = "PC2"))
    output$pt_traj_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                                  rownames = FALSE,
                                                  filter = list(position = 'top', clear = FALSE), 
                                                  selection = "none")
  })
  
  # Render UI for pseudo time trajectory plot sample name size selection
  output$pt_traj_sample_name_size_ui <- renderUI({
    if (input$pt_traj_show_sample_names) {
      sliderInput(
        "pt_traj_sample_name_size", 
        label = "Adjust sample name sizes: ",
        min = 1, 
        max = 10,
        value = 3
      )
    }
  })
  
  # Render UI for pseudo time trajectory plot show side branches option
  output$pt_traj_show_side_branch_ui <- renderUI({
    if (nrow(pt_traj_combs()) > 2) {
      checkboxInput("pt_traj_show_side_branch", "Show side branches")
    }
  })
  
  # Download pseudo time ordered sample ids
  output$pt_traj_samples_order_download <- downloadHandler(
    filename = function() { "Pseudotime_samples.txt" },
    content = function(filename) {
      file.create(filename)
      f <- file(filename)
      writeLines(pred_order()$sample_name, f)
      close(f)
    }
  )
  
  # Scaled top variance bins matrix for samples in selected trajectory
  scaled_pt_mat <- reactive({
    scaled_mat <- t(scale(t(pca_top_var_pred_mat()[, pred_order()$sample_name])))
    scaled_mat[is.na(scaled_mat)] <- 0
    scaled_mat
  })
  
  # All genomic bin clustering results
  all_gbin_clust_res <- reactive({
    showModal(modalDialog("Clustering genomic bins...", footer = NULL, easyClose = TRUE, size = "s"))
    set.seed(12345)
    # Do k-means clustering with all possible number of clusters
    all_res <- list()
    for (i in 1:min(max_n_gbin, nrow(pca_top_var_pred_mat()) - 1)) {
      suppressWarnings(kmeans_res <- kmeans(scaled_pt_mat(), centers = i, nstart = 25, iter.max = 100))
      all_res[[as.character(i)]] <- kmeans_res
    }
    if (min(max_n_gbin, nrow(pca_top_var_pred_mat())) == nrow(pca_top_var_pred_mat())) {
      # Each row is its own cluster
      kmeans_res <- list()
      cluster <- 1:nrow(pca_top_var_pred_mat())
      names(cluster) <- row.names(pca_top_var_pred_mat())
      kmeans_res[['cluster']] <- cluster
      centers <- pca_top_var_pred_mat()
      row.names(centers) <- as.character(c(1:nrow(pca_top_var_pred_mat())))
      kmeans_res[['centers']] <- centers
      kmeans_res[['tot.withinss']] <- 0
      all_res[[as.character(nrow(pca_top_var_pred_mat()))]] <- kmeans_res
    }
    removeModal()
    return(all_res)
  })
  
  # Optimal number of genomic bin clusters
  opt_n_gbin_clust <- reactive({
    # Use elbow method to find optimal number of clusters
    wss <- sapply(all_gbin_clust_res(), function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    }))
    return(opt_nclust)
  })
  
  # Selected genomic bin clustering results
  gbin_clust_res <- reactive({
    kmeans_res <- all_gbin_clust_res()[[as.character(input$pt_n_gbin_clust)]]
    return(kmeans_res)
  })
  
  # Message stating the optimal number of clusters
  output$opt_n_gbin_clust_msg <- renderUI({
    HTML(paste("Optimal number of clusters:", strong(opt_n_gbin_clust())))
  })
  
  pt_gbin_clust_wss_plot <- reactive({
    tot_wss <- unlist(lapply(all_gbin_clust_res(), function(x) {x$tot.withinss}))
    wss_df <- data.frame(n_clust = c(1:min(max_n_gbin, nrow(pca_top_var_pred_mat()))), 
                         wss = tot_wss)
    wcss_plot <- ggplot(data = wss_df, 
                        mapping = aes(n_clust, wss))
    wcss_plot <- wcss_plot + geom_line() + geom_point()
    wcss_plot <- wcss_plot + xlab("Number of Clusters") + ylab("Total Within Cluster Sum of Squares")
    wcss_plot <- wcss_plot + geom_vline(xintercept = opt_n_gbin_clust(), linetype="dashed", color = "blue")
    wcss_plot
  })
  
  # Genomic bin clusters WSS plot
  output$pt_gbin_clust_wss_plot <- renderPlot({
    pt_gbin_clust_wss_plot()
  })
  
  observeEvent(input$pt_gbin_clust_wss_plot_download, {
    download_plot(pt_gbin_clust_wss_plot())
  })
  
  # UI for genomic bin clusters WSS plot
  output$pt_gbin_clust_wss_plot_ui <- renderUI({
    if (input$pt_show_gbin_clust_wss_plot) {
      tagList(
        h4("Genomic bin clusters WSS plot"), 
        plotOutput('pt_gbin_clust_wss_plot'), 
        bsTooltip("pt_gbin_clust_wss_plot", 
                  title = "The dashed line indicates the optimal number of clusters determined by elbow method. ", 
                  placement = "top"), 
        actionButton("pt_gbin_clust_wss_plot_download", "Download plot")
      )
    }
  })
  
  # Genomic bin PCA results
  gbin_pca_res <- reactive({
    prcomp(scaled_pt_mat(), scale = FALSE, center = TRUE)
  })
  
  pt_gbin_clust_plot_pca <- reactive({
    showModal(modalDialog("Making cluster plot...", footer = NULL, easyClose = TRUE, size = "s"))
    # Plot the top 2 PCs
    clust_plot <- ggplot(data = data.frame(gbin_pca_res()$x)[, 1:2], 
                         mapping = aes(PC1, PC2, colour = factor(gbin_clust_res()$cluster)))
    clust_plot <- clust_plot + geom_point()
    clust_plot$labels$colour <- "Cluster"
    explained_var <- summary(gbin_pca_res())$importance[2, 1:2]
    clust_plot <- clust_plot + xlab(paste0("PC1 (", explained_var[1] * 100, "% variance)"))
    clust_plot <- clust_plot + ylab(paste0("PC2 (", explained_var[2] * 100, "% variance)"))
    removeModal()
    clust_plot
  })
  
  # Render genomic bins clusters PCA plot
  output$pt_gbin_clust_plot_pca <- renderPlot({
    pt_gbin_clust_plot_pca()
  })
  
  observeEvent(input$pt_gbin_clust_plot_pca_download, {
    download_plot(pt_gbin_clust_plot_pca())
  })
  
  pt_gbin_clust_plot_umap <- reactive({
    # Run UMAP
    showModal(modalDialog("Running UMAP...", footer = NULL, easyClose = TRUE, size = "s"))
    set.seed(12345)
    pred_umap <- umap(scaled_pt_mat(), 
                      random_state = 1, 
                      n_neighbors = min(15, nrow(scaled_pt_mat()) - 1))
    layout_df <- data.frame(UMAP_1 = pred_umap$layout[, 1], 
                            UMAP_2 = pred_umap$layout[, 2])
    removeModal()
    # Plot UMAP layout
    showModal(modalDialog("Making cluster plot...", footer = NULL, easyClose = TRUE, size = "s"))
    clust_plot <- ggplot(data = layout_df, 
                         mapping = aes(UMAP_1, UMAP_2, colour = factor(gbin_clust_res()$cluster)))
    clust_plot <- clust_plot + geom_point()
    clust_plot$labels$colour <- "Cluster"
    removeModal()
    clust_plot
  })
  
  # Render genomic bins clusters UMAP plot
  output$pt_gbin_clust_plot_umap <- renderPlot({
    pt_gbin_clust_plot_umap()
  })
  
  observeEvent(input$pt_gbin_clust_plot_umap_download, {
    download_plot(pt_gbin_clust_plot_umap())
  })
  
  # Render table for genomic bin clusters means
  output$gbin_clust_means_table <- DT::renderDataTable(aggregate(pca_top_var_pred_mat(), 
                                                                 by=list(cluster=gbin_clust_res()$cluster), 
                                                                 mean), 
                                                       rownames = FALSE,
                                                       filter = list(position = 'top', clear = FALSE), 
                                                       selection = "none",
                                                       options = list(scrollX = TRUE))
  
  # Render table for genomic bin cluster assignment
  output$gbin_clust_table <- DT::renderDataTable(data.frame(cluster = as.factor(gbin_clust_res()$cluster), 
                                                            genomic_bin = names(gbin_clust_res()$cluster)), 
                                                 rownames = FALSE,
                                                 filter = list(position = 'top', clear = FALSE), 
                                                 selection = "none")
  
  # Differential analysis samples kmeans cluster result download
  output$gbin_clust_table_download <- downloadHandler(
    filename = function() { "Genomic_bin_clusters.txt" },
    content = function(file) {
      write.table(data.frame(cluster = as.factor(gbin_clust_res()$cluster), 
                             genomic_bin = names(gbin_clust_res()$cluster)),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Render PCA brushed points table
  observeEvent(input$pt_gbin_clust_plot_pca_brush, {
    top_pcs <- data.frame(gbin_pca_res()$x)[, 1:2]
    brushed_gbins <- rownames(brushedPoints(top_pcs, input$pt_gbin_clust_plot_pca_brush, xvar = "PC1", yvar = "PC2"))
    output$pt_gbin_clust_plot_pca_brushed <- DT::renderDataTable(parse_gbin(brushed_gbins),
                                                                 rownames = FALSE,
                                                                 filter = list(position = 'top', clear = FALSE), 
                                                                 selection = "none")
  })
  
  # Render UI for pseudo time genomic bin clustering results panels
  output$pt_gbin_clust_res_panel <- renderUI({
    if (input$pt_gbin_clust_res_show_panel == "Cluster Plot (PCA)") {
      tagList(
        h4("PCA plot of genomic bin clusters"), 
        plotOutput('pt_gbin_clust_plot_pca', brush = 'pt_gbin_clust_plot_pca_brush'), 
        bsTooltip("pt_gbin_clust_plot_pca", 
                  title = "Each data point represents a genomic bin. Brush on points to see details in table. ", 
                  placement = "top"),
        actionButton("pt_gbin_clust_plot_pca_download", "Download plot"), 
        hr(),
        h4("PCA plot brushed points table"),
        DT::dataTableOutput('pt_gbin_clust_plot_pca_brushed')
      )
    } else if (input$pt_gbin_clust_res_show_panel == "Cluster Means") {
      tagList(
        h4("Genomic bins cluster means table"),
        DT::dataTableOutput('gbin_clust_means_table')
      )
    } else if (input$pt_gbin_clust_res_show_panel == "Clustering") {
      tagList(
        h4("Genomic bins clustering table"),
        downloadButton('gbin_clust_table_download', 'Download clustering table'), 
        DT::dataTableOutput('gbin_clust_table')
      )
    } else if (input$pt_gbin_clust_res_show_panel == "Cluster Plot (UMAP)") {
      tagList(
        h4("UMAP plot of genomic bin clusters"), 
        plotOutput('pt_gbin_clust_plot_umap'), 
        actionButton("pt_gbin_clust_plot_umap_download", "Download plot")
      )
    }
  })
  
  # Render UI for selecting pseudo time genomic bin clustering results panels
  output$pt_gbin_clust_res_ui <- renderUI({
    if (input$pt_show_gbin_clust_res) {
      tagList(
        selectInput(
          "pt_gbin_clust_res_show_panel", 
          label = "Choose genomic bin clustering result panel to display: ", 
          choices = c("Cluster Plot (PCA)", 
                      "Cluster Plot (UMAP)", 
                      "Cluster Means", 
                      "Clustering")
        ), 
        uiOutput('pt_gbin_clust_res_panel')
      )
    }
  })
  
  # Function adapted from TSCAN singlegeneplot
  chracc_along_pt_plot <- function(geneexpr, TSCANorder) {
    Pseudotime <- NULL
    geneexpr <- geneexpr[TSCANorder[, 1]]
    exprdata <- cbind(TSCANorder, geneexpr)
    exprdata$State <- factor(exprdata$State)
    exprdata$predict <- fitted.values(mgcv::gam(geneexpr ~ s(Pseudotime, 
                                                             k = 3), data = exprdata))
    q <- ggplot(aes(Pseudotime, geneexpr), data = exprdata)
    q <- q + geom_point(aes_string(color = "State"))
    q <- q + geom_line(aes(Pseudotime, predict), data = exprdata)
    q <- q + ylab("Predicted log2 chromatin accessibility") + xlab("Pseudotime")
    q <- q + theme(strip.background = element_rect(colour = "white", 
                                                   fill = "white")) + theme(panel.border = element_blank(), 
                                                                            axis.line = element_line()) + theme(panel.grid.minor.x = element_blank(), 
                                                                                                                panel.grid.minor.y = element_blank()) + theme(panel.grid.major.x = element_blank(), 
                                                                                                                                                              panel.grid.major.y = element_blank()) + theme(panel.background = element_rect(fill = "white"))
    q
  }
  
  # Function adapted from TSCAN singlegeneplot
  expr_along_pt_plot <- function(geneexpr, TSCANorder) {
    Pseudotime <- NULL
    geneexpr <- geneexpr[TSCANorder[, 1]]
    exprdata <- cbind(TSCANorder, geneexpr)
    exprdata$State <- factor(exprdata$State)
    exprdata$predict <- fitted.values(mgcv::gam(geneexpr ~ s(Pseudotime, 
                                                             k = 3), data = exprdata))
    q <- ggplot(aes(Pseudotime, geneexpr), data = exprdata)
    q <- q + geom_point(aes_string(color = "State"))
    q <- q + geom_line(aes(Pseudotime, predict), data = exprdata)
    q <- q + ylab("Scaled log2 expression") + xlab("Pseudotime")
    q <- q + theme(strip.background = element_rect(colour = "white", 
                                                   fill = "white")) + theme(panel.border = element_blank(), 
                                                                            axis.line = element_line()) + theme(panel.grid.minor.x = element_blank(), 
                                                                                                                panel.grid.minor.y = element_blank()) + theme(panel.grid.major.x = element_blank(), 
                                                                                                                                                              panel.grid.major.y = element_blank()) + theme(panel.background = element_rect(fill = "white"))
    q
  }
  
  # Function modified from countToFPKM::fpkm
  # Solved problem of dealing with single column counts matrix
  count_to_fpkm <- function (counts, featureLength, meanFragmentLength) {
    stopifnot(length(featureLength) == nrow(counts))
    stopifnot(length(meanFragmentLength) == ncol(counts))
    effLen <- do.call(cbind, lapply(1:ncol(counts), function(i) {
      featureLength - meanFragmentLength[i] + 1
    }))
    idx <- apply(effLen, 1, function(x) min(x) > 1)
    counts <- counts[idx, , drop=FALSE]
    effLen <- effLen[idx, , drop=FALSE]
    featureLength <- featureLength[idx]
    fpkm <- do.call(cbind, lapply(1:ncol(counts), function(i) {
      N <- sum(counts[, i])
      exp(log(counts[, i]) + log(1e+09) - log(effLen[, i]) -
            log(N))
    }))
    colnames(fpkm) <- colnames(counts)
    rownames(fpkm) <- rownames(counts)
    return(fpkm)
  }
  
  # Reactive that stores selected samples expression
  expr_mat <- reactive({
    showModal(modalDialog("Retrieving expression data...", footer = NULL, easyClose = TRUE, size = "s"))
    proj <- as.character(unique(selected_samples()$project))
    sel_proj <- data.frame(project=proj, 
                           project_home=paste0("data_sources/", selected_samples()$file_source[match(proj, selected_samples()$project)]),
                           organism="human")
    mat_li <- lapply(1:nrow(sel_proj), function(i) {
      rse <- create_rse(sel_proj[i, ], recount3_url = recount3_url)
      if ((max(assay(rse)) > .Machine$integer.max) | (all(rowMins(assay(rse)) == 0))) {
        # Use a different method to get fpkm if DESeq cannot be used
        fpkm_matrix <- count_to_fpkm(assay(rse),
                                     featureLength = rse@rowRanges@elementMetadata@listData[['bp_length']],
                                     meanFragmentLength = rse$recount_seq_qc.avg_len)
      } else {
        # Get FPKM from raw counts
        deseq_obj <- DESeqDataSet(rse, design = ~ as.factor(c("study", "external_id")))
        fpkm_matrix <- DESeq2::fpkm(deseq_obj)
      }
      fpkm_matrix
    })
    fpkm_matrix <- do.call(cbind, mat_li)
    # QN
    fpkm_names <- dimnames(fpkm_matrix)
    fpkm_matrix <- normalize.quantiles(fpkm_matrix)
    dimnames(fpkm_matrix) <- fpkm_names
    # Log
    fpkm_matrix <- fpkm_matrix
    log_fpkm <- log2(fpkm_matrix + 1)
    # Remove version numbers from ENSEMBL ids
    rownames(fpkm_matrix) <- gsub("\\.\\d+$", "", rownames(fpkm_matrix))
    removeModal()
    fpkm_matrix
  })
  
  # Scaled expression matrix along pt
  scaled_expr_pt_mat <- reactive({
    scaled_mat <- t(scale(t(expr_mat()[, pred_order()$sample_name])))
    na.omit(scaled_mat)
  })
  
  pt_gbin_clust_chracc_plot <- reactive({
    mean_pt_df <- aggregate(scaled_pt_mat(), 
                            by=list(cluster=gbin_clust_res()$cluster), 
                            mean)
    chosen_clust_scaled <- as.numeric(mean_pt_df[mean_pt_df$cluster == input$pt_choose_gbin_clust, 2:ncol(mean_pt_df)])
    names(chosen_clust_scaled) <- pred_order()$sample_name
    chracc_along_pt_plot(chosen_clust_scaled, pred_order())
  })
  
  # Render chromatin accessibility along pseudo time plot for chosen genomic bin cluster
  output$pt_gbin_clust_chracc_plot <- renderPlot({
    pt_gbin_clust_chracc_plot()
  })
  
  observeEvent(input$pt_gbin_clust_chracc_plot_download, {
    download_plot(pt_gbin_clust_chracc_plot())
  })
  
  # Reactive value indicating whether chosen cluster bins map to at least 1 ensembl gene
  pt_gbin_clust_exist_ensembl <- reactiveVal(TRUE)
  
  # Message that indicates no expression values are associated with selected cluster
  output$pt_gbin_clust_no_ensembl_msg <- renderUI({
    if (! pt_gbin_clust_exist_ensembl()) {
      p("The selected genomic bin cluster's nearest genes do not map to any ENSEMBL genes in expression matrix. Please select a different cluster. ")
    }
  })
  
  # Scaled average expression for all clusters
  pt_all_clust_expr <- reactive({
    clu_avg_expr <- t(sapply(unique(gbin_clust_res()$cluster), function(clu) {
      pt_gbin_clust_exist_ensembl(TRUE)
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust_res()$cluster == clu]
      # Find nearest genes
      clu_gbin_tss <- gbin_tss[gbin_names, ]
      clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
      clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
      clu_annots <- annots[annots$SYMBOL %in% clu_gbin_tss$gene, ]
      # Remove 0-var genes
      clu_annots <- clu_annots[clu_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
      clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$gene %in% clu_annots$SYMBOL, ]
      if (nrow(clu_annots) == 0) {
        # No ensembl genes match gene symbol
        pt_gbin_clust_exist_ensembl(FALSE)
        return(rep(NA, ncol(scaled_expr_pt_mat())))
      }
      # Find the expr vector for each gene symbol
      gene_expr <- aggregate(scaled_expr_pt_mat()[clu_annots$ENSEMBL, , drop=F], 
                             list(gene=clu_annots$SYMBOL), mean)
      gene_expr_mat <- as.matrix.data.frame(gene_expr[, -1])
      rownames(gene_expr_mat) <- gene_expr$gene
      if (input$pt_avg_expr_across == "Bins") {
        chosen_clust_scaled <- colMeans(gene_expr_mat[clu_gbin_tss$gene, , drop=F])
        return(chosen_clust_scaled)
      } else if (input$pt_avg_expr_across == "Nearest genes") {
        chosen_clust_scaled <- colMeans(gene_expr_mat)
        return(chosen_clust_scaled)
      }
    }))
    colnames(clu_avg_expr) <- pred_order()$sample_name
    rownames(clu_avg_expr) <- unique(gbin_clust_res()$cluster)
    clu_avg_expr
  })
  
  # Scaled average expression for chosen cluster
  pt_chosen_clust_expr <- reactive({
    pt_gbin_clust_exist_ensembl(TRUE)
    chosen_clust_scaled <- pt_all_clust_expr()[as.character(input$pt_choose_gbin_clust), ]
    if (anyNA(chosen_clust_scaled)) {
      pt_gbin_clust_exist_ensembl(FALSE)
      return(NULL)
    }
    names(chosen_clust_scaled) <- pred_order()$sample_name
    chosen_clust_scaled
  })
  
  pt_gbin_clust_expr_plot <- reactive({
    if (! is.null(pt_chosen_clust_expr())) {
      expr_along_pt_plot(pt_chosen_clust_expr(), pred_order())
    }
  })
  
  # Render expression along pseudo time plot for chosen genomic bin cluster
  output$pt_gbin_clust_expr_plot <- renderPlot({
    pt_gbin_clust_expr_plot()
  })
  
  observeEvent(input$pt_gbin_clust_expr_plot_download, {
    download_plot(pt_gbin_clust_expr_plot())
  })
  
  # Make genomic bin clusters chromatin accessibility along pseudo time heat map
  pt_gbin_clust_chracc_heatmap <- reactive({
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    mean_pt_df <- aggregate(scaled_pt_mat(), 
                            by=list(cluster=gbin_clust_res()$cluster), 
                            mean)
    chosen_clust_scaled <- as.matrix.data.frame(mean_pt_df[, -1])
    rownames(chosen_clust_scaled) <- mean_pt_df$cluster
    ht <- Heatmap(chosen_clust_scaled, 
                  heatmap_legend_param = list(title = "average predicted \nlog2 chromatin \naccessibility"), 
                  cluster_columns = FALSE)
    removeModal()
    return(draw(ht))
  })
  
  # Make genomic bin clusters expression along pseudo time heat map
  pt_gbin_clust_expr_heatmap <- reactive({
    if (! all(is.na(pt_all_clust_expr()))) {
      showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
      ht <- Heatmap(pt_all_clust_expr()[apply(pt_all_clust_expr(), 1, function(x){if (all(is.na(x))) {FALSE} else {TRUE}}), , drop=F], 
                    heatmap_legend_param = list(title = "average scaled log \nexpression"), 
                    cluster_columns = FALSE)
      removeModal()
      return(draw(ht))
    }
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_clust_chracc_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_clust_chracc_heatmap())
  })
  
  # Render chromatin accessibility along pseudo time heat map for chosen genomic bin cluster
  output$pt_gbin_clust_chracc_heatmap <- renderPlot({
    pt_gbin_clust_chracc_heatmap()
  })
  
  observeEvent(input$pt_gbin_clust_chracc_heatmap_download, {
    download_plot(pt_gbin_clust_chracc_heatmap())
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_clust_expr_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_clust_expr_heatmap())
  })
  
  # Render expression along pseudo time heat map for chosen genomic bin cluster
  output$pt_gbin_clust_expr_heatmap <- renderPlot({
    pt_gbin_clust_expr_heatmap()
  })
  
  observeEvent(input$pt_gbin_clust_expr_heatmap_download, {
    download_plot(pt_gbin_clust_expr_heatmap())
  })
  
  # Render genomic bin cluster chromatin accessibility visualization UI
  output$pt_gbin_clust_chracc_ui <- renderUI({
    if (input$pt_gbin_clust_chracc_choose_plot == "Scatterplot") {
      tagList(
        selectInput(
          'pt_choose_gbin_clust', 
          label = "Show chromatin accessibility along pseudotime for cluster: ", 
          choices = as.character(1:input$pt_n_gbin_clust)
        ), 
        h4("Genomic bin clusters average accessibility plot"),
        plotOutput('pt_gbin_clust_chracc_plot'), 
        bsTooltip("pt_gbin_clust_chracc_plot", 
                  title = "Data points are arranged in order of pseudo time along the x-axis. Each data point represents the average predicted log accessibility of the selected genomic bin cluster. ", 
                  placement = "top"), 
        actionButton("pt_gbin_clust_chracc_plot_download", "Download plot")
      )
    } else if (input$pt_gbin_clust_chracc_choose_plot == "Heatmap") {
      if (input$pt_n_gbin_clust > 1) {
        tagList(
          h4("Genomic bin clusters average accessibility heat map"),
          actionButton('show_interactive_pt_gbin_clust_chracc_heatmap', 
                       "Show interactive heatmap"), 
          plotOutput('pt_gbin_clust_chracc_heatmap'), 
          bsTooltip("pt_gbin_clust_chracc_heatmap", 
                    title = "Heat map columns are arranged in order of pseudo time. Each heat map cell represents the average predicted log accessibility of the selected genomic bin cluster. ", 
                    placement = "top"), 
          actionButton("pt_gbin_clust_chracc_heatmap_download", "Download plot")
        )
      } else {
        # No need to use heat map visualization
        p("Heat map cannot be generated for single row input. Please use a larger number of genomic bin clusters for heat map visualization. ")
      }
    }
  })
  
  # Render genomic bin cluster expression visualization UI
  output$pt_gbin_clust_expr_ui <- renderUI({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      tagList(
        selectInput(
          'pt_choose_gbin_clust', 
          label = "Show expression along pseudotime for cluster: ", 
          choices = as.character(1:input$pt_n_gbin_clust)
        ), 
        wellPanel(
          fluidRow(
            column(
              width = 8,
              sliderInput(
                "pt_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS",
                min = 0, 
                max = 1e6, 
                value = 500, 
                post = "bp",
                step = 100, 
                width = "100%"
              )
            ), 
            column(
              width = 4, 
              checkboxInput(
                "pt_show_gene_dist_plot", 
                "Show distribution of cluster bins distance to genes", 
                value = FALSE
              )
            )
          ),
          uiOutput("pt_gbin_clu_ngene_msg"),
          uiOutput("pt_gbin_clust_expr_gene_dist_plot_ui")
        ),
        h4("Genomic bin clusters expression plot"),
        uiOutput("pt_gbin_clust_no_ensembl_msg"), 
        plotOutput('pt_gbin_clust_expr_plot'), 
        bsTooltip("pt_gbin_clust_expr_plot", 
                  title = "Data points are arranged in order of pseudo time along the x-axis. Each data point represents the scaled average log expression of the selected genomic bin cluster. ", 
                  placement = "top"), 
        actionButton("pt_gbin_clust_expr_plot_download", "Download plot")
      )
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      if (input$pt_n_gbin_clust > 1) {
        tagList(
          wellPanel(
            fluidRow(
              column(
                width = 8,
                sliderInput(
                  "pt_gene_maxdist", 
                  "Maximum distance limit of bins to nearest gene TSS",
                  min = 0, 
                  max = 1e6, 
                  value = 500, 
                  post = "bp",
                  step = 100, 
                  width = "100%"
                )
              ), 
              column(
                width = 4, 
                checkboxInput(
                  "pt_show_gene_dist_plot", 
                  "Show distribution of cluster bins distance to genes", 
                  value = FALSE
                )
              )
            ),
            uiOutput("pt_gbin_clu_ngene_msg"),
            uiOutput("pt_gbin_clust_expr_gene_dist_plot_ui")
          ),
          h4("Genomic bin clusters average expression heat map"),
          actionButton('show_interactive_pt_gbin_clust_expr_heatmap', 
                       "Show interactive heatmap"), 
          plotOutput('pt_gbin_clust_expr_heatmap'), 
          bsTooltip("pt_gbin_clust_expr_heatmap", 
                    title = "Heat map columns are arranged in order of pseudo time. Each heat map cell represents the average expression of the selected genomic bin cluster scaled across samples. ", 
                    placement = "top"), 
          actionButton("pt_gbin_clust_expr_heatmap_download", "Download plot")
        )
      } else {
        # No need to use heat map visualization
        p("Heat map cannot be generated for single row input. Please use a larger number of genomic bin clusters for heat map visualization. ")
      }
    }
  })
  
  output$pt_gbin_clust_expr_gene_dist_plot_ui <- renderUI({
    if (input$pt_show_gene_dist_plot) {
      plotlyOutput("pt_gbin_clust_expr_gene_dist_plot")
    }
  })
  
  output$pt_gbin_clust_expr_gene_dist_plot <- renderPlotly({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust_res()$cluster == input$pt_choose_gbin_clust]
    } else {
      gbin_names <- rownames(pca_top_var_pred_mat())
    }
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  output$pt_gbin_expr_gene_dist_plot_ui <- renderUI({
    if (input$pt_show_gene_dist_plot) {
      plotlyOutput("pt_gbin_expr_gene_dist_plot")
    }
  })
  
  output$pt_gbin_expr_gene_dist_plot <- renderPlotly({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  pt_gbin_clu_nearest_genes <- reactive({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust_res()$cluster == input$pt_choose_gbin_clust]
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      gbin_names <- rownames(pca_top_var_pred_mat())
    }
    # Find nearest genes
    clu_gbin_tss <- gbin_tss[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    clu_annots <- annots[annots$SYMBOL %in% clu_gbin_tss$gene, ]
    # Remove 0-var genes
    clu_annots <- clu_annots[clu_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
    unique(clu_annots$SYMBOL)
  })
  
  output$pt_gbin_clu_ngene_msg <- renderUI({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust_res()$cluster == input$pt_choose_gbin_clust]
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      gbin_names <- rownames(pca_top_var_pred_mat())
    }
    # Find nearest genes
    clu_gbin_tss <- gbin_tss[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      HTML(paste("<p>There are", strong(sum(gbin_clust_res()$cluster == input$pt_choose_gbin_clust)), 
                 "bins in this cluster, mapping to", strong(length(unique(clu_gbin_tss$gene))), 
                 "genes inside the selected maximum mapping distance of selected bins. Of these genes,", 
                 strong(length(pt_gbin_clu_nearest_genes())), "have non-zero-variance expression values</p>"))
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      HTML(paste("<p>There are", strong(length(unique(clu_gbin_tss$gene))), 
                 "genes inside the selected maximum mapping distance of selected bins. Of these genes,", 
                 strong(length(pt_gbin_clu_nearest_genes())), "have non-zero-variance expression values</p>"))
    }
  })
  
  output$pt_gbin_ngene_msg <- renderUI({
    gbin_names <- rownames(pca_top_var_pred_mat())
    # Find nearest genes
    clu_gbin_tss <- gbin_tss[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    gbin_annots <- annots[annots$SYMBOL %in% clu_gbin_tss$gene, ]
    gbin_annots <- gbin_annots[gbin_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
    HTML(paste("<p>There are", strong(length(unique(clu_gbin_tss$gene))), 
               "genes inside the selected maximum mapping distance. Of these genes,", 
               strong(length(unique(gbin_annots$SYMBOL))), "have non-zero-variance expression values</p>"))
  })
  
  # Update chosen number of genomic bin clusters on optimal choice check box
  observeEvent(input$use_opt_n_gbin_clust, {
    if (input$use_opt_n_gbin_clust) {
      updateSliderInput(
        session, 
        "pt_n_gbin_clust", 
        value = opt_n_gbin_clust()
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of genomic clusters
  observeEvent(input$pt_n_gbin_clust, {
    if (input$pt_n_gbin_clust != opt_n_gbin_clust()) {
      updateCheckboxInput(
        session, 
        "use_opt_n_gbin_clust", 
        value = FALSE
      )
    }
  })
  
  pt_gbin_chracc_plot <- reactive({
    if (length(input$top_var_gbin_table_rows_selected == 1)) {
      chracc_along_pt_plot(pca_top_var_pred_mat()[input$top_var_gbin_table_rows_selected, ], pred_order())
    }
  })
  
  # Render chromatin accessibility along pseudo time plot for chosen genomic bin
  output$pt_gbin_chracc_plot <- renderPlot({
    pt_gbin_chracc_plot()
  })
  
  observeEvent(input$pt_gbin_chracc_plot, {
    download_plot(pt_gbin_chracc_plot())
  })
  
  # Reactive value indicating whether chosen bin maps to at least 1 ensembl gene
  pt_gbin_exist_ensembl <- reactiveVal(TRUE)
  
  # Message that indicates no expression values are associated with selected bin
  output$pt_gbin_no_ensembl_msg <- renderUI({
    if (! pt_gbin_exist_ensembl()) {
      p("The selected genomic bin's nearest gene does not map to any ENSEMBL genes in expression matrix. Please select a different bin. ")
    }
  })
  
  pt_gbin_expr_plot <- reactive({
    pt_gbin_exist_ensembl(TRUE)
    if (length(input$top_var_gbin_table_rows_selected == 1)) {
      gbin <- rownames(pca_top_var_pred_mat())[input$top_var_gbin_table_rows_selected]
      gene <- gbin_tss[gbin, "gene"]
      ensembl <- annots[annots$SYMBOL %in% gene, "ENSEMBL"]
      if (sum(ensembl %in% rownames(scaled_expr_pt_mat())) == 0) {
        # No matching non-zero expression value found
        pt_gbin_exist_ensembl(FALSE)
        return(NULL)
      }
      gbin_expr <- colMeans(scaled_expr_pt_mat()[ensembl, , drop=F])
      names(gbin_expr) <- colnames(scaled_expr_pt_mat())
      expr_along_pt_plot(gbin_expr, pred_order())
    }
  })
  
  # Render expression along pseudo time plot for chosen genomic bin
  output$pt_gbin_expr_plot <- renderPlot({
    pt_gbin_expr_plot()
  })
  
  observeEvent(input$pt_gbin_expr_plot_download, {
    download_plot(pt_gbin_expr_plot())
  })
  
  # Make genomic bin chromatin accessibility along pseudo time heat map
  pt_gbin_chracc_heatmap <- reactive({
    topvar_pred_mat_gbins <- rownames(pca_top_var_pred_mat())
    topvar_pred_mat <- pca_top_var_pred_mat()
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$pt_gbin_chracc_heatmap_show_nearest_genes) {
      nearest_genes <- gbin_tss[rownames(pca_top_var_pred_mat()), ]$gene
      nearest_genes[is.na(nearest_genes)] <- "None"
      rownames(topvar_pred_mat) <- nearest_genes
    }
    if (input$pt_gbin_chracc_heatmap_sort_by == "Decreasing variance") {
      hypervar <- pred_hypervar()$hypervar[pred_hypervar()$feature %in% topvar_pred_mat_gbins]
      sort_idx <- base::sort(hypervar, 
                             decreasing=TRUE, 
                             index.return=TRUE)$ix
      row.order <- order(sort_idx)
      cluster.rows <- FALSE
    } else if (input$pt_gbin_chracc_heatmap_sort_by == "Genomic position") {
      row.order <- order(1:nrow(topvar_pred_mat))
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    heat_mat <- topvar_pred_mat[, pred_order()[, 1]]
    if (input$pt_gbin_chracc_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat[is.na(heat_mat)] <- 0
    }
    ht <- Heatmap(heat_mat, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "predicted \nchromatin \naccessibility"), 
                  cluster_columns = FALSE)
    if (input$pt_gbin_chracc_heatmap_show_nearest_genes) {
      ht <- ht + rowAnnotation(gbins = anno_text(topvar_pred_mat_gbins), 
                               nearest_genes = anno_text(nearest_genes))
    }
    removeModal()
    return(draw(ht))
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_chracc_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_chracc_heatmap())
  })
  
  # Render chromatin accessibility along pseudo time heat map for chosen genomic bin 
  output$pt_gbin_chracc_heatmap <- renderPlot({
    pt_gbin_chracc_heatmap()
  })
  
  observeEvent(input$pt_gbin_chracc_heatmap_download, {
    download_plot(pt_gbin_chracc_heatmap())
  })
  
  # Make genomic bin expression along pseudo time heat map
  pt_gbin_expr_heatmap <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    # Find nearest genes
    clu_gbin_tss <- gbin_tss[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    # Only keep genes with matching ensembl
    clu_annots <- annots[annots$SYMBOL %in% clu_gbin_tss$gene, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$gene %in% clu_annots$SYMBOL, ]
    # Find the expr vector for each gene symbol
    gene_expr <- aggregate(expr_mat()[clu_annots$ENSEMBL, , drop=F], 
                           list(gene=clu_annots$SYMBOL), mean)
    # Genes with non-zero expression variance
    gene_expr_mat <- as.matrix.data.frame(gene_expr[, -1])
    var_genes <- gene_expr$gene[rowVars(gene_expr_mat) > 0]
    gene_expr_mat <- gene_expr_mat[gene_expr$gene %in% var_genes, , drop=F]
    rownames(gene_expr_mat) <- var_genes
    bin_genes <- clu_gbin_tss$gene[clu_gbin_tss$gene %in% var_genes]
    bin_expr_mat <- gene_expr_mat[bin_genes, colnames(scaled_expr_pt_mat()), drop=F]
    bins <- rownames(clu_gbin_tss)[clu_gbin_tss$gene %in% var_genes]
    rownames(bin_expr_mat) <- bins
    
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$pt_gbin_expr_heatmap_show_nearest_genes) {
      rownames(bin_expr_mat) <- bin_genes
    }
    if (input$pt_gbin_expr_heatmap_sort_by == "Decreasing variance") {
      max_k <- min(apply(bin_expr_mat, 2, function(x){length(unique(x))}))
      if (ncol(bin_expr_mat) >= max_k) {
        # Cannot use hypervar
        row.order <- order(rowVars(bin_expr_mat), decreasing = T)
      } else {
        hypervar <- hypervar_bulk(bin_expr_mat)
        row.order <- order(hypervar$hypervar, decreasing = T)
      }
      cluster.rows <- FALSE
    } else if (input$pt_gbin_expr_heatmap_sort_by == "Genomic position") {
      row.order <- order(1:nrow(bin_expr_mat))
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    heat_mat <- bin_expr_mat
    if (input$pt_gbin_expr_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat[is.na(heat_mat)] <- 0
    }
    ht <- Heatmap(heat_mat, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "log2 expression"), 
                  cluster_columns = FALSE)
    if (input$pt_gbin_expr_heatmap_show_nearest_genes) {
      ht <- ht + rowAnnotation(gbins = anno_text(bins), 
                               nearest_genes = anno_text(bin_genes))
    }
    removeModal()
    return(draw(ht))
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_expr_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_expr_heatmap())
  })
  
  # Render expression along pseudo time heat map for chosen genomic bin 
  output$pt_gbin_expr_heatmap <- renderPlot({
    pt_gbin_expr_heatmap()
  })
  
  observeEvent(input$pt_gbin_expr_heatmap_download, {
    download_plot(pt_gbin_expr_heatmap())
  })
  
  # Render genomic bin chromatin accessibility visualization UI
  output$pt_gbin_chracc_ui <- renderUI({
    if (input$pt_gbin_chracc_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Top variance genomic bins table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gbin_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("top_var_gbin_table_info", 
                  title = "<h4>Top variance genomic bins table</h4>", 
                  content = do.call(paste0, popover_contents$top_var_gbin_table_info), 
                  placement = "right",
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gbin_table'), 
        hr(), 
        h4("Genomic bin chromatin accessibility along pseudo-time plot"), 
        plotOutput('pt_gbin_chracc_plot'), 
        bsTooltip("pt_gbin_chracc_plot", 
                  title = "Each point in this plot represents a sample. The samples are sorted by assigned pseudo-time point along x-axis. The y-axis values are predicted log<sub>2</sub> accessibility for each sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_chracc_plot_download", "Download plot")
      )
    } else if (input$pt_gbin_chracc_choose_plot == "Heatmap") {
      tagList(
        h4("Genomic bin expression along pseudo-time heat map"), 
        fluidRow(
          column(
            4, 
            radioButtons(
              "pt_gbin_chracc_heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            )
          ), 
          column(
            4, 
            checkboxInput(
              "pt_gbin_chracc_heatmap_show_nearest_genes", 
              label = "Show nearest genes",
              value = FALSE
            ),
            checkboxInput(
              "pt_gbin_chracc_heatmap_scale", 
              "Scale heatmap rows", 
              value = TRUE
            )
          )
        ),
        actionButton('show_interactive_pt_gbin_chracc_heatmap', 
                     "Show interactive heatmap"), 
        plotOutput('pt_gbin_chracc_heatmap'), 
        bsTooltip("pt_gbin_chracc_heatmap", 
                  title = "Columns in this heat map are samples, and they are sorted by the assigned pseudo-time point. Rows in this heat map are genomic bins. Each cell in this heat map is the predicted log<sub>2</sub> accessibility of a genomic position in a sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_chracc_heatmap_download", "Download plot")
      )
    }
  })
  
  # Render genomic bin expression visualization UI
  output$pt_gbin_expr_ui <- renderUI({
    if (input$pt_gbin_expr_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Top variance genomic bins table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gbin_table_info_expr", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("top_var_gbin_table_info_expr", 
                  title = "<h4>Top variance genomic bins table</h4>", 
                  content = do.call(paste0, popover_contents$top_var_gbin_table_info_expr), 
                  placement = "right",
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gbin_table'), 
        hr(), 
        h4("Genomic bin expression along pseudo-time plot"), 
        uiOutput("pt_gbin_no_ensembl_msg"),
        plotOutput('pt_gbin_expr_plot'), 
        bsTooltip("pt_gbin_expr_plot", 
                  title = "Each point in this plot represents a sample. The samples are sorted by assigned pseudo-time point along x-axis. The y-axis values are average scaled log<sub>2</sub> expression for each sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_expr_plot_download", "Download plot")
      )
    } else if (input$pt_gbin_expr_choose_plot == "Heatmap") {
      tagList(
        h4("Genomic bin expression along pseudo-time heat map"), 
        fluidRow(
          column(
            4, 
            radioButtons(
              "pt_gbin_expr_heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            )
          ), 
          column(
            4, 
            checkboxInput(
              "pt_gbin_expr_heatmap_show_nearest_genes", 
              label = "Show nearest genes",
              value = FALSE
            ),
            checkboxInput(
              "pt_gbin_expr_heatmap_scale", 
              "Scale heatmap rows", 
              value = TRUE
            )
          )
        ),
        actionButton('show_interactive_pt_gbin_expr_heatmap', 
                     "Show interactive heatmap"), 
        plotOutput('pt_gbin_expr_heatmap'), 
        bsTooltip("pt_gbin_expr_heatmap", 
                  title = "Columns in this heat map are samples, and they are sorted by the assigned pseudo-time point. Rows in this heat map are genomic bins. Each cell in this heat map is the average scaled log<sub>2</sub> expression of a genomic position in a sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_expr_heatmap_download", "Download plot")
      )
    }
  })
  
  # Top variance genomic bins data table
  output$top_var_gbin_table <- DT::renderDataTable({
    showModal(modalDialog("Rendering top variance genomic bins information table...", footer = NULL, easyClose = TRUE, size = "s"))
    gbin_names <- rownames(pca_top_var_pred_mat())
    df <- parse_gbin(rownames(pca_top_var_pred_mat()))
    topvar_gbin_tss <- gbin_tss[gbin_names, ]
    topvar_gbin_snp <- gbin_snp[gbin_names, ]
    df$nearest_gene <- as.factor(topvar_gbin_tss$gene)
    df$distance_to_gene <- topvar_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(topvar_gbin_tss$relative_position_to_tss)
    df$nearest_snp <- topvar_gbin_snp$snp_id
    df$snp_position <- topvar_gbin_snp$position
    df$snp_associated_trait <- topvar_gbin_snp[, 3]
    df$distance_to_snp <- topvar_gbin_snp$distance
    if ((! is.null(input$pt_show_panel)) && 
        (input$pt_show_panel == "Nearest gene expression along pseudotime")) {
      df <- df[df$distance_to_gene <= input$pt_gene_maxdist, ]
    }
    removeModal()
    DT::datatable(df, 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'single', 
                  options = list(scrollX = TRUE))
  })
  
  pt_gene_chracc_gene_dist_plot <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_chracc_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_chracc_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  output$pt_gene_chracc_gene_dist_plot <- renderPlotly({
    pt_gene_chracc_gene_dist_plot()
  })
  
  output$pt_gene_expr_gene_dist_plot <- renderPlotly({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_expr_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_expr_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  pca_top_var_nearest_genes <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    req(input$pt_show_panel)
    if ((input$pt_show_panel == "Nearest gene expression along pseudotime") &&
        (! is.null(input$pt_expr_dat_type)) && (input$pt_expr_dat_type == "Gene average")) {
      maxdist <- input$pt_gene_expr_gene_maxdist
    } else if ((input$pt_show_panel == "Accessibility along pseudotime") &&
               (! is.null(input$pt_chracc_dat_type)) && (input$pt_chracc_dat_type == "Gene average")) {
      maxdist <- input$pt_gene_chracc_gene_maxdist
    } else {return(data.frame(genes=c()))}
    nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= maxdist, ]$gene)
    if ((input$pt_show_panel == "Nearest gene expression along pseudotime") & input$pt_expr_dat_type == "Gene average") {
      # ensembl_annots <- annots[annots$SYMBOL %in% nearest_genes, ]
      # ensembl_annots <- ensembl_annots[ensembl_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
      # nearest_genes <- ensembl_annots$SYMBOL
      nearest_genes <- nearest_genes[nearest_genes %in% annots$SYMBOL]
    }
    data.frame(genes = nearest_genes[! is.na(nearest_genes)])
  })
  
  # Top variance genes data table
  output$top_var_gene_table <- DT::renderDataTable({
    DT::datatable(pca_top_var_nearest_genes(), 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'single')
  })
  
  # Render pseudo time analysis selected gene TSS table
  output$pt_gene_tss_table <- DT::renderDataTable({
    selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
    selected_gene_tss <- gene_tss[which(gene_tss$Gene == selected_gene), -3]
    DT::datatable(selected_gene_tss, 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'none')
  })
  
  # Render pseudo time analysis selected gene TSS table UI
  output$pt_gene_tss_table_ui <- renderUI({
    if (input$pt_gene_show_tss_table) {
      tagList(
        h4("Selected gene's transcriptional start sites table"), 
        DT::dataTableOutput('pt_gene_tss_table')
      )
    }
  })
  
  # Vector of associated genomic bins for selected gene in pseudo time analysis
  pt_selected_gene_gbins <- reactive({
    selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
    all_gene_gbins <- rownames(gbin_tss)[which(gbin_tss$gene == selected_gene)]
    all_gene_gbins[which(all_gene_gbins %in% rownames(pca_top_var_pred_mat()))]
  })
  
  # Render pseudo time analysis selected gene gbins table
  output$pt_gene_gbins_table <- DT::renderDataTable({
    DT::datatable(parse_gbin(pt_selected_gene_gbins()), 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'none')
  })
  
  # Render pseudo time analysis selected gene gbins table UI
  output$pt_gene_gbins_table_ui <- renderUI({
    if (input$pt_gene_show_gbins_table) {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Gene's nearest genomic bins table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("pt_gene_gbins_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")), 
        bsPopover("pt_gene_gbins_table_info", 
                  title = "<h4>Nearest genomic bins table</h4>", 
                  content = do.call(paste0, popover_contents$pt_gene_gbins_table_info), 
                  placement = "right",
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)), 
        DT::dataTableOutput('pt_gene_gbins_table')
      )
    }
  })
  
  pt_gene_chracc_plot <- reactive({
    if (length(input$top_var_gene_table_rows_selected == 1)) {
      # Get predicted chromatin accessibility for associated bins
      near_gbins_chracc <- pca_top_var_pred_mat()[pt_selected_gene_gbins(), ]
      # Get mean accessibility
      if (length(pt_selected_gene_gbins()) > 1) {
        near_gbins_chracc <- colMeans(near_gbins_chracc)
      }
      chracc_along_pt_plot(near_gbins_chracc, pred_order())
    }
  })
  
  # Render chromatin accessibility along pseudo time plot for chosen gene
  output$pt_gene_chracc_plot <- renderPlot({
    pt_gene_chracc_plot()
  })
  
  observeEvent(input$pt_gene_chracc_plot_download, {
    download_plot(pt_gene_chracc_plot())
  })
  
  pt_gene_expr_plot <- reactive({
    if (length(input$top_var_gene_table_rows_selected == 1)) {
      # Get expression for gene
      selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
      ensembls <- annots$ENSEMBL[annots$SYMBOL == selected_gene]
      ensembls <- ensembls[ensembls %in% rownames(scaled_expr_pt_mat())]
      if (length(ensembls) == 0) {
        return(NULL)
      }
      gene_expr <- colMeans(scaled_expr_pt_mat()[ensembls, , drop=F])
      names(gene_expr) <- colnames(scaled_expr_pt_mat())
      expr_along_pt_plot(gene_expr, pred_order())
    }
  })
  
  # Render expression along pseudo time plot for chosen gene
  output$pt_gene_expr_plot <- renderPlot({
    pt_gene_expr_plot()
  })
  
  observeEvent(input$pt_gene_expr_plot, {
    download_plot(pt_gene_expr_plot())
  })
  
  # Render text message indicating ENSEMBL genes that selected gene maps to
  output$pt_gene_expr_ensembl_msg <- renderText({
    selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
    ensembls <- annots$ENSEMBL[annots$SYMBOL == selected_gene]
    var_ensembls <- ensembls[ensembls %in% rownames(scaled_expr_pt_mat())]
    paste0("The selected gene maps to the following ENSEMBL genes: ", 
           paste(ensembls, collapse = ", "), 
           ", of which ", length(var_ensembls), 
           " (", paste(var_ensembls, collapse = ", "), ") are of non-zero expression variance.")
  })
  
  # Make gene chromatin accessibility along pseudo time heat map
  pt_gene_chracc_heatmap <- reactive({
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    # Get average chromatin accessibility for each gene
    avg_chracc <- lapply(pca_top_var_nearest_genes()$genes, function(x) {
      gbins <- rownames(gbin_tss)[which(gbin_tss$gene == x)]
      # Get predicted chromatin accessibility for associated bins
      near_gbins_chracc <- pca_top_var_pred_mat()[which(rownames(pca_top_var_pred_mat()) %in% gbins), ]
      # Get mean accessibility
      if (length(which(rownames(pca_top_var_pred_mat()) %in% gbins)) > 1) {
        colMeans(near_gbins_chracc)
      } else {
        near_gbins_chracc
      }
    })
    avg_chracc <- as.data.frame(do.call(rbind, avg_chracc))
    rownames(avg_chracc) <- pca_top_var_nearest_genes()$genes
    heat_mat <- as.matrix(avg_chracc[, pred_order()[, 1]])
    if (input$pt_gene_chracc_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat[is.na(heat_mat)] <- 0
    }
    ht <- Heatmap(heat_mat, 
                  heatmap_legend_param = list(title = "predicted \nchromatin \naccessibility"), 
                  cluster_columns = FALSE)
    removeModal()
    return(draw(ht))
  })
  
  # Make gene expression along pseudo time heat map
  pt_gene_expr_heatmap <- reactive({
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    # Get expression for each gene
    ensembl_annots <- annots[annots$SYMBOL %in% pca_top_var_nearest_genes()$genes, ]
    heat_mat <- aggregate(expr_mat()[ensembl_annots$ENSEMBL, pred_order()$sample_name, drop=F], 
                          by = list(gene=ensembl_annots$SYMBOL), 
                          mean)
    heat_mat <- as.matrix(heat_mat[, -1])
    colnames(heat_mat) <- pred_order()$sample_name
    rownames(heat_mat) <- ensembl_annots$SYMBOL
    if (input$pt_gene_expr_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat <- na.omit(heat_mat)
    }
    ht <- Heatmap(heat_mat, 
                  heatmap_legend_param = list(title = "expression"), 
                  cluster_columns = FALSE)
    removeModal()
    return(draw(ht))
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gene_chracc_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gene_chracc_heatmap())
  })
  
  # Render chromatin accessibility along pseudo time heat map for chosen gene
  output$pt_gene_chracc_heatmap <- renderPlot({
    pt_gene_chracc_heatmap()
  })
  
  observeEvent(input$pt_gene_chracc_heatmap_download, {
    download_plot(pt_gene_chracc_heatmap())
  })
  
  # Render expression along pseudo time heat map
  output$pt_gene_expr_heatmap <- renderPlot({
    pt_gene_expr_heatmap()
  })
  
  observeEvent(input$pt_gene_expr_heatmap_download, {
    download_plot(pt_gene_expr_heatmap())
  })
  
  # Render gene chromatin accessibility visualization UI
  output$pt_gene_chracc_ui <- renderUI({
    if (input$pt_gene_chracc_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Genes table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gene_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")), 
        bsPopover("top_var_gene_table_info", 
                  title = "<h4>Table for genes near top variance genomic bins</h4>", 
                  content = do.call(paste0, popover_contents$top_var_gene_table_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gene_table'), 
        checkboxInput(
          'pt_gene_show_tss_table', 
          label = "Show selected gene's transcription start sites", 
          value = FALSE
        ), 
        uiOutput('pt_gene_tss_table_ui'),
        checkboxInput(
          'pt_gene_show_gbins_table', 
          label = "Show selected gene's associated genomic bins", 
          value = FALSE
        ), 
        uiOutput('pt_gene_gbins_table_ui'),
        h4("Gene average accessibility along pseudo-time plot"), 
        plotOutput('pt_gene_chracc_plot'), 
        bsTooltip("pt_gene_chracc_plot", 
                  title = "Along the x-axis of this plot are the samples sorted in assigned pseudo-time. The data point y-values are the average predicted log<sub>2</sub> chromatin accessibility for genomic bins nearest the selected gene. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gene_chracc_plot_download", "Download plot")
      )
    } else if (input$pt_gene_chracc_choose_plot == "Heatmap") {
      if (nrow(pca_top_var_nearest_genes()) >= 2) {
        tagList(
          h4("Gene average accessibility along pseudo-time heat map"), 
          actionButton('show_interactive_pt_gene_chracc_heatmap', 
                       "Show interactive heatmap"), 
          checkboxInput("pt_gene_chracc_heatmap_scale", "Scale heatmap rows", value = TRUE),
          plotOutput('pt_gene_chracc_heatmap'),
          bsTooltip("pt_gene_chracc_heatmap", 
                    title = "The heat map columns are samples sorted in assigned pseudo-time. The rows are the genes near top variance genomic bins. Each heat map cell shows the average predicted log<sub>2</sub> chromatin accessibility for genomic bins nearest the gene. ", 
                    placement = "top", 
                    options = list(html = TRUE)), 
          actionButton("pt_gene_chracc_heatmap_download", "Download plot")
        )
      } else {
        # No need to use heat map visualization
        p("Not enough genes to generate heat map. At least 2 genes are required for heat map visualization. ")
      }
    }
  })
  
  # Render gene expression visualization UI
  output$pt_gene_expr_ui <- renderUI({
    if (input$pt_gene_expr_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Genes table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gene_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")), 
        bsPopover("top_var_gene_table_info", 
                  title = "<h4>Table for genes near top variance genomic bins</h4>", 
                  content = do.call(paste0, popover_contents$top_var_gene_table_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gene_table'), 
        checkboxInput(
          'pt_gene_show_tss_table', 
          label = "Show selected gene's transcription start sites", 
          value = FALSE
        ), 
        uiOutput('pt_gene_tss_table_ui'),
        checkboxInput(
          'pt_gene_show_gbins_table', 
          label = "Show selected gene's associated genomic bins", 
          value = FALSE
        ), 
        uiOutput('pt_gene_gbins_table_ui'),
        h4("Gene expression along pseudo-time plot"), 
        plotOutput('pt_gene_expr_plot'), 
        textOutput("pt_gene_expr_ensembl_msg"), 
        bsTooltip("pt_gene_expr_plot", 
                  title = "Along the x-axis of this plot are the samples sorted in assigned pseudo-time. The data point y-values are the scaled log<sub>2</sub> expression for the selected gene. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gene_expr_plot_download", "Download plot")
      )
    } else if (input$pt_gene_expr_choose_plot == "Heatmap") {
      if ((! is.null(pca_top_var_nearest_genes())) && (nrow(pca_top_var_nearest_genes()) >= 2)) {
        tagList(
          h4("Gene expression along pseudo-time heat map"), 
          actionButton('show_interactive_pt_gene_expr_heatmap', 
                       "Show interactive heatmap"), 
          checkboxInput("pt_gene_expr_heatmap_scale", "Scale heatmap rows", value = TRUE),
          plotOutput('pt_gene_expr_heatmap'),
          bsTooltip("pt_gene_expr_heatmap", 
                    title = "The heat map columns are samples sorted in assigned pseudo-time. The rows are the genes near top variance genomic bins. Each heat map cell shows the log<sub>2</sub> expression of a gene. ", 
                    placement = "top", 
                    options = list(html = TRUE)), 
          actionButton("pt_gene_expr_heatmap_download", "Download plot")
        )
      } else {
        # No need to use heat map visualization
        p("Not enough genes to generate heat map. At least 2 genes are required for heat map visualization. ")
      }
    }
  })
  
  # Render differential test following pseudo-time UI
  output$pt_diff_ui <- renderUI({
    if (is.null(input$pt_n_pc)) {
      p("Please go to Pseudo-time analysis tab to compute and select a pseudo-time trajectory first. ")
    } else {
      sidebarLayout(
        sidebarPanel(
          selectInput(
            "pt_diff_show_panel", 
            "Show differential test results for:", 
            choices = c("Individual genomic bins", 
                        "Genomic bin clusters", 
                        "Gene average accessibility")
          ),
          uiOutput("pt_diff_opts_ui"), 
          actionButton("run_pt_diff_test", "Perform Test")
        ), 
        mainPanel(
          uiOutput("pt_diff_res_panels")
        )
      )
    }
  })
  
  # Render UI for differential test along pseudo time options
  output$pt_diff_opts_ui <- renderUI({
    if (input$pt_diff_show_panel == "Genomic bin clusters") {
      tagList(
        sliderInput(
          "pt_diff_n_gbin_clust", 
          label = "Number of genomic bin clusters: ", 
          min = 1, 
          max = min(max_n_gbin, nrow(pred_mat())), 
          value = opt_n_gbin_clust(), 
          step = 1
        ), 
        bsTooltip("pt_diff_n_gbin_clust", 
                  title = "How many clusters do you want to group the top variance bins into? Detailed clustering results are shown in Pseudo-time analysis tab. ",
                  placement = "right", 
                  options = list(container = "body", 
                                 html = TRUE)), 
        checkboxInput(
          "pt_diff_use_opt_n_gbin_clust", 
          label = "Use optimal number of genomic bin clusters", 
          value = TRUE
        ), 
        htmlOutput('pt_diff_opt_n_gbin_clust_msg'),
        bsTooltip("pt_diff_opt_n_gbin_clust_msg", 
                  title = "The optimal number of genomic bin clusters is determined by elbow method. ",
                  placement = "right", 
                  options = list(container = "body", 
                                 html = TRUE))
      )
    } else if (input$pt_diff_show_panel == "Gene average accessibility") {
      tagList(
        sliderInput("pt_diff_gene_maxdist", 
                    "Maximum distance limit of bins to nearest gene TSS",
                    min = 0, 
                    max = 1e6, 
                    value = 500, 
                    post = "bp",
                    step = 100), 
        plotlyOutput("pt_diff_gene_dist_plot"), 
        uiOutput("pt_diff_ngene_msg")
      )
    }
  })
  
  output$pt_diff_gene_dist_plot <- renderPlotly({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_diff_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  pt_diff_nearest_genes <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_gene_maxdist, ]$gene)
    nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    nearest_genes
  })
  
  output$pt_diff_ngene_msg <- renderUI({
    HTML(paste("<p>", strong(length(pt_diff_nearest_genes())), "genes are inside the selected maximum mapping distance of selected bins. </p>"))
  })
  
  # Selected genomic bin clustering results
  pt_diff_gbin_clust_res <- reactive({
    if (! is.null(input$pt_diff_n_gbin_clust)) {
      kmeans_res <- all_gbin_clust_res()[[as.character(input$pt_diff_n_gbin_clust)]]
      return(kmeans_res)
    } 
  })
  
  # Message stating the optimal number of clusters
  output$pt_diff_opt_n_gbin_clust_msg <- renderUI({
    HTML(paste("Optimal number of clusters:", strong(opt_n_gbin_clust())))
  })
  
  # Differential test along pseudo time
  pt_difftest <- function(data, order, df = 3) {   
    ptime <- 1:length(order)
    pval <- apply(data[,order,drop=F], 1, function(x) {
      if (sum(x) == 0) {
        1
      } else {
        model <- mgcv::gam(x~s(ptime,k=df))
        pchisq(model$null.deviance - model$deviance, model$df.null - model$df.residual,lower.tail = F)
      }
    })      
    fdr <- p.adjust(pval, method = "fdr")
    res <- data.frame(pvalue = pval,FDR = fdr)
  }
  
  # Perform differential tests along pt (adapted from TSCAN)
  pt_diff_test_res <- reactive({
    if (input$run_pt_diff_test > 0) {
      isolate({
        showModal(modalDialog("Running differential test...", size = "s", easyClose = TRUE, footer = NULL))
        if (input$pt_diff_show_panel == "Individual genomic bins") {
          res <- data.frame(genomic_bin = row.names(pca_top_var_pred_mat()), 
                            pt_difftest(data = pca_top_var_pred_mat(), order = pred_order()$sample_name), 
                            stringsAsFactors = F)
          removeModal()
          return(res)
        } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
          if (! is.null(pt_diff_gbin_clust_res())) {
            clust_means <- aggregate(pca_top_var_pred_mat(), 
                                     by=list(cluster=pt_diff_gbin_clust_res()$cluster), 
                                     mean)
            rownames(clust_means) <- clust_means$cluster
            clust_means <- clust_means[, 2:ncol(clust_means)]
            res <- data.frame(cluster = row.names(clust_means), 
                              pt_difftest(data = clust_means, order = pred_order()$sample_name), 
                              stringsAsFactors = F)
            removeModal()
            return(res)
          }
        } else if (input$pt_diff_show_panel == "Gene average accessibility") {
          gbin_names <- rownames(pca_top_var_pred_mat())
          topvar_gbin_tss <- gbin_tss[rownames(pca_top_var_pred_mat()), ]
          topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
          topvar_gbin_tss <- topvar_gbin_tss[! is.na(rownames(topvar_gbin_tss)), ]
          gene_avg <- aggregate(pca_top_var_pred_mat()[rownames(topvar_gbin_tss), ], 
                                by=list(gene=topvar_gbin_tss$gene), 
                                mean)
          rownames(gene_avg) <- gene_avg$gene
          gene_avg <- gene_avg[, 2:ncol(gene_avg)]
          res <- data.frame(gene = row.names(gene_avg), 
                            pt_difftest(data = gene_avg, order = pred_order()$sample_name), 
                            stringsAsFactors = F)
          removeModal()
          return(res)
        }
      })
    }
  })
  
  # Render differential analysis results panels
  output$pt_diff_res_panels <- renderUI({
    if ((! is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0)) {
      isolate({
        tabsetPanel(
          tabPanel("Results",
                   tags$div(
                     style = "margin-top:30px; margin-bottom:30px;", 
                     h4("Differential test results table"),
                     downloadButton("pt_diff_res_download", "Download results table"),
                     DT::dataTableOutput("pt_diff_res_table")
                   )),
          tabPanel("Summary",
                   tags$div(
                     style = "margin-top:30px; margin-bottom:30px;", 
                     wellPanel(
                       h4("Significant bins summary"),
                       fluidRow(
                         column(6, sliderInput("pt_diff_alpha", 
                                               "Level of significance (FDR): ", 
                                               min = 0.0001, 
                                               max = 0.5, 
                                               value = 0.05)), 
                         column(6, uiOutput("pt_diff_res_sig_bed_download_ui"))
                       ),
                       textOutput("pt_diff_sum_text")
                     ),
                     wellPanel(
                       radioButtons("pt_diff_res_hist_val",
                                    "Histogram of: ",
                                    c("p-value", "FDR")),
                       h4("Histogram summary"),
                       plotOutput("pt_diff_sum_hist"), 
                       bsTooltip("pt_diff_sum_hist", 
                                 title = "Histogram of selected value", 
                                 placement = "top", 
                                 options = list(container = "body")),
                       actionButton("pt_diff_sum_hist_download", "Download plot")
                     ), 
                     wellPanel(
                       h4("p-value adjustment line plot"),
                       plotOutput("pt_diff_sum_lineplot"), 
                       bsTooltip("pt_diff_sum_lineplot", 
                                 title = "Line plot of sorted p-values for all bins before and after FDR adjustment. Dashed line indicates the selected significance level. ", 
                                 placement = "top", 
                                 options = list(container = "body")), 
                       actionButton("pt_diff_sum_lineplot_download", "Download plot")
                     )
                   )), 
          tabPanel("Gene ontology", 
                   tags$div(
                     style = "margin-top:30px; margin-bottom:30px;", 
                     wellPanel(
                       wellPanel(
                         # GO options
                         sliderInput(
                           "pt_diff_go_alpha", 
                           "Level of significance: ", 
                           min = 0.0001, 
                           max = 1, 
                           value = 0.05
                         ),
                         uiOutput("pt_diff_go_sel_gbin_clusts_ui"), 
                         uiOutput("pt_diff_go_gene_maxdist_ui"), 
                         textOutput("pt_diff_go_sig_genes_msg"), 
                         uiOutput("pt_diff_go_external_tool_ui"),
                         bsTooltip("pt_diff_go_external_tool_ui", 
                                   title = "Use and external tool to analyze significant regions/genes in greater detail. ", 
                                   placement = "left", 
                                   options = list(container = "body")),
                         checkboxInput("pt_diff_go_show_sig_bins_table", 
                                       "Show table mapping significant bins to nearest genes"), 
                         uiOutput('pt_diff_go_sig_bins_table_ui')
                       ),
                       radioButtons("pt_diff_go_ctrl", 
                                    "Control gene list: ", 
                                    c("All genes near selected genomic range",
                                      "All genes near BIRD default prediction range")), 
                       bsTooltip("pt_diff_go_ctrl", 
                                 title = "Using only genes near the selected genomic range as control genes is recommended as using all genes will greatly slow down the runtime. ", 
                                 placement = "left", 
                                 options = list(container = "body")),
                       radioButtons("pt_diff_go_ontology", 
                                    "GO ontology: ", 
                                    c("Biological process" = "BP", 
                                      "Molecular function" = "MF", 
                                      "Cellular component" = "CC")), 
                       sliderInput("pt_diff_go_top_n", 
                                   "Number of top GO terms to return: ", 
                                   min = 10, 
                                   max = 500, 
                                   value = 20, 
                                   step = 10), 
                       actionButton("run_pt_diff_go", "Find top GO terms")
                     ), 
                     textOutput('pt_no_feasible_go_terms_warning'), 
                     uiOutput('pt_diff_go_sel_res_ui')
                   ))
        )
      })
    } else {
      p("Select sample groups and click on Perform Test to perform differential test on selected groups. ")
    }
  })
  
  # Differential test result table
  output$pt_diff_res_table <- DT::renderDataTable({
    if (! is.null(pt_diff_test_res())) {
      pt_diff_test_res() %>% 
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = "none") %>% 
        formatRound(columns=c('pvalue', "FDR"), digits=4)
    }
  })
  
  # Differential test result download
  output$pt_diff_res_download <- downloadHandler(
    filename = function() { "Differential_accessibility_along_pseudotime.txt" },
    content = function(file) {
      write.table(pt_diff_test_res(),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Significant bins from pseudo time differential test results summary
  pt_diff_sig_bins <- reactive({
    if ((! is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0)) {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        significant_bins <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        sig_clusts <- pt_diff_test_res()$cluster[pt_diff_test_res()$FDR < input$pt_diff_alpha]
        gbin_clusts <- data.frame(cluster = as.factor(pt_diff_gbin_clust_res()$cluster), 
                                  genomic_bin = names(pt_diff_gbin_clust_res()$cluster))
        significant_bins <- gbin_clusts$genomic_bin[gbin_clusts$cluster %in% sig_clusts]
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        significant_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
        topvar_gbin_tss <- gbin_tss[rownames(pca_top_var_pred_mat()), ]
        topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
        significant_bins <- rownames(topvar_gbin_tss)[topvar_gbin_tss$gene %in% significant_genes]
      }
      significant_bins
    }
  })
  
  # Render diff test significant bins bed download button UI
  output$pt_diff_res_sig_bed_download_ui <- renderUI({
    if (length(pt_diff_sig_bins()) > 0) {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        tagList(
          downloadButton("pt_diff_res_sig_bed_download", "Download significant bins BED file"), 
          bsTooltip("pt_diff_res_sig_bed_download", 
                    title = "BED file for bins that have significant differential accessibility along pseudo-time. ",
                    placement = "top")
        )
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        tagList(
          downloadButton("pt_diff_res_sig_bed_download", "Download significant clusters BED files"), 
          bsTooltip("pt_diff_res_sig_bed_download", 
                    title = "zip file of BED files. One BED file for each cluster. All bins in significantly differential clusters are included in the BED file for that cluster. ",
                    placement = "top")
        )
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        tagList(
          downloadButton("pt_diff_res_sig_bed_download", "Download significant bins BED file"), 
          bsTooltip("pt_diff_res_sig_bed_download", 
                    title = "BED file for all bins with nearest genes that have significant differential accessibility along pseudo-time. ",
                    placement = "top")
        )
      }
    }
  })
  
  # Differential test significant bins BED file download
  output$pt_diff_res_sig_bed_download <- downloadHandler(
    filename = function() {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        return("Pseudotime_significant_bins.bed")
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        return("Pseudotime_significant_clusters.zip")
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        return("Pseudotime_significant_genes.bed")
      }
    }, 
    content = function(file) {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        significant_bins <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
        write.table(parse_gbin(significant_bins), 
                    file, 
                    col.names = FALSE, 
                    row.names = FALSE, 
                    quote = FALSE, 
                    sep = "\t")
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        # Make zip file
        # Create temp folder to hold prediction files
        tmp <- tempdir()
        tmp_fpaths <- c()
        # Write the appropriate prediction to table
        gbin_clusts <- data.frame(cluster = as.factor(pt_diff_gbin_clust_res()$cluster), 
                                  genomic_bin = names(pt_diff_gbin_clust_res()$cluster))
        for (i in pt_diff_test_res()$cluster[pt_diff_test_res()$FDR < input$pt_diff_alpha]) {
          gbins <- gbin_clusts$genomic_bin[gbin_clusts$cluster == i]
          fname <- paste0("cluster_", i, ".bed")
          write.table(parse_gbin(gbins), 
                      file.path(tmp, fname), 
                      col.names = FALSE, 
                      row.names = FALSE, 
                      quote = FALSE, 
                      sep = "\t")
          tmp_fpaths <- append(tmp_fpaths, file.path(tmp, fname))
        }
        zip(zipfile = file, files = tmp_fpaths, extras = '-j')
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        significant_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
        topvar_gbin_tss <- gbin_tss[rownames(pca_top_var_pred_mat()), ]
        topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
        write.table(parse_gbin(rownames(topvar_gbin_tss)[topvar_gbin_tss$gene %in% significant_genes]), 
                    file, 
                    col.names = FALSE, 
                    row.names = FALSE, 
                    quote = FALSE, 
                    sep = "\t")
      }
    }
  )
  
  # Render text message for number of significant bins
  output$pt_diff_sum_text <- renderText({
    if (!is.null(pt_diff_test_res())) {
      n_sigbins <- sum(pt_diff_test_res()$FDR < input$pt_diff_alpha)
      pct <- round(mean(pt_diff_test_res()$FDR < input$pt_diff_alpha),digits=4) * 100
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        paste("There are ", n_sigbins, "significant bins, which is", pct, "percent of all selected genomic bins")
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        paste("There are ", n_sigbins, "significant clusters, which is", pct, "percent of all genomic bins clusters")
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        paste("There are ", n_sigbins, "significant genes, which is", pct, "percent of all genes near selected genomic bins")
      }
    }
  })
  
  pt_diff_sum_hist <- reactive({
    if (!is.null(pt_diff_test_res())) {
      if (input$pt_diff_res_hist_val == "statistics") {
        g <- ggplot(pt_diff_test_res(), aes(statistics)) + geom_histogram(bins = 30) 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="Statistics", y="Frequency")
        g
      } else if (input$pt_diff_res_hist_val == "FDR") {
        g <- ggplot(pt_diff_test_res(), aes(FDR)) + geom_histogram(bins = 30) 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="FDR", y="Frequency")
        g <- g + geom_vline(xintercept = input$diff_alpha, linetype = "dotted", colour = "blue")
        g
      } else if (input$pt_diff_res_hist_val == "p-value") {
        g <- ggplot(pt_diff_test_res(), aes(pvalue)) + geom_histogram(bins = 30) 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="p-value", y="Frequency")
        g
      }
    }
  })
  
  # Render summary histogram for differential test result
  output$pt_diff_sum_hist <- renderPlot({
    pt_diff_sum_hist()
  })
  
  observeEvent(input$pt_diff_sum_hist_download, {
    download_plot(pt_diff_sum_hist())
  })
  
  pt_diff_sum_lineplot <- reactive({
    g <- ggplot(pt_diff_test_res()[order(pt_diff_test_res()$pvalue), ], aes(1:nrow(pt_diff_test_res())))
    g <- g + geom_line(aes(y=pvalue, color = "red")) + geom_line(aes(y=FDR, color = "blue"))
    g <- g + geom_hline(yintercept = input$pt_diff_alpha, linetype = "dotted", colour = "blue")
    g <- g + theme(panel.background = element_blank())
    g <- g + labs(x="Genomic bins sorted by p-values", y="Values")
    g <- g + scale_colour_manual(name = 'Values', 
                                 values = c('blue'='blue','red'='red'), 
                                 labels = c('FDR','p-value'))
    g
  })
  
  # Render summary line plot for differential test result
  output$pt_diff_sum_lineplot <- renderPlot({
    pt_diff_sum_lineplot()
  })
  
  observeEvent(input$pt_diff_sum_lineplot_download, {
    download_plot(pt_diff_sum_lineplot())
  })
  
  output$pt_diff_go_sel_gbin_clusts_ui <- renderUI({
    if ((input$run_pt_diff_test > 0) && (! is.null(pt_diff_test_res())) && (!is.null(input$pt_diff_go_alpha))) {
      isolate({
        if (input$pt_diff_show_panel == "Genomic bin clusters") {
          sig_clusts <- pt_diff_test_res()$cluster[pt_diff_test_res()$FDR < input$pt_diff_go_alpha]
          selectInput(
            "pt_diff_go_sel_gbin_clusts", 
            "Significant clusters to use for GO enrichment analysis: ",
            choices = sig_clusts, 
            selected = sig_clusts, 
            multiple = TRUE
          )
        }
      })
    }
  })
  
  output$pt_diff_go_gene_maxdist_ui <- renderUI({
    if ((!is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0)) {
      isolate({
        if(input$pt_diff_show_panel != "Gene average accessibility") {
          tagList(
            sliderInput("pt_diff_go_gene_maxdist", 
                        "Maximum distance limit of bins to nearest gene TSS",
                        min = 0, 
                        max = 1e6, 
                        value = 500, 
                        post = "bp",
                        step = 100), 
            plotlyOutput("pt_diff_go_gene_dist_plot")
          )
        }
      })
    }
  })
  
  # Significant bins from pseudo time differential test results for GO analysis
  pt_diff_go_sig_bins <- reactive({
    if (input$pt_diff_show_panel == "Genomic bin clusters") {
      sig_clusts <- input$pt_diff_go_sel_gbin_clusts
      gbin_clusts <- data.frame(cluster = as.factor(pt_diff_gbin_clust_res()$cluster), 
                                genomic_bin = names(pt_diff_gbin_clust_res()$cluster))
      significant_bins <- gbin_clusts$genomic_bin[gbin_clusts$cluster %in% sig_clusts]
    } else if (input$pt_diff_show_panel == "Gene average accessibility") {
      significant_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_go_alpha, 1]
      topvar_gbin_tss <- gbin_tss[rownames(pca_top_var_pred_mat()), ]
      topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
      significant_bins <- rownames(topvar_gbin_tss)[topvar_gbin_tss$gene %in% significant_genes]
    } else if (input$pt_diff_show_panel == "Individual genomic bins") {
      significant_bins <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_go_alpha, 1]
    }
    significant_bins[! is.na(significant_bins)]
  })
  
  pt_diff_go_nearest_genes <- reactive({
    if (input$pt_diff_show_panel == "Gene average accessibility") {
      nearest_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_go_alpha, 1]
      nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    } else {
      gbin_names <- pt_diff_go_sig_bins()
      sel_gbin_gene <- gbin_tss[gbin_names, ]
      nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_go_gene_maxdist, ]$gene)
      nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    }
    nearest_genes
  })
  
  output$pt_diff_go_gene_dist_plot <- renderPlotly({
    gbin_names <- pt_diff_go_sig_bins()
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_go_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_diff_go_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Significant genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  # Render text message for number of significant bins and nearest genes
  output$pt_diff_go_sig_genes_msg <- renderText({
    if ((!is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0) && (! is.null(input$pt_diff_go_alpha))) {
      if (((input$pt_diff_show_panel != "Genomic bin clusters") || (!is.null(input$pt_diff_go_sel_gbin_clusts))) &&
          ((input$pt_diff_show_panel == "Gene average accessibility") || (!is.null(input$pt_diff_go_gene_maxdist)))) {
        isolate({
          if (input$pt_diff_show_panel == "Individual genomic bins") {
            # sig_genes <- unique(gbin_tss[pt_diff_go_sig_bins(), ]$gene)
            # sig_genes <- sig_genes[! is.na(sig_genes)]
            return(paste("There are", 
                         length(pt_diff_go_sig_bins()[! is.na(pt_diff_go_sig_bins())]), 
                         "significant bins, which map to", 
                         length(pt_diff_go_nearest_genes()), 
                         "nearest genes that will be used in GO term enrichment analysis. "))
          } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
            sig_clusts <- input$pt_diff_go_sel_gbin_clusts
            # sig_genes <- unique(gbin_tss[pt_diff_go_sig_bins(), ]$gene)
            # sig_genes <- sig_genes[! is.na(sig_genes)]
            return(paste("You selected", 
                         length(sig_clusts), 
                         "significant clusters, which contain", 
                         length(pt_diff_go_sig_bins()[! is.na(pt_diff_go_sig_bins())]), 
                         "bins and map to", 
                         length(pt_diff_go_nearest_genes()), 
                         "nearest genes that will be used in GO term enrichment analysis. "))
          } else if (input$pt_diff_show_panel == "Gene average accessibility") {
            # sig_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
            # sig_genes <- sig_genes[! is.na(sig_genes)]
            return(paste("There are", 
                         length(pt_diff_go_nearest_genes()), 
                         "significant genes that will be used in GO term enrichment analysis. "))
          }
        })
        
      }
    }
  })
  
  output$pt_diff_go_external_tool_ui <- renderUI({
    if (input$pt_diff_show_panel == "Gene average accessibility") {
      return(fluidRow(column(6, wellPanel(uiOutput("pt_diff_go_ext_gbin_func")))))
    } else {
      return(fluidRow(
        column(6, wellPanel(uiOutput("pt_diff_go_ext_gene_func"))), 
        column(6, wellPanel(uiOutput("pt_diff_go_ext_gbin_func")))
      ))
    }
  })
  
  output$pt_diff_go_ext_gene_func <- renderUI({
    sig_genes <- pt_diff_go_nearest_genes()
    sig_genes <- sig_genes[! is.na(sig_genes)]
    sig_genes_text <- paste(sig_genes, collapse = "\n")
    if (sig_genes_text == "") {
      sig_genes_text <- " "
    }
    tagList(
      h4("Gene set analysis"), 
      actionButton(
        inputId = "pt_diff_enrichr_link", 
        label = "Go to Enrichr", 
        onclick = "window.open('https://maayanlab.cloud/Enrichr/')", 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(),
      rclipButton(
        inputId = "pt_diff_go_sig_genes_clipbtn", 
        label = "Copy significant genes", 
        clipText = sig_genes_text, 
        icon = icon("clipboard"), 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(),
      downloadButton("pt_diff_go_ext_genes_txt_download", "Download significant genes text file", style = "width: 100%; border: 1px solid white;")
    )
  })
  
  output$pt_diff_go_ext_gbin_func <- renderUI({
    df <- parse_gbin(pt_diff_go_sig_bins())
    clip_bed <- paste(capture.output(write.table(df, 
                                                 col.names = FALSE, 
                                                 row.names = FALSE, 
                                                 quote = FALSE, 
                                                 sep = "\t")), 
                      collapse = "\n")
    if (clip_bed == "") {
      clip_bed <- " "
    }
    tagList(
      h4("Genomic regions analysis"), 
      actionButton(
        inputId = "pt_diff_great_link", 
        label = "Go to GREAT", 
        onclick = "window.open('https://great.stanford.edu/great/public/html/')", 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(),
      rclipButton(
        inputId = "pt_diff_go_sig_gbins_clipbtn", 
        label = "Copy significant bins BED", 
        clipText = clip_bed, 
        icon = icon("clipboard"),
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(),
      downloadButton("pt_diff_go_ext_bed_download", "Download significant bins BED", style = "width: 100%; border: 1px solid white;")
    )
  })
  
  output$pt_diff_go_ext_genes_txt_download <- downloadHandler(
    filename = "Pseudotime_significant_genes.txt", 
    content = function(file) {
      if (input$pt_diff_show_panel == "Gene average accessibility") {
        sig_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
      } else {
        sig_genes <- unique(gbin_tss[pt_diff_go_sig_bins(), ]$gene)
      }
      sig_genes <- sig_genes[! is.na(sig_genes)]
      writeLines(sig_genes, file)
    }
  )
  
  output$pt_diff_go_ext_bed_download <- downloadHandler(
    filename = "Pseudotime_significant_bins.bed", 
    content = function(file) {
      write.table(parse_gbin(pt_diff_go_sig_bins()), 
                  file, 
                  col.names = FALSE, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # UI for significant bins table
  output$pt_diff_go_sig_bins_table_ui <- renderUI({
    if ((input$pt_diff_go_show_sig_bins_table) && (length(pt_diff_go_sig_bins()) > 0)) {
      tagList(
        h4("Significant genomic bins and their nearest genes table"),
        downloadButton('pt_diff_go_sig_bins_table_download', "Download significant bins and nearest genes table"),
        DT::dataTableOutput('pt_diff_go_sig_bins_table')
      )
    }
  })
  
  # Reactive significant bins table
  pt_diff_go_sig_bins_table <- reactive({
    df <- parse_gbin(pt_diff_go_sig_bins())
    sig_gbin_tss <- gbin_tss[pt_diff_go_sig_bins(), ]
    df$nearest_gene <- as.factor(sig_gbin_tss$gene)
    df$distance_to_gene <- sig_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(sig_gbin_tss$relative_position_to_tss)
    df
  })
  
  # Differential test significant bins and nearest genes file download
  output$pt_diff_go_sig_bins_table_download <- downloadHandler(
    filename = "Significant_differential_bins_genes.txt", 
    content = function(file) {
      write.table(pt_diff_go_sig_bins_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render table showing significant bins and nearest genes
  output$pt_diff_go_sig_bins_table <- DT::renderDataTable(pt_diff_go_sig_bins_table() %>%
                                                            datatable(rownames = FALSE,
                                                                      filter = list(position = 'top', clear = FALSE), 
                                                                      selection = "none", 
                                                                      options = list(scrollX = TRUE)))
  
  # Record whether there is no feasible GO terms found for current submission
  pt_no_feasible_go_terms <- reactiveVal(FALSE)
  
  # Warning message when there is no feasible GO terms found for current submission
  output$pt_no_feasible_go_terms_warning <- renderText({
    if (pt_no_feasible_go_terms()) {
      paste("No enrichment can pe performed - no genes have feasible GO mapping. \nPlease include more genes. ")
    }
  })
  
  # Conditional MLE odds ratio calculation
  cond_or <- function(x) {
    m <- sum(x[, 1L])
    n <- sum(x[, 2L])
    k <- sum(x[1L, ])
    x <- x[1L, 1L]
    lo <- max(0L, k - n)
    hi <- min(k, m)
    
    support <- lo:hi #Interval of definition of Hypergeometric Distribution
    
    logdc <- dhyper(support, m, n, k, log = TRUE) #log of Hypergeometric Probability Function
    
    dnhyper <- function(ncp) {
      d <- logdc + log(ncp) * support
      d <- exp(d - max(d))
      d/sum(d)
    }
    
    mnhyper <- function(ncp) {
      if (ncp == 0) 
        return(lo)
      if (ncp == Inf) 
        return(hi)
      sum(support * dnhyper(ncp))
    }
    
    mle <- function(x) {
      if (x == lo) 
        return(0)
      if (x == hi) 
        return(Inf)
      mu <- mnhyper(1)
      if (mu > x) 
        uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
      else if (mu < x) 
        1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 
                                                  1))$root
      else 1
    }
    
    mle(x)
  }
  
  # Unconditional MLE odds ratio calculation
  uncond_or <- function(x) {
    x[1, 1] * x[2, 2] / (x[1, 2] * x[2, 1])
  }
  
  # Function for finding top Go terms
  gene_GO <- function(target_gene, control_gene, top=20, go_ontology, ...){
    target_gene <- as.character(target_gene)
    control_gene <- as.character(control_gene)
    
    unique_gene <- unique(c(target_gene, control_gene))
    geneList <- rep(0, length(unique_gene))
    names(geneList) <- unique_gene
    geneList[which(target_gene %in% unique_gene)] <- 1
    
    #print(paste0("num target genes: ", length(target_gene), "; num all genes: ", length(unique_gene)))
    
    GOdata <- new("topGOdata",description = "pathway", ontology = go_ontology,
                  allGenes = geneList, geneSelectionFun = function(x) {x == 1},
                  nodeSize = 10, annotationFun = annFUN.org, mapping = 'org.Hs.eg.db', ID = 'symbol')
    
    gene.universe <- genes(GOdata)
    sig.genes <- sigGenes(GOdata)
    if (length(usedGO(GOdata)) == 0) {
      # No feasible GO terms
      return(NULL)
    }
    res <- sapply(usedGO(GOdata), function(goID) {
      go.genes <- genesInTerm(GOdata, goID)[[1]]
      my.group <- new("classicCount", 
                      testStatistic = GOFisherTest, 
                      name = "fisher",
                      allMembers = gene.universe, 
                      groupMembers = go.genes,
                      sigMembers = sig.genes)
      fisher_res <- fisher.test(contTable(my.group), alternative = "greater")
      c(fisher_res$p.value, fisher_res$estimate, uncond_or(contTable(my.group)), uncond_or(contTable(my.group) + 1))
    })
    if (length(usedGO(GOdata)) == 1) {
      res <- data.frame(res)
    } else {
      res <- data.frame(t(res))
    }
    colnames(res) <- c('p.value', 'cond.odds.ratio', 'uncond.odds.ratio', 'pc.uncond.odds.ratio')
    
    pval <- res$p.value
    names(pval) <- row.names(res)
    GOtest <- new("topGOresult", description = 'BP', score = pval, testName = 'fisher', algorithm = 'classic')
    resultTable <- GenTable(GOdata,
                            pvalue = GOtest,
                            topNodes = min(top, length(usedGO(GOdata))),
                            ranksOf = 'pvalue',
                            numChar = 1024)
    
    pval_adj <- p.adjust(pval, method="BH")
    resultTable$FDR <- pval_adj[resultTable$GO.ID]
    
    resultTable$odds_ratio_conditional <- res[resultTable$GO.ID, 'cond.odds.ratio']
    resultTable$odds_ratio_unconditional <- res[resultTable$GO.ID, 'uncond.odds.ratio']
    resultTable$odds_ratio_pseudo <- res[resultTable$GO.ID, 'pc.uncond.odds.ratio']
    
    GO_gene_all <- genesInTerm(GOdata, resultTable[,1])
    GO_gene_sign <- sapply(GO_gene_all, function(x){
      tmp <- x[x %in% target_gene]
      paste(tmp, collapse=",")
    })
    
    resultTable$gene <- GO_gene_sign
    resultTable$pvalue <- as.numeric(resultTable$pvalue)
    return(resultTable)
  }
  
  # Find top GO terms associated with genes near significant differential bins
  pt_diff_top_go_terms <- reactive({
    if ((! is.null(input$run_pt_diff_go)) && (input$run_pt_diff_go > 0)) {
      isolate({
        showModal(modalDialog("Finding top GO terms...", footer = NULL, easyClose = TRUE, size = "s"))
        # sig_genes <- unique(gbin_tss[pt_diff_go_sig_bins(), ]$gene)
        # sig_genes <- sig_genes[! is.na(sig_genes)]
        sig_genes <- pt_diff_go_nearest_genes()
        ctrl_genes <- NULL
        if (input$pt_diff_go_ctrl == "All genes near BIRD default prediction range") {
          ctrl_genes <- unique(gbin_tss$gene)
        } else if (input$pt_diff_go_ctrl == "All genes near selected genomic range") {
          ctrl_genes <- unique(gbin_tss[rownames(pred_mat()), ]$gene)
        }
        ctrl_genes <- ctrl_genes[! is.na(ctrl_genes)]
        top_go_table <- gene_GO(sig_genes, ctrl_genes, 
                                top = input$pt_diff_go_top_n, 
                                go_ontology = input$pt_diff_go_ontology)
        if (is.null(top_go_table)) {
          pt_no_feasible_go_terms(TRUE)
        } else {
          pt_no_feasible_go_terms(FALSE)
        }
        removeModal()
        return(top_go_table)
      })
    }
  })
  
  # Render UI for selecting differential analysis results to display
  output$pt_diff_go_sel_res_ui <- renderUI({
    if (! is.null(pt_diff_top_go_terms())) {
      tagList(
        selectInput(
          'pt_diff_go_sel_res',
          'Select GO result to show: ',
          c('Top GO terms table',
            'GO terms p-value graph',
            'GO terms FDR graph',
            'Volcano plot',
            'GO terms bar plot', 
            'GO terms accessibility along pseudo-time')
        ),
        uiOutput('pt_diff_go_res_ui')
      )
    }
  })
  
  # Render Ui for displaying GO analysis results
  output$pt_diff_go_res_ui <- renderUI({
    if (input$pt_diff_go_sel_res == 'Top GO terms table') {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Top GO terms table")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_table_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_table_info",
          title = "<h4>Top GO terms table</h4>",
          content = do.call(paste0,
                            popover_contents$go_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        br(),
        downloadButton('pt_diff_go_table_download', "Download top GO terms table"),
        DT::dataTableOutput("pt_diff_go_table")
      )
    } else if (input$pt_diff_go_sel_res == 'GO terms p-value graph') {
      tagList(
        sliderInput(
          'pt_diff_go_pval_graph_alpha',
          'Significance level',
          min = 0.0001,
          max = 1,
          value = 0.05
        ),
        # bsTooltip("pt_diff_go_pval_graph_alpha",
        #           title = "Control position of p-value threshold (dashed line)",
        #           placement = "top",
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms p-value graph")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_pval_graph_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_pval_graph_info",
          title = "<h4>GO terms p-value graph</h4>",
          content = do.call(paste0,
                            popover_contents$go_pval_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotlyOutput('pt_diff_go_pval_graph'),
        bsTooltip("pt_diff_go_pval_graph",
                  title = "Graph of -log<sub>10</sub>p-values vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ",
                  placement = "top",
                  options = list(container = "body")),
        hr(),
        h4("GO terms p-value graph selected points"),
        DT::dataTableOutput('pt_diff_go_pval_graph_brushed')
      )
    } else if (input$pt_diff_go_sel_res == 'GO terms FDR graph') {
      tagList(
        sliderInput(
          'pt_diff_go_fdr_graph_alpha',
          'Significance level',
          min = 0.0001,
          max = 1,
          value = 0.05
        ),
        # bsTooltip("pt_diff_go_fdr_graph_alpha",
        #           title = "Control position of FDR threshold (dashed line)",
        #           placement = "top",
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms FDR graph")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_fdr_graph_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_fdr_graph_info",
          title = "<h4>GO terms FDR graph</h4>",
          content = do.call(paste0,
                            popover_contents$go_fdr_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotlyOutput('pt_diff_go_fdr_graph'),
        bsTooltip("pt_diff_go_fdr_graph",
                  title = "Graph of -log<sub>10</sub>FDR vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ",
                  placement = "top",
                  options = list(container = "body")),
        hr(),
        h4("GO terms FDR graph selected points"),
        DT::dataTableOutput('pt_diff_go_fdr_graph_brushed')
      )
    } else if (input$pt_diff_go_sel_res == 'Volcano plot') {
      max_odds_ratio <- max(pt_diff_top_go_terms_df()$odds_ratio_pseudo[is.finite(pt_diff_top_go_terms_df()$odds_ratio_pseudo)])
      tagList(
        tags$div(
          id = "pt_diff_go_volcano_plot_params",
          fluidRow(
            column(6,
                   sliderInput(
                     'pt_diff_go_volcano_plot_alpha',
                     'Significance level',
                     min = 0.0001,
                     max = 1,
                     value = 0.05
                   )),
            column(6,
                   sliderInput(
                     'pt_diff_go_volcano_plot_or_threshold',
                     'Odds ratio threshold',
                     min = 0,
                     max = max_odds_ratio,
                     value = min(1, max_odds_ratio)
                   ))
          )
        ),
        # bsTooltip("pt_diff_go_volcano_plot_params",
        #           title = "Adjust these cut-offs to color significant vs. non-significant GO terms differently in volcano plot. ",
        #           placement = "top",
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms volcano plot")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_volcano_plot_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_volcano_plot_info",
          title = "<h4>GO terms volcano plot</h4>",
          content = do.call(paste0,
                            popover_contents$go_volcano_plot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotlyOutput('pt_diff_go_volcano_plot'),
        bsTooltip("pt_diff_go_volcano_plot",
                  title = "For each GO term, -log<sub>10</sub>p-value is plotted against odds ratio (computed with pseudo-count). ",
                  placement = "top",
                  options = list(container = "body"))
      )
    } else if (input$pt_diff_go_sel_res == 'GO terms bar plot') {
      tagList(
        radioButtons(
          "pt_diff_go_barplot_var",
          "Bar plot value: ",
          choices = c("- log10 p-value" = "p-value",
                      "- log10 FDR" = "FDR")
        ),
        fluidRow(
          column(
            width = 4,
            radioButtons(
              "pt_diff_go_barplot_sort_by",
              label = "Sort bar plot by: ",
              choices = c("Default order" = "default",
                          "Decreasing value" = "decrease",
                          "Increasing value" = "increase",
                          "Custom order" = "custom")
            )
          ),
          column(
            width = 8,
            uiOutput("pt_diff_go_barplot_sort_details_ui")
          )
        ),
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "pt_diff_go_barplot_top_cut", 
              "Number of top GO terms to show: ", 
              min = 2, 
              max = nrow(pt_diff_top_go_terms()), 
              value = min(10, nrow(pt_diff_top_go_terms())), 
              step = 1
            )
          ), 
          column(
            width = 4, 
            sliderInput(
              "pt_diff_go_barplot_bar_width", 
              "Bar width: ", 
              min = 0.1, 
              max = 1.0, 
              value = 0.5,
              step = 0.1
            )
          ),
          column(
            width = 4, 
            uiOutput("pt_diff_go_barplot_xlim_ui")
          )
        ),
        checkboxInput(
          "pt_diff_go_barplot_show_des", 
          "Show GO term descriptions", 
          value = FALSE
        ),
        uiOutput("pt_diff_go_barplot_des_details_ui"),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms bar plot")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "pt_go_barplot_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_barplot_info",
          title = "<h4>GO terms bar plot</h4>",
          content = do.call(paste0,
                            popover_contents$go_barplot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotOutput("pt_diff_go_barplot"), 
        actionButton("pt_diff_go_barplot_download", "Download plot")
      )
    } else if (input$pt_diff_go_sel_res == "GO terms accessibility along pseudo-time") {
      go_list <- pt_diff_top_go_terms()$GO.ID
      names(go_list) <- paste0(pt_diff_top_go_terms()$GO.ID, ' (', pt_diff_top_go_terms()$Term, ')')
      tagList(
        wellPanel(
          fluidRow(
            column(
              6, 
              radioButtons(
                "pt_diff_go_all_chracc_color", 
                "Color trend lines by: ", 
                choices = c("FDR cut-off", 
                            "p-value cut-off", 
                            "FDR", 
                            "p-value")
                # choices = c("GO terms", 
                #             "p-value", 
                #             "FDR", 
                #             "p-value cut-off", 
                #             "FDR cut-off")
              )
            ), 
            column(
              6, 
              uiOutput("pt_diff_go_all_chracc_alpha_ui")
            )
          ),
          h4("GO terms average chromatin accessibility trends"), 
          plotlyOutput("pt_diff_go_all_chracc_plot"), 
          bsTooltip("pt_diff_go_all_chracc_plot",
                    title = "Each line is the trend of average chromatin accessibility along pseudo-time for a GO term. ",
                    placement = "top",
                    options = list(container = "body"))
        ),
        wellPanel(
          fluidRow(
            column(
              4, 
              selectInput(
                "pt_diff_go_chracc_term", 
                "Select a GO term to show", 
                choices = go_list
              )
            ), 
            column(
              4, 
              radioButtons(
                "pt_diff_go_chracc_plot", 
                "Show plot: ", 
                choices = c("Scatter plot with overall trend",
                            "Trend lines")
              )
            ),
            column(
              4, 
              uiOutput("pt_diff_go_chracc_plot_trends_options")
            )
          ), 
          uiOutput("pt_diff_go_chracc_overview_ui")
        )
      )
    }
  })
  
  # Render UI for top terms accessibility along pseudo-time plot alpha slider
  output$pt_diff_go_all_chracc_alpha_ui <- renderUI({
    if (input$pt_diff_go_all_chracc_color %in% c("p-value cut-off", "FDR cut-off")) {
      tooltip_text <- paste("This is the", input$pt_diff_go_all_chracc_color, "for significance. ")
      tagList(
        sliderInput(
          "pt_diff_go_all_chracc_alpha", 
          "Significance level cut-off: ", 
          min = 0, 
          max = 1, 
          value = 0.05
        ), 
        bsTooltip("pt_diff_go_all_chracc_alpha",
                  title = tooltip_text,
                  placement = "top",
                  options = list(container = "body"))
      )
    }
  })
  
  # Render plot of top terms accessibility along pseudo-time
  output$pt_diff_go_all_chracc_plot <- renderPlotly({
    if (input$run_pt_diff_go) {
      fit_vals <- apply(pt_diff_top_go_terms(), 1, function(x) {
        genes <- unlist(strsplit(x["gene"], ","))
        gbin_genes <- pt_diff_go_sig_bins_table()[(pt_diff_go_sig_bins_table()$nearest_gene %in% genes) & 
                                                    (pt_diff_go_sig_bins_table()$distance_to_gene <= input$pt_diff_go_gene_maxdist), , drop=F]
        gbins <- paste0(gbin_genes$chromosome, ' (', gbin_genes$start, '-', gbin_genes$end, ')')
        go_avg_chracc <- colMeans(pca_top_var_pred_mat()[gbins, pred_order()[,1], drop=F])
        data <- data.frame(pseudotime = 1:length(go_avg_chracc), 
                           chracc = go_avg_chracc)
        fitted.values(mgcv::gam(chracc ~ s(pseudotime, k = 3), data = data))
      })
      fit_df <- data.frame(pseudotime = 1:nrow(fit_vals), 
                           as.data.frame(fit_vals))
      colnames(fit_df)[-1] <- pt_diff_top_go_terms()$GO.ID
      fit_long <- melt(fit_df, id = "pseudotime")
      if (input$pt_diff_go_all_chracc_color == "GO terms") {
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = variable, text = variable)) + geom_line()
        g$labels$colour <- "GO term ID"
      } else if (input$pt_diff_go_all_chracc_color == "p-value") {
        go_pval <- pt_diff_top_go_terms()[, c("GO.ID", "pvalue")]
        fit_long <- merge(fit_long, go_pval, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = pvalue, text = paste0(variable, '\np-value: ', pvalue))) + geom_line()
        g <- g + scale_color_gradient(low = "darkred", high = "grey")
        g$labels$colour <- "p-value"
      } else if (input$pt_diff_go_all_chracc_color == "FDR") {
        go_fdr <- pt_diff_top_go_terms()[, c("GO.ID", "FDR")]
        fit_long <- merge(fit_long, go_fdr, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = FDR, text = paste0(variable, '\nFDR: ', FDR))) + geom_line()
        g <- g + scale_color_gradient(low = "darkred", high = "grey")
        g$labels$colour <- "FDR"
      } else if (input$pt_diff_go_all_chracc_color == "p-value cut-off") {
        go_pval <- pt_diff_top_go_terms()[, c("GO.ID", "pvalue")]
        significance <- rep("Non-significant", nrow(go_pval))
        significance[go_pval$pvalue < input$pt_diff_go_all_chracc_alpha] <- "Significant"
        go_pval$significance <- as.factor(significance)
        fit_long <- merge(fit_long, go_pval, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = significance, text = paste0(variable, '\np-value: ', pvalue))) + geom_line()
        g <- g + scale_color_manual(values = c('Significant' = "darkred", 'Non-significant' = "grey"))
        g$labels$colour <- "Significance"
      } else if (input$pt_diff_go_all_chracc_color == "FDR cut-off") {
        go_fdr <- pt_diff_top_go_terms()[, c("GO.ID", "FDR")]
        significance <- rep("Non-significant", nrow(go_fdr))
        significance[go_fdr$FDR < input$pt_diff_go_all_chracc_alpha] <- "Significant"
        go_fdr$significance <- significance
        fit_long <- merge(fit_long, go_fdr, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = significance, text = paste0(variable, '\nFDR: ', FDR))) + geom_line()
        g <- g + scale_color_manual(values = c('Significant' = "darkred", 'Non-significant' = "grey"))
        g$labels$colour <- "Significance"
      } 
      g <- g + ylab("Average predicted log2 chromatin accessibility") + xlab("Pseudotime")
      g <- g + theme(strip.background = element_rect(colour = "white", 
                                                     fill = "white")) + theme(panel.border = element_blank(), 
                                                                              axis.line = element_line()) + theme(panel.grid.minor.x = element_blank(), 
                                                                                                                  panel.grid.minor.y = element_blank()) + theme(panel.grid.major.x = element_blank(), 
                                                                                                                                                                panel.grid.major.y = element_blank()) + theme(panel.background = element_rect(fill = "white"))
      p <- ggplotly(g, tooltip = 'text')
      p
    }
  })
  
  # Render options for overview plot
  output$pt_diff_go_chracc_plot_trends_options <- renderUI({
    if (input$pt_diff_go_chracc_plot == "Trend lines") {
      radioButtons(
        "pt_diff_go_chracc_form", 
        "Show chromatin accessibility for: ", 
        choices = c("Gene average", "Individual bins")
      )
    }
  })
  
  # Render UI for GO term accessibility along pseudo-time overview
  output$pt_diff_go_chracc_overview_ui <- renderUI({
    if (input$pt_diff_go_chracc_plot == "Trend lines") {
      req(input$pt_diff_go_chracc_form)
      header_text <- paste(input$pt_diff_go_chracc_form, 
                           "chromatin accessibility along pseudo-time overview for", 
                           input$pt_diff_go_chracc_term)
      if (input$pt_diff_go_chracc_form == "Gene average") {
        tooltip_text <- "Each line is the fitted trend for the average predicted accessibility along pseudo-time for a significant gene. "
      } else if (input$pt_diff_go_chracc_form == "Individual bins") {
        tooltip_text <- "Each line is the fitted trend for the predicted accessibility along pseudo-time for a bin near significant genes. "
      }
    } else {
      header_text <- "GO term average accessibility along pseudo-time scatter plot"
      tooltip_text <- "Each point is the average predicted accessibility across all genomic bins near significant genes. "
    }
    tagList(
      h4(header_text),
      plotlyOutput("pt_diff_go_chracc_overview_plot"),
      bsTooltip("pt_diff_go_chracc_overview_plot",
                title = tooltip_text,
                placement = "top",
                options = list(container = "body"))
    )
  })
  
  # Table of significant bins and genes for selected GO term
  pt_diff_go_chracc_sel_genes_table <- reactive({
    genes <- pt_diff_top_go_terms()$gene[pt_diff_top_go_terms()$GO.ID == input$pt_diff_go_chracc_term]
    genes <- unlist(strsplit(genes, ','))
    pt_diff_go_sig_bins_table()[(pt_diff_go_sig_bins_table()$nearest_gene %in% genes) &
                                  (pt_diff_go_sig_bins_table()$distance_to_gene <= input$pt_diff_go_gene_maxdist), , drop=F]
  })
  
  # Render overview plot for GO term accessibility along pseudotime
  output$pt_diff_go_chracc_overview_plot <- renderPlotly({
    go_sig_bins <- paste0(pt_diff_go_chracc_sel_genes_table()$chromosome, 
                          ' (', 
                          pt_diff_go_chracc_sel_genes_table()$start, 
                          '-',
                          pt_diff_go_chracc_sel_genes_table()$end, 
                          ')')
    go_sig_pred_mat <- pca_top_var_pred_mat()[go_sig_bins,]
    if (input$pt_diff_go_chracc_plot == "Trend lines") {
      if (input$pt_diff_go_chracc_form == "Gene average") {
        # gbin_names <- rownames(pca_top_var_pred_mat())
        # topvar_gbin_tss <- gbin_tss[rownames(pca_top_var_pred_mat()), ]
        # topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
        # topvar_gbin_tss <- topvar_gbin_tss[! is.na(rownames(topvar_gbin_tss)), ]
        # gene_avg <- aggregate(pca_top_var_pred_mat()[rownames(topvar_gbin_tss), ], 
        #                       by=list(gene=topvar_gbin_tss$gene), 
        #                       mean)
        chracc <- aggregate(go_sig_pred_mat, 
                            by=list(gene=pt_diff_go_chracc_sel_genes_table()$nearest_gene), 
                            mean)
        rownames(chracc) <- chracc$gene
        chracc <- chracc[, pred_order()[, 1]]
      } else if (input$pt_diff_go_chracc_form == "Individual bins") {
        chracc <- go_sig_pred_mat[, pred_order()[, 1]]
      }
      pseudotime <- 1:ncol(chracc)
      fit_vals <- apply(chracc, 1, function(x) {
        data <- data.frame(pseudotime = pseudotime, 
                           chracc = x)
        fitted.values(mgcv::gam(chracc ~ s(pseudotime, k = 3), data = data))
      })
      fit_df <- data.frame(pseudotime = pseudotime, 
                           as.data.frame(fit_vals))
      if (input$pt_diff_go_chracc_form == "Individual bins") {
        colnames(fit_df)[-1] <- go_sig_bins
      }
      fit_long <- melt(fit_df, id = "pseudotime")
      g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = variable, text = variable)) + geom_line()
      if (input$pt_diff_go_chracc_form == "Gene average") {
        g$labels$colour <- "Gene"
      } else {
        g$labels$colour <- "Genomic bin"
      }
      g <- g + ylab("Predicted log2 chromatin accessibility") + xlab("Pseudotime")
      g <- g + theme(strip.background = element_rect(colour = "white", 
                                                     fill = "white")) + theme(panel.border = element_blank(), 
                                                                              axis.line = element_line()) + theme(panel.grid.minor.x = element_blank(), 
                                                                                                                  panel.grid.minor.y = element_blank()) + theme(panel.grid.major.x = element_blank(), 
                                                                                                                                                                panel.grid.major.y = element_blank()) + theme(panel.background = element_rect(fill = "white"))
      p <- ggplotly(g, tooltip = 'text')
      return(p)
    } else {
      ggplotly(chracc_along_pt_plot(colMeans(go_sig_pred_mat), pred_order()))
    }
  })
  
  # Render UI for bar plot xlim
  output$pt_diff_go_barplot_xlim_ui <- renderUI({
    req(input$pt_diff_go_barplot_var)
    req(input$pt_diff_go_barplot_sort_by)
    req(input$pt_diff_go_barplot_top_cut)
    # Set bar values
    if (input$pt_diff_go_barplot_var == "p-value") {
      df <- data.frame(go_term = pt_diff_top_go_terms()$GO.ID, 
                       value = - log10(pt_diff_top_go_terms()$pvalue))
    } else if (input$pt_diff_go_barplot_var == "FDR") {
      df <- data.frame(go_term = pt_diff_top_go_terms()$GO.ID, 
                       value = - log10(pt_diff_top_go_terms()$FDR))
    }
    # Sort barplot
    if (input$pt_diff_go_barplot_sort_by == "decrease") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value)])
    } else if (input$pt_diff_go_barplot_sort_by == "increase") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value, decreasing = TRUE)])
    } else if (input$pt_diff_go_barplot_sort_by == "custom") {
      df$go_term <- factor(df$go_term, levels = rev(pt_diff_go_barplot_custom_order()))
    }
    # Top n bars cut-off
    df <- df[order(df$go_term)[1:input$pt_diff_go_barplot_top_cut], ]
    sliderInput(
      "pt_diff_go_barplot_xlim", 
      "Minimum x value: ", 
      min = 0, 
      max = min(df$value), 
      value = min(df$value) - (max(df$value) - min(df$value)) / 3
    )
  })
  
  # Render UI for bar plot show description details
  output$pt_diff_go_barplot_des_details_ui <- renderUI({
    if (input$pt_diff_go_barplot_show_des) {
      wellPanel(
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "pt_diff_go_barplot_show_des_size", 
              "GO term description font size", 
              min = 1, 
              max = 10, 
              value = 4
            )
          ),
          column(
            width = 4, 
            radioButtons(
              "pt_diff_go_barplot_show_des_opt", 
              "GO description display options", 
              choices = c("Show full description", 
                          "Show truncated description", 
                          "Split description into multiple lines")
            )
          ), 
          column(
            width = 4, 
            uiOutput("pt_diff_go_barplot_show_des_opt_format")
          )
        )
      )
    }
  })
  
  # Render UI for bar plot GO description formatting options
  output$pt_diff_go_barplot_show_des_opt_format <- renderUI({
    if (input$pt_diff_go_barplot_show_des_opt == "Show truncated description") {
      tagList(
        radioButtons(
          "pt_diff_go_barplot_des_trim_mode", 
          "Truncation mode: ", 
          choices = c("Fixed length", "Proportional to bar length"), 
          selected = "Fixed length"
        ), 
        sliderInput(
          "pt_diff_go_barplot_des_trim_len", 
          "Truncation length: ", 
          min = 0, max = 1, value = 0.8, step = 0.01
        )
      )
    } else if (input$pt_diff_go_barplot_show_des_opt == "Split description into multiple lines") {
      tagList(
        radioButtons(
          "pt_diff_go_barplot_des_split_mode", 
          "Split mode: ", 
          choices = c("Fixed line length", "Line length proportional to bar length"),
          selected = "Fixed line length"
        ), 
        sliderInput(
          "pt_diff_go_barplot_des_split_len", 
          "Line length: ", 
          min = 0, max = 1, value = 0.5, step = 0.01
        )
      )
    }
  })
  
  # Render UI for bar plot sort details
  output$pt_diff_go_barplot_sort_details_ui <- renderUI({
    if (input$pt_diff_go_barplot_sort_by == "custom") {
      fluidRow(
        column(
          width = 6,
          radioButtons(
            "pt_diff_go_barplot_custom_sort_method",
            "Input custom order by: ",
            choices = c("Text input",
                        "Drag to sort")
          )
        ),
        column(
          width = 6,
          uiOutput("pt_diff_go_barplot_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for GO bar plot custom sorting options
  output$pt_diff_go_barplot_custom_sort_ui <- renderUI({
    if (input$pt_diff_go_barplot_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "pt_diff_go_barplot_custom_sort_text",
          "Input GO IDs separated by line breaks: "
        ),
        fileInput(
          "pt_diff_go_barplot_custom_sort_txt_file",
          "Upload txt file indicating sort order",
          accept = "text/plain"
        ),
        actionButton("pt_submit_diff_go_barplot_custom_sort", "Confirm order"),
        textOutput("pt_diff_go_barplot_custom_sort_submission_text")
      )
    } else if (input$pt_diff_go_barplot_custom_sort_method == "Drag to sort") {
      actionButton("pt_diff_go_barplot_custom_sort_drag_button", "Sort samples")
    }
  })
  
  # Update GO bar plot custom sort text area input value based on uploaded file
  observeEvent(input$pt_diff_go_barplot_custom_sort_txt_file, {
    if (! is.null(input$pt_diff_go_barplot_custom_sort_txt_file)) {
      go_sort_text <- paste(readLines(input$pt_diff_go_barplot_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session,
        "pt_diff_go_barplot_custom_sort_text",
        value = go_sort_text
      )
    }
  })
  
  # Disease bar plot custom order value
  pt_diff_go_barplot_custom_order <- reactiveVal()
  
  # Update default custom order when GO results are computed
  observeEvent(pt_diff_top_go_terms(), {
    pt_diff_go_barplot_custom_order(pt_diff_top_go_terms()$GO.ID)
  })
  
  # Render pop-up modal for GO bar plot custom drag sort
  observeEvent(input$pt_diff_go_barplot_custom_sort_drag_button, {
    if (is.null(pt_diff_go_barplot_custom_order())) {
      go_order <- pt_diff_top_go_terms()$GO.ID
    } else {
      go_order <- pt_diff_go_barplot_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = go_order,
      input_id = "go_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("pt_submit_diff_go_barplot_custom_sort", "Confirm order"),
        textOutput("pt_diff_go_barplot_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for GO bar plot custom sort
  output$pt_diff_go_barplot_custom_sort_submission_text <- renderText({
    pt_diff_go_barplot_custom_sort_submission_text()
  })
  
  # Process GO bar plot custom sort request
  pt_diff_go_barplot_custom_sort_submission_text <- eventReactive(input$pt_submit_diff_go_barplot_custom_sort, {
    if (input$pt_diff_go_barplot_custom_sort_method == "Text input") {
      # Read GO terms from submitted text
      go_terms <- unlist(strsplit(input$pt_diff_go_barplot_custom_sort_text, split = "\n"))
      go_terms <- sapply(go_terms, function(go) {
        go <- gsub(" ", "", go)
        go <- gsub("\t", "", go)
        go
      })
      go <- go[go != ""]
      # Check for non-selected GO terms
      extra <- go_terms[! (go_terms %in% pt_diff_top_go_terms()$GO.ID)]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected GO terms:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated GO terms
      counts <- sapply(pt_diff_top_go_terms()$GO.ID, function(go) {
        sum(go_terms %in% go)
      })
      if (any(counts > 1)) {
        return(paste("The following GO terms are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing GO terms
      if (any(counts == 0)) {
        return(paste("The following GO terms are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      pt_diff_go_barplot_custom_order(go_terms)
      return(paste("Sorting complete!"))
    } else if (input$pt_diff_go_barplot_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      pt_diff_go_barplot_custom_order(input$go_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  pt_diff_go_barplot <- reactive({
    req(input$pt_diff_go_barplot_xlim)
    # Set bar values
    if (input$pt_diff_go_barplot_var == "p-value") {
      df <- data.frame(go_term = pt_diff_top_go_terms()$GO.ID, 
                       go_des =  pt_diff_top_go_terms()$Term, 
                       value = - log10(pt_diff_top_go_terms()$pvalue))
    } else if (input$pt_diff_go_barplot_var == "FDR") {
      df <- data.frame(go_term = pt_diff_top_go_terms()$GO.ID, 
                       go_des =  pt_diff_top_go_terms()$Term, 
                       value = - log10(pt_diff_top_go_terms()$FDR))
    }
    # Sort barplot
    if (input$pt_diff_go_barplot_sort_by == "decrease") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value)])
    } else if (input$pt_diff_go_barplot_sort_by == "increase") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value, decreasing = TRUE)])
    } else if (input$pt_diff_go_barplot_sort_by == "custom") {
      df$go_term <- factor(df$go_term, levels = rev(pt_diff_go_barplot_custom_order()))
    }
    # Top n bars cut-off
    df <- df[order(df$go_term)[1:input$pt_diff_go_barplot_top_cut], ]
    if (input$pt_diff_go_barplot_show_des) {
      req(input$pt_diff_go_barplot_show_des_opt)
      # Show GO descriptions
      # Get description lengths
      des_width <- sapply(df$go_des, function(des){
        strwidth(des, units = "inches", family = "sans")
      })
      if (input$pt_diff_go_barplot_show_des_opt == "Show truncated description") {
        req(input$pt_diff_go_barplot_des_trim_mode)
        req(input$pt_diff_go_barplot_des_trim_len)
        abbrev_len <- strwidth("...", units = "inches", family = "sans")
        if (input$pt_diff_go_barplot_des_trim_mode == "Fixed length") {
          trim_len <- rep(abbrev_len + input$pt_diff_go_barplot_des_trim_len * (max(des_width) - abbrev_len), length(des_width))
          names(trim_len) <- df$go_des
        } else {
          bar_len <- df$value - input$pt_diff_go_barplot_xlim
          max_len <- abbrev_len + input$pt_diff_go_barplot_des_trim_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - abbrev_len)
          trim_len <- max_len * bar_len / (max(df$value) - input$pt_diff_go_barplot_xlim)
          names(trim_len) <- df$go_des
        }
        # Trim terms
        trim_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= trim_len[term]) {
            return(term)
          } else {
            # Find approximate nchar to trim
            keep_nchar <- floor(nchar(term) * (trim_len[term] - abbrev_len) / des_width[term])
            while (strwidth(substring(term, 1, keep_nchar), units = "inches", family = "sans") > trim_len[term] - abbrev_len) {
              keep_nchar <- keep_nchar - 1
            }
            return(paste0(substring(term, 1, keep_nchar), "..."))
          }
        })
        df$go_des <- trim_terms
      } else if (input$pt_diff_go_barplot_show_des_opt == "Split description into multiple lines") {
        req(input$pt_diff_go_barplot_des_split_mode)
        req(input$pt_diff_go_barplot_des_split_len)
        if (input$pt_diff_go_barplot_des_split_mode == "Fixed line length") {
          min_len <- max(des_width) / 2
          line_len <- rep(min_len + input$pt_diff_go_barplot_des_split_len * (max(des_width) - min_len), length(des_width))
          names(line_len) <- df$go_des
        } else {
          bar_len <- df$value - input$pt_diff_go_barplot_xlim
          min_len <- max(des_width) / 2
          max_len <- min_len + input$pt_diff_go_barplot_des_split_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - min_len)
          line_len <- sapply(df$go_des, function(term) {
            ratio <- bar_len[df$go_des == term] / (max(df$value) - input$pt_diff_go_barplot_xlim)
            if ((max(df$value) - input$pt_diff_go_barplot_xlim) == 0) {
              ratio <- 1
            }
            max_len * ratio
          })
          names(line_len) <- df$go_des
        }
        # Format terms
        format_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= line_len[term]) {
            return(term)
          } else {
            # Find approximate nchar in a single line
            remain_term <- term
            split_lines <- c()
            line_nchar <- floor(nchar(term) * line_len[term] / des_width[term])
            while (strwidth(remain_term, units = "inches", family = "sans") > line_len[term] &&
                   ! -1 %in% unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))) {
              breaks <- unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))
              breaks <- breaks[!(breaks + 1) %in% breaks]
              break_i <- if (length(breaks) && min(breaks) <= line_nchar) {
                which.max(breaks[breaks <= line_nchar])
              } else {1}
              while (strwidth(trimws(substring(remain_term, 1, breaks[break_i])), 
                              units = "inches", family = "sans") > line_len[term] &&
                     break_i > 1) {
                break_i <- break_i - 1
              }
              split_lines <- c(split_lines, trimws(substring(remain_term, 1, breaks[break_i])))
              remain_term <- trimws(substring(remain_term, breaks[break_i] + 1, ))
            }
            split_lines <- c(split_lines, remain_term)
            return(paste(split_lines, collapse = "\n"))
          }
        })
        df$go_des <- format_terms
      }
    }
    g <- ggplot(df, aes(x = go_term, y = value, fill = value))
    g <- g + xlab("GO terms")
    if (input$pt_diff_go_barplot_var == "p-value") {
      g <- g + ylab('- log10 p-value')
      g <- g + labs(fill = '- log10 p-value')
    } else if (input$pt_diff_go_barplot_var == "FDR") {
      g <- g + ylab('- log10 FDR')
      g <- g + labs(fill = '- log10 FDR')
    }
    g <- g + geom_bar(stat = 'identity', width = input$pt_diff_go_barplot_bar_width) + theme_bw()
    g <- g + coord_flip(ylim = c(input$pt_diff_go_barplot_xlim, max(df$value)))
    if (input$pt_diff_go_barplot_show_des) {
      g <- g + geom_text(aes(x = go_term, y = input$pt_diff_go_barplot_xlim,
                             label = go_des, hjust = "left"),
                         color = "white", lineheight = 0.7,
                         size = input$pt_diff_go_barplot_show_des_size)
    }
    return(g)
  })
  
  # Render GO bar plot
  output$pt_diff_go_barplot <- renderPlot({
    pt_diff_go_barplot()
  })
  
  observeEvent(input$pt_diff_go_barplot, {
    download_plot(pt_diff_go_barplot())
  })
  
  # Data frame of top GO terms with go column containing integer GO ids
  pt_diff_top_go_terms_df <- reactive({
    if (! is.null(pt_diff_top_go_terms())) {
      go_df <- as.data.frame.matrix(pt_diff_top_go_terms())
      go_df$go <- as.integer(gsub("GO:", "", go_df$GO.ID))
      go_df
    }
  })
  
  # Render plot for GO terms p values
  output$pt_diff_go_pval_graph <- renderPlotly({
    if (! is.null(pt_diff_top_go_terms())) {
      df <- data.frame(go = pt_diff_top_go_terms_df()$go,
                       GO.ID = pt_diff_top_go_terms_df()$GO.ID,
                       logpvalue = - log10(as.numeric(pt_diff_top_go_terms_df()$pvalue)),
                       pvalue = pt_diff_top_go_terms_df()$pvalue,
                       annotated = pt_diff_top_go_terms_df()$Annotated,
                       term = pt_diff_top_go_terms_df()$Term,
                       fdr = pt_diff_top_go_terms_df()$FDR,
                       odds_ratio = pt_diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df,
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go,
                     y = ~logpvalue,
                     color = ~logpvalue,
                     size = ~annotated,
                     text = ~paste("GO id: ", GO.ID,
                                   '<br>Annotated: ', annotated,
                                   '<br>GO term: ', term,
                                   '<br>FDR: ', fdr,
                                   '<br>Odds ratio: ', odds_ratio,
                                   '<br>p-value: ', pvalue),
                     hoverinfo = 'text',
                     source = "pt_go_pval_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$pt_diff_go_ontology)),
                                         showticklabels = FALSE,
                                         zeroline = FALSE),
                            yaxis = list(title = '-log<sub>10</sub>pvalue'),
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$pt_diff_go_pval_graph_alpha),
                                y1 = - log10(input$pt_diff_go_pval_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Make GO terms p-value plotly graph brushed points table
  observeEvent({
    event_data(event = "plotly_selected",
               source = "pt_go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  },{
    go_selected <- event_data(event = "plotly_selected",
                              source = "pt_go_pval_graph",
                              session = shiny::getDefaultReactiveDomain())
    df <- pt_diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
    output$pt_diff_go_pval_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                                rownames = FALSE,
                                                                filter = list(position = 'top', clear = FALSE),
                                                                selection = "none")
  })
  
  # Show detailed info modal on GO terms p-value graph click event
  observeEvent({
    event_data(event = "plotly_click",
               source = "pt_go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  }, {
    go_clicked <- event_data(event = "plotly_click",
                             source = "pt_go_pval_graph",
                             session = shiny::getDefaultReactiveDomain())
    go_info <- pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(pt_diff_top_go_terms_df()) != 'go']
    go_info$gene <- gsub(",", "<br/>", go_info$gene)
    go_info <- t(go_info)
    rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
    rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
    output$pt_diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info,
                                                                                  colnames = "",
                                                                                  selection = "none",
                                                                                  escape = FALSE))
    showModal(modalDialog(
      tagList(
        downloadButton("pt_go_genes_download", "Download significant genes"),
        DT::dataTableOutput("pt_diff_go_graph_pt_details_table")
      ),
      easyClose = TRUE
    ))
  })
  
  # Render plot for GO terms FDR
  output$pt_diff_go_fdr_graph <- renderPlotly({
    if (! is.null(pt_diff_top_go_terms())) {
      df <- data.frame(go = pt_diff_top_go_terms_df()$go,
                       GO.ID = pt_diff_top_go_terms_df()$GO.ID,
                       logfdr = - log10(as.numeric(pt_diff_top_go_terms_df()$FDR)),
                       pvalue = pt_diff_top_go_terms_df()$pvalue,
                       annotated = pt_diff_top_go_terms_df()$Annotated,
                       term = pt_diff_top_go_terms_df()$Term,
                       fdr = pt_diff_top_go_terms_df()$FDR,
                       odds_ratio = pt_diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df,
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go,
                     y = ~logfdr,
                     color = ~logfdr,
                     size = ~annotated,
                     text = ~paste("GO id: ", GO.ID,
                                   '<br>Annotated: ', annotated,
                                   '<br>GO term: ', term,
                                   '<br>FDR: ', fdr,
                                   '<br>Odds ratio: ', odds_ratio,
                                   '<br>p-value: ', pvalue),
                     hoverinfo = 'text',
                     source = "pt_go_fdr_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$pt_diff_go_ontology)),
                                         showticklabels = FALSE,
                                         zeroline = FALSE),
                            yaxis = list(title = '-log<sub>10</sub>FDR'),
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$pt_diff_go_fdr_graph_alpha),
                                y1 = - log10(input$pt_diff_go_fdr_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Make GO terms FDR plotly graph brushed points table
  observeEvent(
    suppressWarnings(event_data(event = "plotly_selected",
                                source = "pt_go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())),
    {
      go_selected <- event_data(event = "plotly_selected",
                                source = "pt_go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())
      df <- pt_diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
      output$pt_diff_go_fdr_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                                 rownames = FALSE,
                                                                 filter = list(position = 'top', clear = FALSE),
                                                                 selection = "none")
    })
  
  # Show detailed info modal on GO terms FDR graph click event
  observeEvent(
    suppressWarnings(event_data(event = "plotly_click",
                                source = "pt_go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())),
    {
      go_clicked <- event_data(event = "plotly_click",
                               source = "pt_go_fdr_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(pt_diff_top_go_terms_df()) != 'go']
      go_info$gene <- gsub(",", "<br/>", go_info$gene)
      go_info <- t(go_info)
      rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
      rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
      output$pt_diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info,
                                                                                    colnames = "",
                                                                                    selection = "none",
                                                                                    escape = FALSE))
      showModal(modalDialog(
        tagList(
          downloadButton("pt_go_genes_download", "Download significant genes"),
          DT::dataTableOutput("pt_diff_go_graph_pt_details_table")
        ),
        easyClose = TRUE
      ))
    }
  )
  
  # Render GO terms volcano plot
  output$pt_diff_go_volcano_plot <- renderPlotly({
    if (! is.null(pt_diff_top_go_terms())) {
      df <- data.frame(GO.ID = pt_diff_top_go_terms_df()$GO.ID,
                       logpvalue = - log10(as.numeric(pt_diff_top_go_terms_df()$pvalue)),
                       pvalue = pt_diff_top_go_terms_df()$pvalue,
                       annotated = pt_diff_top_go_terms_df()$Annotated,
                       term = pt_diff_top_go_terms_df()$Term,
                       fdr = pt_diff_top_go_terms_df()$FDR,
                       odds_ratio = pt_diff_top_go_terms_df()$odds_ratio_pseudo)
      # Only keep finite odds ratio rows
      df <- df[is.finite(df$odds_ratio), ]
      # Indicate significance in df
      df$significance <- rep("non-significant", nrow(df))
      df$significance[(df$pvalue < input$pt_diff_go_volcano_plot_alpha) & (df$odds_ratio > input$pt_diff_go_volcano_plot_or_threshold)] <- "significant"
      # Set colors
      pal <- c("grey", "blue")
      pal <- setNames(pal, c("non-significant", "significant"))
      fig <- plot_ly(type = 'scatter',
                     mode = 'markers',
                     source = "pt_go_volcano_plot",
                     data = df,
                     x = ~odds_ratio,
                     y = ~logpvalue,
                     color = ~significance,
                     colors = pal,
                     text = ~paste("GO id: ", GO.ID,
                                   '<br>Annotated: ', annotated,
                                   '<br>GO term: ', term,
                                   '<br>FDR: ', fdr,
                                   '<br>Odds ratio: ', odds_ratio,
                                   '<br>p-value: ', pvalue),
                     hoverinfo = 'text')
      fig <- fig %>% layout(xaxis = list(title = 'Odds ratio'),
                            yaxis = list(title = '-log<sub>10</sub>pvalue'))
      fig
    }
  })
  
  # Download GO term significant genes in modal pop-up
  output$pt_go_genes_download <- downloadHandler(
    filename = {
      go_clicked <- event_data(event = "plotly_click",
                               source = "pt_go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      paste0(pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, 'GO.ID'], "_significant_genes.txt")
    },
    content = function(file) {
      go_clicked <- event_data(event = "plotly_click",
                               source = "pt_go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(pt_diff_top_go_terms_df()) != 'go']
      write.table(unlist(strsplit(go_info$gene, ",")),
                  file,
                  row.names = FALSE,
                  col.names = FALSE,
                  quote = FALSE)
    }
  )
  
  # Differential test top GO terms download
  output$pt_diff_go_table_download <- downloadHandler(
    filename = "Top_GO_terms.txt",
    content = function(file) {
      write.table(pt_diff_top_go_terms(),
                  file,
                  row.names = FALSE,
                  quote = FALSE,
                  sep = "\t")
    }
  )
  
  # Render significant differential bins nearest genes associated top GO terms table
  output$pt_diff_go_table <- DT::renderDataTable({
    if (! is.null(pt_diff_top_go_terms())) {
      pt_diff_top_go_terms() %>%
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE),
                  selection = "none",
                  options = list(scrollX = TRUE)) %>%
        formatRound(columns=c('pvalue', 'FDR', "odds_ratio_conditional",
                              "odds_ratio_unconditional", "odds_ratio_pseudo"),
                    digits=4)
    }
  })
  
  output$heatmap_page_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to display a heatmap. ")
    } else if (n_bins_selected() < 2) {
      p("You must select at least 2 genomic bins to display a heatmap. ")
    } else {
      tagList(
        sliderInput(
          "heatmap_top_var", 
          label = tags$span("Number of top variance rows to include in heat map", 
                            bsButton("heatmap_top_var_info", 
                                     label = "", 
                                     icon = icon("info"),
                                     style = "info", 
                                     size = "extra-small")), 
          min = 1000, 
          max = 10000, 
          value = 2000, 
          step = 100
        ),
        bsPopover(
          id = "heatmap_top_var_info",
          title = "<h4>Heat map top variance genomic bins</h4>",
          content = do.call(paste0, 
                            popover_contents$heatmap_top_var_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fluidRow(
          column(
            6, 
            radioButtons(
              "heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            )
          ), 
          column(
            6, 
            checkboxInput(
              "heatmap_show_nearest_genes", 
              label = "Show nearest genes",
              value = FALSE
            ),
            checkboxInput(
              "heatmap_scale", 
              "Scale heatmap rows", 
              value = TRUE
            ),
          )
        ),
        actionButton("show_interactive_heatmap", "Show interactive heat map"),
        h4("Heat map"),
        plotOutput("heat_map"), 
        bsTooltip("heat_map", 
                  title = "The heat map columns are selected samples ordered by column clusters. Each heat map row is a genomic bin. Each heat map cell value is the predicted log<sub>2</sub> chromatin accessibility value at a genomic bin in a selected sample", 
                  placement = "top"),
        actionButton("heat_map_download", "Download plot")
      )
    }
  })
  
  # Create Heatmap object
  heat_map <- reactive({
    n_top_var <- min(input$heatmap_top_var, nrow(pred_hypervar()))
    top_var_idx <- base::sort(pred_hypervar()$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    
    # Filter prediction matrix by top variance rows
    pred_mat_sorted <- pred_mat()[pred_hypervar()$feature[top_var_idx], ] # This is sorted by decreasing variance
    pred_mat_sorted_gbins <- rownames(pred_mat_sorted)
    
    # Make heat map
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$heatmap_sort_by == "Decreasing variance") {
      row.order <- order(1:nrow(pred_mat_sorted))
      cluster.rows <- FALSE
    } else if (input$heatmap_sort_by == "Genomic position") {
      sorted_gbins <- pred_hypervar()$feature[base::sort(top_var_idx)] # Genomic bins sorted by genomic position
      row.order <- sapply(pred_mat_sorted_gbins, function(x) {
        which(sorted_gbins == x)
      })
      row.order <- order(row.order)
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    if (input$heatmap_show_nearest_genes) {
      nearest_genes <- gbin_tss[rownames(pred_mat_sorted), ]$gene
      nearest_genes[is.na(nearest_genes)] <- "None"
      rownames(pred_mat_sorted) <- nearest_genes
    }
    if (input$heatmap_scale) {
      pred_mat_sorted <- t(scale(t(pred_mat_sorted)))
      pred_mat_sorted[is.na(pred_mat_sorted)] <- 0
    }
    ht <- Heatmap(pred_mat_sorted, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "predicted \nchromatin \naccessibility"))
    if (input$heatmap_show_nearest_genes) {
      ht <- ht + rowAnnotation(gbins = anno_text(pred_mat_sorted_gbins), 
                               nearest_genes = anno_text(nearest_genes))
    }
    removeModal()
    return(draw(ht))
  })
  
  # Render heat map
  output$heat_map <- renderPlot({
    heat_map()
  })
  
  observeEvent(input$heat_map_download, {
    download_plot(heat_map())
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, heat_map())
  })
  
  # Render differential analysis page ui
  output$diff_page_ui <- renderUI({
    if (nrow(selected_samples()) < 3) {
      p("You must select at least 3 samples to perform differential analysis. ")
    } else if (n_bins_selected() < 2) {
      p("You must select at least 2 genomic bins to perform differential analysis. ")
    } else {
      tabsetPanel(
        # Tab panel for clustering/grouping samples
        tabPanel(
          title = "Group samples", 
          tags$div(
            style = "margin-bottom:50px; margin-top:50px", 
            sidebarLayout(
              sidebarPanel(
                h4("Sample grouping methods and parameters"),
                radioButtons(
                  "samples_grouping_method", 
                  "Group samples by: ", 
                  c("manual selection", "k-means clustering"), 
                  selected = character(0)
                ), 
                bsTooltip("samples_grouping_method", 
                          title = "Manual selection methods include text input, drag-and-drop, and lasso selection from samples plot. ", 
                          placement = "right", 
                          options = list(container = "body")), 
                uiOutput("diff_sample_grouping_options_ui")
              ), 
              mainPanel(
                uiOutput("diff_sample_grouping_ui")
              )
            )
          )
        ), 
        # Tab panel for differential analysis
        tabPanel(
          title = "Differential testing", 
          tags$div(
            style = "margin-bottom:50px; margin-top:50px", 
            uiOutput('diff_test_analysis_panel_ui')
          )
        )
      )
    }
  })
  
  # UI for grouping option parameters that show up on sidebar
  output$diff_sample_grouping_options_ui <- renderUI({
    req(input$samples_grouping_method)
    if (input$samples_grouping_method == "k-means clustering") {
      tagList(
        # PCA
        sliderInput(
          "diff_pca_top_var", 
          label = "Number of top variance rows to use in PCA computation", 
          min = 1000, 
          max = 10000, 
          value = 2000, 
          step = 100
        ),
        bsTooltip("diff_pca_top_var", 
                  title = "Only this number of hyper-variable bins will be selected to use in PCA", 
                  placement = "right", 
                  options = list(container = "body")), 
        wellPanel(
          fluidRow(
            style = 'margin-left: 2%; margin-right: 2%;',
            tags$div(
              style = "width: 70%; display: inline-block; vertical-align: middle;", 
              selectInput(
                "diff_pca_show_graph", 
                label = "Show PCA results: ", 
                choices = c("PCA Plot", "Explained Variance", "Cumulative Explained Variance")
              )
            ),
            tags$div(
              style = "display: inline-block; vertical-align: middle;", 
              actionButton("diff_pca_show_graph_submit", "View graph")
            )
          )
        ),
        sliderInput(
          "diff_n_pc", 
          label = "Number of PCs to use for sample clustering: ", 
          min = 1, 
          max = min(30, ncol(isolate(diff_pca_res()))), 
          value = isolate(diff_opt_n_pc()), 
          step = 1
        ),
        checkboxInput(
          "diff_use_opt_n_pc", 
          label = "Use optimal number of PCs", 
          value = TRUE
        ),
        htmlOutput('diff_opt_n_pc_msg'),
        bsTooltip("diff_opt_n_pc_msg", 
                  title = "The optimal number of PCs is calculated by elbow method on cumulative explained variance. ", 
                  placement = "left", 
                  options = list(container = "body"))
      )
    } else if (input$samples_grouping_method == "manual selection") {
      tagList(
        selectInput(
          "diff_manual_grouping_method", 
          "Select groups by: ", 
          c("Text input", "Drag and drop", "Select from plot")
        ), 
        uiOutput("diff_manual_grouping_options_ui")
      )
    }
  })
  
  # UI for grouping details for specific grouping option
  output$diff_sample_grouping_ui <- renderUI({
    req(input$samples_grouping_method)
    req
    if (input$samples_grouping_method == "k-means clustering") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Samples k-means clustering")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_kmeans_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_kmeans_info",
          title = "<h3>Use k-means clustering to group samples</h3>",
          content = do.call(paste0, 
                            popover_contents$diff_group_kmeans_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        # Define number of sample clusters
        wellPanel(
          fluidRow(
            column(6, uiOutput("diff_n_sample_clust_ui")), 
            column(6, checkboxInput(
              "diff_use_opt_n_sample_clust", 
              label = "Use optimal number of sample clusters", 
              value = TRUE
            ))
          ),
          htmlOutput('diff_opt_n_sample_clust_msg'), 
          bsTooltip("diff_opt_n_sample_clust_msg", 
                    title = "The optimal number of clusters is calculated by elbow method. ", 
                    placement = "left", 
                    options = list(container = "body"))
        ),
        checkboxInput(
          "diff_show_sample_clust_wss_plot", 
          label = "Show Total Within Cluster Sum of Squares Plot", 
          value = FALSE
        ),
        uiOutput("diff_sample_clust_wss_plot_ui"),
        checkboxInput(
          "diff_show_sample_clust_res", 
          label = "Show samples k-means clustering result", 
          value = TRUE
        ), 
        uiOutput("diff_sample_clust_res_ui"),
        actionButton(
          "submit_diff_groups_kmeans", 
          label = "Confirm groups"
        ),
        textOutput("diff_groups_kmeans_submission_text")
      )
    } else if (input$samples_grouping_method == "manual selection") {
      uiOutput("diff_manual_grouping_ui")
    }
  })
  
  # UI panel for differential analysis k-means grouping number of clusters slider
  output$diff_n_sample_clust_ui <- renderUI({
    sliderInput(
      "diff_n_sample_clust", 
      label = "Number of sample clusters: ", 
      min = 2, 
      max = min(diff_max_n_sample_clust, ncol(pred_mat()) - 1), 
      value = 2, 
      step = 1
    )
  })
  
  # UI panel for manual group selection parameters
  output$diff_manual_grouping_options_ui <- renderUI({
    if (input$diff_manual_grouping_method == "Select from plot") {
      tagList(
        sliderInput(
          "diff_pca_top_var", 
          label = "Number of top variance rows to use in PCA computation", 
          min = 1000, 
          max = 10000, 
          value = 2000, 
          step = 100
        ),
        actionButton("diff_plotsel_group_view", "View selected groups", style = "width: 100%; border: 1px solid white;"), 
        actionButton("diff_plotsel_group_clear", "Clear all groups", style = "width: 100%; border: 1px solid white;"), 
        actionButton("diff_plotsel_group_submit", "Confirm group selection", style = "width: 100%; border: 1px solid white;"), 
        textOutput("diff_plotsel_group_submit_message")
      )
    }
  })
  
  # UI panel for manual group selection
  output$diff_manual_grouping_ui <- renderUI({
    if (input$diff_manual_grouping_method == "Text input") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Group samples by text input")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_text_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_text_info",
          title = "<h3>Use text input to group samples</h3>",
          content = do.call(paste0, 
                            popover_contents$diff_group_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        textAreaInput(
          "diff_sample_groups_text", 
          label = tags$span("Input comma-separated sample ids (each line is a group)",
                            bsButton("diff_sample_groups_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5),
        bsPopover(
          id = "diff_sample_groups_text_info",
          title = "<h4>Use text input to group samples</h4>",
          content = do.call(paste0, 
                            popover_contents$diff_sample_groups_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "diff_sample_groups_txt_file", 
          "Upload txt file indicating sample groups", 
          accept = "text/plain"
        ),
        actionButton(
          "submit_diff_groups_text", 
          label = "Confirm groups"
        ),
        textOutput("diff_groups_text_submission_text")
      )
    } else if (input$diff_manual_grouping_method == "Drag and drop") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Group samples by drag and drop")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_dd_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_dd_info",
          title = "<h3>Use drag-and-drop to group samples</h3>",
          content = do.call(paste0, 
                            popover_contents$diff_group_dd_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        uiOutput("diff_group_sel_bucket"), 
        uiOutput("diff_dd_del_group_ui"), 
        uiOutput("diff_dd_add_group_ui"), 
        actionButton("diff_dd_reset_groups", "Reset", style = "width: 40%; border: 1px solid white;"),
        br(),
        actionButton("submit_diff_groups_dd", "Confirm groups", style = "width: 40%; border: 1px solid white;"), 
        uiOutput("diff_groups_text_submission_dd")
      )
    } else if (input$diff_manual_grouping_method == "Select from plot") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Group samples from plot")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_plotsel_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_plotsel_info",
          title = "<h3>Select sample groups from plot</h3>",
          content = do.call(paste0, 
                            popover_contents$diff_group_plotsel_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        uiOutput("diff_plotsel_plot_ui"), 
        checkboxInput("diff_plotsel_show_sel_pts", 
                      "Show selected samples in table", 
                      value = TRUE), 
        uiOutput("diff_plotsel_sel_pts_table_ui"),
        tags$div(
          style = "display: inline-block;", 
          actionButton("diff_plotsel_add_group", "Add to new group", style = "border: 1px solid white;"),
          actionButton("diff_plotsel_add_to_group", "Add to existing group", style = "border: 1px solid white;"),
          actionButton("diff_plotsel_make_rest_group", "Add all remaining samples to new group", style = "border: 1px solid white;")
        )
      )
    }
  })
  
  # Show modal with PCA results graph
  observeEvent(input$diff_pca_show_graph_submit, {
    showModal(modalDialog(
      uiOutput("diff_pca_ui"),
      size = 'l',
      easyClose = TRUE
    ))
  })
  
  # Sample groups - named vector similar to clustering vector
  diff_sample_groups <- reactiveVal()
  
  # Reactive value containing selected groups from plot
  diff_plotsel_groups <- reactiveVal(list())
  
  # Render UI for group selection plot
  output$diff_plotsel_plot_ui <- renderUI({
    if (length(unlist(diff_plotsel_groups())) == nrow(selected_samples())) {
      p("All samples have been grouped. Click on Confirm groups to submit sample groups. ")
    } else {
      tagList(
        h4("Samples PCA plot"), 
        plotlyOutput("diff_plotsel_plot"),
        bsTooltip("diff_plotsel_plot", 
                  title = "Samples PCA plot. Use box select or lasso select tools on top to select and group samples from this plot. ", 
                  placement = "top", 
                  options = list(container = "body"))
      )
    }
  })
  
  # Render plot selection PCA plot
  output$diff_plotsel_plot <- renderPlotly({
    top_pcs <- diff_pca_res()[, 1:2]
    df <- cbind(top_pcs, selected_samples())
    grouped_samples <- unlist(diff_plotsel_groups())
    df <- df[! df$sample %in% grouped_samples, ]
    g <- ggplot(data = df, 
                mapping = aes(PC1, PC2, 
                              colour = factor(project), 
                              customdata = sample, 
                              text = paste("File source: ", file_source, 
                                           '<br>Project: ', project, 
                                           '<br>Sample: ', sample))) + geom_point()
    g$labels$colour <- "Project"
    p <- ggplotly(g, 
                  tooltip = 'text', 
                  source = "diff_plotsel_plot")
    event_register(p, "plotly_selected")
    p
  })
  
  # Selected samples from plot
  diff_plotsel_plot_samples_selected <- reactiveVal(c())
  
  # Update selected samples from plot
  observe({
    selected <- event_data(event = "plotly_selected", 
                           source = "diff_plotsel_plot",
                           session = shiny::getDefaultReactiveDomain())
    diff_plotsel_plot_samples_selected(selected$customdata)
  })
  
  # Render UI for selected points table
  output$diff_plotsel_sel_pts_table_ui <- renderUI({
    if (input$diff_plotsel_show_sel_pts) {
      tagList(
        h4("Selected samples"), 
        DT::dataTableOutput("diff_plotsel_sel_pts_table")
      )
    }
  })
  
  # Render selected points table
  output$diff_plotsel_sel_pts_table <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% diff_plotsel_plot_samples_selected(), ], 
                                                           rownames = FALSE,
                                                           filter = list(position = 'top', clear = FALSE), 
                                                           selection = "none")
  
  # Add new group
  observeEvent(input$diff_plotsel_add_group, {
    if (length(diff_plotsel_plot_samples_selected()) > 0) {
      new_group <- list(diff_plotsel_plot_samples_selected())
      diff_plotsel_groups(c(diff_plotsel_groups(), new_group))
      diff_plotsel_plot_samples_selected(c())
    }
  })
  
  # Add all remaining samples to new group
  observeEvent(input$diff_plotsel_make_rest_group, {
    if (length(unlist(diff_plotsel_groups())) < nrow(selected_samples())) {
      new_group <- list(selected_samples()$sample[! selected_samples()$sample %in% unlist(diff_plotsel_groups())])
      diff_plotsel_groups(c(diff_plotsel_groups(), new_group))
      diff_plotsel_plot_samples_selected(c())
    }
  })
  
  # Show pop-up when user adds samples to existing group
  observeEvent(input$diff_plotsel_add_to_group, {
    if (length(diff_plotsel_plot_samples_selected()) > 0) {
      if (length(diff_plotsel_groups()) > 0) {
        showModal(modalDialog(
          tagList(
            selectInput("diff_plotsel_add_to_group_sel", 
                        "Add to group: ", 
                        choices = c(1:length(diff_plotsel_groups()))), 
            actionButton("diff_plotsel_add_to_group_submit", "Confirm adding to selected group")
          ), 
          size = 'l',
          easyClose = TRUE
        ))
      } else {
        showModal(modalDialog(
          p("There is no existing group. Please create groups first."), 
          size = 'l',
          easyClose = TRUE
        ))
      }
    }
  })
  
  # Add samples to existing group
  observeEvent(input$diff_plotsel_add_to_group_submit, {
    add_to_group <- as.numeric(input$diff_plotsel_add_to_group_sel)
    groups_list <- diff_plotsel_groups()
    groups_list[[add_to_group]] <- c(groups_list[[add_to_group]], diff_plotsel_plot_samples_selected())
    diff_plotsel_groups(groups_list)
    diff_plotsel_plot_samples_selected(c())
    removeModal()
  })
  
  # Show pop-up for group viewing
  observeEvent(input$diff_plotsel_group_view, {
    showModal(modalDialog(
      h4("PCA plot of grouped samples"),
      plotlyOutput("diff_plotsel_groups_plot"),
      bsTooltip("diff_plotsel_groups_plot", 
                title = "Each data point is a sample colored by current group", 
                placement = "top", 
                options = list(container = "body")),
      h4("User-selected groups"),
      uiOutput("diff_plotsel_group_modal_ui"), 
      size = 'l',
      easyClose = TRUE
    ))
  })
  
  # Render plotly PCA plot colored by groups
  output$diff_plotsel_groups_plot <- renderPlotly({
    top_pcs <- diff_pca_res()[, 1:2]
    df <- cbind(top_pcs, selected_samples())
    groups <- rep('None', nrow(selected_samples()))
    if (length(diff_plotsel_groups())) {
      for (i in 1:length(diff_plotsel_groups())) {
        groups[df$sample %in% diff_plotsel_groups()[[i]]] <- i
      }
    }
    df$group <- groups
    g <- ggplot(data = df, 
                mapping = aes(PC1, PC2, 
                              colour = factor(group),
                              text = paste("File source: ", file_source, 
                                           '<br>Project: ', project, 
                                           '<br>Sample: ', sample, 
                                           '<br>Group: ', group))) + geom_point()
    g$labels$colour <- "Group"
    p <- ggplotly(g, 
                  tooltip = 'text')
    p
  })
  
  # UI for group tables
  output$diff_plotsel_group_modal_ui <- renderUI({
    if (length(diff_plotsel_groups()) > 0) {
      lapply(1:length(diff_plotsel_groups()), function(x) {
        wellPanel(
          strong(paste("Group", x)), 
          hr(),
          DT::dataTableOutput(paste0("diff_plotsel_group", x, "_table"))
        )
      })
    } else {
      p("No group has been created. ")
    }
  })
  
  # Render data tables for created groups
  observeEvent(diff_plotsel_groups(), ignoreNULL = FALSE, {
    if (length(diff_plotsel_groups()) > 0) {
      lapply(1:length(diff_plotsel_groups()), function(x) {
        samples <- diff_plotsel_groups()[[x]]
        df <- selected_samples()[selected_samples()$sample %in% samples, ]
        output[[paste0("diff_plotsel_group", x, "_table")]] <- DT::renderDataTable(df, 
                                                                                   rownames = FALSE,
                                                                                   filter = list(position = 'top', clear = FALSE), 
                                                                                   selection = "none")
      })
    }
  })
  
  # Clear all groups pop-up
  observeEvent(input$diff_plotsel_group_clear, {
    showModal(modalDialog(
      p("Clear all groups?"), 
      actionButton("diff_plotsel_group_clear_confirm", "Yes")
    ))
  })
  
  # Clear all groups
  observeEvent(input$diff_plotsel_group_clear_confirm, {
    diff_plotsel_groups(list())
    removeModal()
  })
  
  # Render group submission message
  output$diff_plotsel_group_submit_message <- renderText({
    diff_plotsel_group_submit_message()
  })
  
  # Update sample groups
  diff_plotsel_group_submit_message <- eventReactive(input$diff_plotsel_group_submit, {
    if (length(unlist(diff_plotsel_groups())) == nrow(selected_samples())) {
      if (length(diff_plotsel_groups()) == 1) {
        return(paste("Failed. Please make at least 2 groups."))
      }
      if (all(sapply(diff_plotsel_groups(), length) == 1)) {
        return(paste("Failed. Please make sure there is at least 1 group with multiple samples. "))
      }
      vec <- rep(0, nrow(selected_samples()))
      names(vec) <- selected_samples()$sample
      for (i in 1:length(diff_plotsel_groups())) {
        vec[diff_plotsel_groups()[[i]]] <- i
      }
      diff_sample_groups(vec)
      return(paste("Grouping completed!"))
    } else {
      return(paste("Failed. Please group all samples before submission."))
    }
  })
  
  # Update group selection text area input value based on uploaded file
  observeEvent(input$diff_sample_groups_txt_file, {
    if (! is.null(input$diff_sample_groups_txt_file)) {
      groups_text <- paste(readLines(input$diff_sample_groups_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "diff_sample_groups_text", 
        value = groups_text
      )
    }
  })
  
  # Render submission text
  output$diff_groups_text_submission_text <- renderText({
    diff_groups_text_submission_text()
  })
  
  # Update submission text based on action button and text evaluation results
  diff_groups_text_submission_text <- eventReactive(input$submit_diff_groups_text, {
    # Read sample groups from submitted text
    groups_list <- unlist(strsplit(input$diff_sample_groups_text, split = "\n"))
    groups_list <- lapply(groups_list, function(group) {
      samples <- unlist(strsplit(group, split = ","))
      samples <- gsub(" ", "", samples)
      samples <- gsub("\t", "", samples)
      samples
    })
    groups_list <- groups_list[groups_list != ""]
    if (length(unlist(groups_list)) == 0) {
      return(paste("Grouping failed. \nInput is empty."))
    }
    # Check if samples exist in selection
    sample_ids <- colnames(pred_mat())
    if (any(! unlist(groups_list) %in% sample_ids)) {
      bad_samples <- unlist(groups_list)[which(! unlist(groups_list) %in% sample_ids)]
      return(paste0("Grouping failed. \nThe following samples are not found in selected samples:\n", 
                    paste(unique(bad_samples), collapse = "\n")))
    } else if (! all(sample_ids %in% unlist(groups_list))) {
      bad_samples <- sample_ids[which(! sample_ids %in% unlist(groups_list))]
      return(paste0("Grouping failed. \nThe following samples are not assigned to any groups:\n", 
                    paste(unique(bad_samples), collapse = "\n")))
    }
    sample_groups <- rep(0, ncol(pred_mat()))
    names(sample_groups) <- sample_ids
    for (i in seq_along(groups_list)) {
      group_vec <- groups_list[[i]]
      for (sample in group_vec) {
        if (sample_groups[sample] != 0) {
          return(paste0("Grouping failed. \n", sample, " is found in multiple groups."))
        }
        sample_groups[sample] <- i
      }
    }
    if (length(unique(sample_groups)) < 2) {
      paste("Grouping failed. \nYou need at least 2 groups to perform differential analysis.")
    } else if (all(table(sample_groups[sample_groups > 0]) == 1)) {
      paste("Grouping failed. \nYou need at least one group with multiple samples to perform differential analysis.")
    } else {
      diff_sample_groups(sample_groups)
      paste("Grouping completed!")
    }
  })
  
  # Reactive value containing drag and drop groups
  diff_dd_groups <- reactiveVal()
  
  # Update drag and drop groups when selected samples change
  observe({
    sel_samples <- selected_samples()$sample
    diff_dd_groups(tibble(text = c("Drag samples from here", "group 1", "group 2"), 
                          values = list(sel_samples, NULL, NULL), 
                          ids = c("diff_samples_bank", "diff_group1", "diff_group2")))
  })
  
  # Render UI for last rank list deletion
  output$diff_dd_del_group_ui <- renderUI({
    if ((nrow(diff_dd_groups()) > 3)) {
      actionButton("diff_dd_del_group", "Delete last group", style = "width: 40%; border: 1px solid white;")
    }
  })
  
  # Remove last rank list
  observeEvent(input$diff_dd_del_group, {
    last_group <- paste0("diff_group", nrow(diff_dd_groups()) - 1)
    last_group_items <- input[[last_group]]
    updated_samples_bank <- c(input$diff_samples_bank, last_group_items)
    curr_groups <- diff_dd_groups() 
    curr_groups$values <- input$diff_dd_bucket
    curr_groups$values[[1]] <- updated_samples_bank
    diff_dd_groups(curr_groups[- nrow(curr_groups), ])
  })
  
  # Render UI for adding new rank list
  output$diff_dd_add_group_ui <- renderUI({
    if (nrow(diff_dd_groups()) < ncol(pred_mat())) {
      actionButton("diff_dd_add_group", "Add new group", style = "width: 40%; border: 1px solid white;")
    }
  })
  
  # Add new rank list
  observeEvent(input$diff_dd_add_group, {
    new_group <- tibble(text = paste("group", nrow(diff_dd_groups())),
                        values = NULL, 
                        ids = paste0("diff_group",nrow(diff_dd_groups())))
    curr_groups_vals <- input$diff_dd_bucket
    curr_groups_vals[length(curr_groups_vals) + 1] <- list(NULL)
    curr_groups <- tibble(text = c("Drag samples from here", paste("group", 1:nrow(diff_dd_groups()))),
                          values = curr_groups_vals, 
                          ids = c("diff_samples_bank", paste0("diff_group", 1:nrow(diff_dd_groups()))))
    diff_dd_groups(curr_groups)
  })
  
  # Reset rank lists pop-up
  observeEvent(input$diff_dd_reset_groups, {
    showModal(modalDialog(
      p("Clear all groups? "), 
      actionButton("diff_dd_reset_groups_confirm", "Yes")
    ))
  })
  
  # Reset rank lists
  observeEvent(input$diff_dd_reset_groups_confirm, {
    sel_samples <- selected_samples()$sample
    diff_dd_groups(tibble(text = c("Drag samples from here", "group 1", "group 2"), 
                          values = list(sel_samples, NULL, NULL), 
                          ids = c("diff_samples_bank", "diff_group1", "diff_group2")))
    removeModal()
  })
  
  # Rank list items for bucket list 
  diff_groups_rank_lists <- reactive({
    diff_dd_groups() %>% mutate(
      rank.list = pmap(list(text, values, ids), function(x,y,z){
        add_rank_list(
          text = x,
          labels = y ,
          input_id = z
        )
      })
    ) %>% pull(rank.list)
  })
  
  # Render UI for drag and drop group selection 
  output$diff_group_sel_bucket <- renderUI({
    rank_list_items <- diff_groups_rank_lists()
    do.call("bucket_list", args = c(
      list(header = "",
           group_name = "diff_dd_bucket",
           orientation = "horizontal"),
      rank_list_items
    ))
  })
  
  # Render submission text
  output$diff_groups_text_submission_dd <- renderText({
    diff_groups_text_submission_dd()
  })
  
  # Update submission text based on action button and drag and drop groups
  diff_groups_text_submission_dd <- eventReactive(input$submit_diff_groups_dd, {
    groups_list <- input$diff_dd_bucket
    groups_list[1] <- NULL
    sample_groups <- rep(0, ncol(pred_mat()))
    names(sample_groups) <- colnames(pred_mat())
    for (i in seq_along(groups_list)) {
      group_vec <- groups_list[[i]]
      for (sample in group_vec) {
        sample_groups[sample] <- i
      }
    }
    if (all(table(sample_groups[sample_groups > 0]) == 1)) {
      paste("Grouping failed. \nYou need at least one group with multiple samples to perform differential analysis.")
    } else if (any(sample_groups == 0)) {
      paste0("Grouping failed. \nThe following samples are not assigned to any groups:\n", 
             paste(names(sample_groups[sample_groups == 0]), collapse = "\n"))
    } else {
      diff_sample_groups(sample_groups)
      paste("Grouping completed!")
    }
  })
  
  # PCA top variance filtered prediction matrix
  diff_pca_top_var_pred_mat <- reactive({
    # Calculate hyper variance for each bin
    n_top_var <- min(input$diff_pca_top_var, nrow(pred_hypervar()))
    top_var_idx <- base::sort(pred_hypervar()$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    top_var_idx <- base::sort(top_var_idx)
    
    # Filter prediction matrix by top variance rows
    return(pred_mat()[pred_hypervar()$feature[top_var_idx], ])
  })
  
  # Get PCA result
  diff_pca_res_full <- reactive({
    
    if (! all(is.na(pred_hypervar()))) {
      pred_mat_sorted <- t(diff_pca_top_var_pred_mat())
      
      # Remove near zero variance columns
      if (length(nearZeroVar(pred_mat_sorted)) > 0) {
        pred_mat_sorted <- pred_mat_sorted[, - nearZeroVar(pred_mat_sorted)]
      }
      
      if (any(dim(pred_mat_sorted) == 0)) {
        return(NA)
      }
      
      showModal(modalDialog("Performing PCA...", footer = NULL, easyClose = TRUE, size = "s"))
      pca_result <- prcomp(pred_mat_sorted, 
                           scale = TRUE)
      removeModal()
      
      return(pca_result)
    } 
    return(NA)
  })
  
  # Get transformed vectors from PCA result
  diff_pca_res <- reactive({
    if (! all(is.na(diff_pca_res_full()))) {
      res <- data.frame(diff_pca_res_full()$x)
      # Sort result columns by PC
      return(res[, paste0("PC", 1:ncol(res))])
    }
    return(NA)
  })
  
  # Get optimal number of PCs
  diff_opt_n_pc <- reactive({
    sdev <- diff_pca_res_full()$sdev
    # Only consider first 30 PCs
    sdev <- sdev[1:min(30,length(sdev))]
    x <- 1:length(sdev)
    pcadim <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(sdev~x+x2)$residuals^2)
    }))
    pcadim
  })
  
  # Render panel with PCA results or message if no results can be generated
  output$diff_pca_plot_ui <- renderUI({
    if (all(is.na(diff_pca_res())) || ncol(diff_pca_res()) < 2) {
      p("Too few genomic bins with significant variance.")
    } else {
      tagList(
        h4("PCA plot"),
        plotOutput("diff_pca_plot", brush = "diff_pca_plot_brush"), 
        bsTooltip("diff_pca_plot", 
                  title = "Each data point in this plot is a sample. Brush on this plot to view sample details. ", 
                  placement = "top", 
                  options = list(container = "body")),
        actionButton("diff_pca_plot_download", "Download plot"), 
        hr(),
        h4("PCA brushed points table"),
        # Display table with brushed samples
        DT::dataTableOutput('diff_pca_brushed')
      )
    }
  })
  
  diff_pca_plot <- reactive({
    if (!all(is.na(diff_pca_res())) && ncol(diff_pca_res()) >= 2) {
      top_pcs <- diff_pca_res()[, 1:2]
      proj <- selected_samples()$project
      pca_plot <- ggplot(data = top_pcs, 
                         mapping = aes(PC1, PC2, colour = factor(proj))) + geom_point()
      pca_plot$labels$colour <- "Project"
      pca_plot
    }
  })
  
  # Render PCA plot
  output$diff_pca_plot <- renderPlot({
    diff_pca_plot()
  })
  
  observeEvent(input$diff_pca_plot_download, {
    download_plot(diff_pca_plot())
  })
  
  # Render PCA brushed points table
  observeEvent(input$diff_pca_plot_brush, {
    top_pcs <- diff_pca_res()[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$diff_pca_plot_brush, xvar = "PC1", yvar = "PC2"))
    output$diff_pca_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                                   rownames = FALSE,
                                                   filter = list(position = 'top', clear = FALSE), 
                                                   selection = "none")
  })
  
  diff_pca_var_plot <- reactive({
    explained_var <- data.frame(t(summary(diff_pca_res_full())$importance))
    explained_var <- explained_var[paste0('PC', 1:min(30, nrow(explained_var))), ]
    var_plot <- ggplot(data = explained_var, 
                       mapping = aes(factor(rownames(explained_var), levels = rownames(explained_var)), 
                                     explained_var$Proportion.of.Variance, group=1))
    var_plot <- var_plot + geom_line() + geom_point()
    var_plot <- var_plot + xlab("Principal Components") + ylab("Cumulative Proportion of Variance Explained")
    var_plot <- var_plot + geom_text(aes(label=explained_var$Proportion.of.Variance), vjust=-0.25)
    var_plot
  })
  
  # Render PCA variance plot
  output$diff_pca_var_plot <- renderPlot({
    diff_pca_var_plot()
  })
  
  observeEvent(input$diff_pca_var_plot_download, {
    download_plot(diff_pca_var_plot())
  })
  
  diff_pca_cumvar_plot <- reactive({
    cumvar <- data.frame(t(summary(diff_pca_res_full())$importance))
    cumvar <- cumvar[paste0('PC', 1:nrow(cumvar)), ]
    cumvar_plot <- ggplot(data = cumvar, 
                          mapping = aes(factor(rownames(cumvar), levels = rownames(cumvar)), 
                                        cumvar$Cumulative.Proportion, group=1))
    cumvar_plot <- cumvar_plot + geom_line() + geom_point()
    cumvar_plot <- cumvar_plot + geom_vline(xintercept = paste0('PC', opt_n_pc()), linetype = "dashed")
    cumvar_plot <- cumvar_plot + xlab("Principal Components") + ylab("Proportion of Variance Explained")
    cumvar_plot <- cumvar_plot + geom_text(aes(label=cumvar$Cumulative.Proportion), vjust=-0.25)
    cumvar_plot
  })
  
  # Render PCA cumulative variance plot
  output$diff_pca_cumvar_plot <- renderPlot({
    diff_pca_cumvar_plot()
  })
  
  observeEvent(input$diff_pca_cumvar_plot_download, {
    download_plot(diff_pca_cumvar_plot())
  })
  
  # Render PCA results UI panel
  output$diff_pca_ui <- renderUI({
    if (input$diff_pca_show_graph == "PCA Plot") {
      # Output PCA plot
      uiOutput("diff_pca_plot_ui")
    } else if (input$diff_pca_show_graph == "Explained Variance") {
      # Output explained variance plot
      tagList(
        h4("PCA explained variance plot"), 
        plotOutput("diff_pca_var_plot"), 
        bsTooltip("diff_pca_var_plot", 
                  title = "Explained variance for each PC.", 
                  placement = "top", 
                  options = list(container = "body")), 
        actionButton("diff_pca_var_plot_download", "Download plot")
      )
    } else if (input$diff_pca_show_graph == "Cumulative Explained Variance"){
      # Output cumulative variance plot
      tagList(
        h4("PCA cumulative explained variance plot"), 
        plotOutput("diff_pca_cumvar_plot"), 
        bsTooltip("diff_pca_cumvar_plot", 
                  title = "Cumulative explained variance along number of top PCs.", 
                  placement = "top", 
                  options = list(container = "body")), 
        actionButton("diff_pca_cumvar_plot_download", "Download plot")
      )
    }
  })
  
  # Update chosen number of PCs on optimal choice check box
  observeEvent(input$diff_use_opt_n_pc, {
    if (input$diff_use_opt_n_pc) {
      updateSliderInput(
        session, 
        "diff_n_pc", 
        value = diff_opt_n_pc()
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of PCs
  observeEvent(input$diff_n_pc, {
    if (input$diff_n_pc != diff_opt_n_pc()) {
      updateCheckboxInput(
        session, 
        "diff_use_opt_n_pc", 
        value = FALSE
      )
    }
  })
  
  # Message stating the optimal number of clusters
  output$diff_opt_n_pc_msg <- renderUI({
    HTML(paste0("Optimal number of PCs: <b>", diff_opt_n_pc(), "</b>"))
  })
  
  # All sample clustering results for differential analysis
  all_sample_clust_res <- reactive({
    showModal(modalDialog("Clustering samples...", footer = NULL, easyClose = TRUE, size = "s"))
    scaled_df <- diff_pca_res()[, 1:input$diff_n_pc]
    set.seed(12345)
    # Do k-means clustering with all possible number of clusters
    all_res <- list()
    for (i in 2:min(diff_max_n_sample_clust, nrow(diff_pca_res()) - 1)) {
      suppressWarnings(kmeans_res <- kmeans(scaled_df, centers = i, nstart = 25, iter.max = 100))
      all_res[[as.character(i)]] <- kmeans_res
    }
    removeModal()
    return(all_res)
  })
  
  # Optimal number of sample clusters
  diff_opt_n_sample_clust <- reactive({
    # Use elbow method to find optimal number of clusters
    wss <- sapply(all_sample_clust_res(), function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    })) + 1
    return(opt_nclust)
  })
  
  # Selected sample clustering results
  diff_sample_clust_res <- reactive({
    kmeans_res <- all_sample_clust_res()[[as.character(input$diff_n_sample_clust)]]
    return(kmeans_res)
  })
  
  # Message stating the optimal number of clusters
  output$diff_opt_n_sample_clust_msg <- renderUI({
    HTML(paste("Optimal number of clusters:", strong(diff_opt_n_sample_clust())))
  })
  
  diff_sample_clust_wss_plot <- reactive({
    tot_wss <- unlist(lapply(all_sample_clust_res(), function(x) {x$tot.withinss}))
    wss_df <- data.frame(n_clust = c(2:min(diff_max_n_sample_clust, ncol(pred_mat()) - 1)), 
                         wss = tot_wss)
    wcss_plot <- ggplot(data = wss_df, 
                        mapping = aes(n_clust, wss))
    wcss_plot <- wcss_plot + geom_line() + geom_point()
    wcss_plot <- wcss_plot + xlab("Number of Clusters") + ylab("Total Within Cluster Sum of Squares")
    wcss_plot <- wcss_plot + geom_vline(xintercept = diff_opt_n_sample_clust(), linetype="dashed", color = "blue")
    wcss_plot
  })
  
  # Sample clusters WSS plot
  output$diff_sample_clust_wss_plot <- renderPlot({
    diff_sample_clust_wss_plot()
  })
  
  observeEvent(input$diff_sample_clust_wss_plot_download, {
    download_plot(diff_sample_clust_wss_plot())
  })
  
  # UI for sample clusters WSS plot
  output$diff_sample_clust_wss_plot_ui <- renderUI({
    if (input$diff_show_sample_clust_wss_plot) {
      tagList(
        h4("Sample clusters within-cluster sum of squares plot"),
        plotOutput('diff_sample_clust_wss_plot'), 
        bsTooltip("diff_sample_clust_wss_plot", 
                  title = "This plot shows the total within-cluster sum of squares for grouping samples into different number of clusters. The dashed line indicates the optimal number of clusters suggested by elbow method. ", 
                  placement = "top", 
                  options = list(container = "body")), 
        actionButton("diff_sample_clust_wss_plot_download", "Download plot")
      )
    }
  })
  
  diff_sample_clust_plot_pca <- reactive({
    showModal(modalDialog("Making cluster plot...", footer = NULL, easyClose = TRUE, size = "s"))
    # Plot the top 2 PCs
    clust_plot <- ggplot(data = data.frame(diff_pca_res_full()$x)[, 1:2], 
                         mapping = aes(PC1, PC2, colour = factor(diff_sample_clust_res()$cluster)))
    clust_plot <- clust_plot + geom_point()
    clust_plot$labels$colour <- "Cluster"
    explained_var <- summary(diff_pca_res_full())$importance[2, 1:2]
    clust_plot <- clust_plot + xlab(paste0("PC1 (", explained_var[1] * 100, "% variance)"))
    clust_plot <- clust_plot + ylab(paste0("PC2 (", explained_var[2] * 100, "% variance)"))
    removeModal()
    clust_plot
  })
  
  # Render sample clusters PCA plot
  output$diff_sample_clust_plot_pca <- renderPlot({
    diff_sample_clust_plot_pca()
  })
  
  observeEvent(input$diff_sample_clust_plot_pca_download, {
    download_plot(diff_sample_clust_plot_pca())
  })
  
  # Render PCA brushed points table
  observeEvent(input$diff_sample_clust_plot_pca_brush, {
    top_pcs <- data.frame(diff_pca_res_full()$x)[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$diff_sample_clust_plot_pca_brush, xvar = "PC1", yvar = "PC2"))
    output$diff_sample_clust_plot_pca_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                                                     rownames = FALSE,
                                                                     filter = list(position = 'top', clear = FALSE), 
                                                                     selection = "none")
  })
  
  # Render table for sample cluster assignment
  output$diff_sample_clust_table <- DT::renderDataTable(data.frame(cluster = as.factor(diff_sample_clust_res()$cluster), 
                                                                   sample = names(diff_sample_clust_res()$cluster)), 
                                                        rownames = FALSE,
                                                        filter = list(position = 'top', clear = FALSE), 
                                                        selection = "none")
  
  # Render UI for differential analysis sample clustering results panels
  output$diff_sample_clust_res_panel <- renderUI({
    if (input$diff_sample_clust_res_show_panel == "Cluster Plot (PCA)") {
      tagList(
        h4("PCA plot of samples"),
        plotOutput('diff_sample_clust_plot_pca', brush = 'diff_sample_clust_plot_pca_brush'), 
        bsTooltip("diff_sample_clust_plot_pca", 
                  title = "This plot shows the top 2 PCs of PCA. Each point is a sample colored by cluster. ", 
                  placement = "top", 
                  options = list(container = "body")),
        actionButton("diff_sample_clust_plot_pca_download", "Download plot"), 
        hr(),
        # Display table with brushed samples
        h4("PCA plot brushed points"),
        DT::dataTableOutput('diff_sample_clust_plot_pca_brushed')
      )
    } else if (input$diff_sample_clust_res_show_panel == "Clustering") {
      tagList(
        h4("Samples clustering table"),
        downloadButton('diff_sample_clust_table_download', 'Download clustering table'), 
        DT::dataTableOutput('diff_sample_clust_table')
      )
    } 
  })
  
  # Differential analysis samples kmeans cluster result download
  output$diff_sample_clust_table_download <- downloadHandler(
    filename = function() { "Samples_kmeans_clusters.txt" },
    content = function(file) {
      write.table(data.frame(cluster = as.factor(diff_sample_clust_res()$cluster), 
                             sample = names(diff_sample_clust_res()$cluster)),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Render UI for selecting differential analysis sample clustering results panels
  output$diff_sample_clust_res_ui <- renderUI({
    if (input$diff_show_sample_clust_res) {
      tagList(
        selectInput(
          "diff_sample_clust_res_show_panel", 
          label = "Choose sample clustering result panel to display: ", 
          choices = c("Cluster Plot (PCA)", 
                      "Clustering"), 
          selected = "Cluster Plot (PCA)"
        ), 
        uiOutput('diff_sample_clust_res_panel')
      )
    }
  })
  
  # Update chosen number of sample clusters on optimal choice check box
  observeEvent(input$diff_use_opt_n_sample_clust, {
    if (input$diff_use_opt_n_sample_clust) {
      updateSliderInput(
        session, 
        "diff_n_sample_clust", 
        value = diff_opt_n_sample_clust()
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of sample clusters
  observeEvent(input$diff_n_sample_clust, {
    if (input$diff_n_sample_clust != diff_opt_n_sample_clust()) {
      updateCheckboxInput(
        session, 
        "diff_use_opt_n_sample_clust", 
        value = FALSE
      )
    }
  })
  
  output$diff_groups_kmeans_submission_text <- renderText({
    diff_groups_kmeans_submission_text()
  })
  
  # Update submission text based on action button and kmeans clusters evaluation results
  diff_groups_kmeans_submission_text <- eventReactive(input$submit_diff_groups_kmeans, {
    diff_sample_groups(diff_sample_clust_res()$cluster)
    paste0("Grouping completed!")
  })
  
  # Render UI for differential test panel
  output$diff_test_analysis_panel_ui <- renderUI({
    if (! is.null(diff_sample_groups())) {
      sidebarLayout(
        sidebarPanel(
          div(style = "display: inline-block;vertical-align: middle;", h4("Differential test parameters")), 
          div(style = "display: inline-block;vertical-align: middle;", 
              bsButton(
                "diff_param_info", 
                label = "", 
                icon = icon("info"), 
                style = "info", 
                size = "extra-small"
              )), 
          bsPopover(
            id = "diff_param_info",
            title = "<h4>Differential test parameters</h4>",
            content = do.call(paste0, 
                              popover_contents$diff_param_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          checkboxInput(
            "diff_select_all_sample_groups",
            "Perform test for all sample groups", 
            value = FALSE
          ), 
          uiOutput("diff_select_sample_groups_ui"), 
          bsTooltip("diff_select_sample_groups_ui", 
                    title = "At least 2 groups must be selected, with at least 1 group containing multiple samples. ", 
                    placement = "right", 
                    options = list(container = "body")),
          uiOutput("diff_sel_test_method_ui"), 
          bsTooltip("diff_sel_test_method_ui", 
                    title = "Tests on two groups include t-test, non-parametric Wilcoxon test, and permutation test. Tests on more than two groups include ANOVA test, non-parametric Kruskal-Wallis test, and permutation test. ", 
                    placement = "right", 
                    options = list(container = "body")),
          uiOutput("diff_sel_squeezevar"), 
          uiOutput("diff_permu_num_ui"),
          uiOutput("diff_test_alt_hyp_ui"),
          uiOutput("diff_test_alt_msg_ui"),
          checkboxInput("diff_scale","Scale predictions for each sample"),
          uiOutput('run_diff_test_button_ui') 
        ), 
        mainPanel(
          div(style = "display: inline-block;vertical-align: middle;", h3("Differential test results")), 
          div(style = "display: inline-block;vertical-align: middle;", 
              bsButton(
                "diff_res_panels_info", 
                label = "", 
                icon = icon("info"), 
                style = "info", 
                size = "extra-small"
              )), 
          bsPopover(
            id = "diff_res_panels_info",
            title = "<h4>Differential test results</h4>",
            content = do.call(paste0, 
                              popover_contents$diff_res_panels_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          uiOutput('diff_res_panels')
        )
      )
    } else {
      p("Please group samples in Group Samples tab and click on Confirm Grouping button to make sample groups first. ")
    }
  })
  
  # Render UI for selecting sample groups for differential test
  output$diff_select_sample_groups_ui <- renderUI({
    selectInput("diff_select_sample_groups",
                "Select groups where differential tests will be performed (at least two should be selected)",
                sort(unique(diff_sample_groups())),
                selected = sort(unique(diff_sample_groups()))[1:2],
                multiple = TRUE)
  })
  
  # Render UI for selecting test method for differential test
  output$diff_sel_test_method_ui <- renderUI({
    if (length(input$diff_select_sample_groups) > 2) {
      radioButtons("diff_sel_test_method",
                   "Select test method",
                   list("ANOVA test"="anovatest",
                        "Kruskal-Wallis test (nonparametric)"="kw",
                        "Permutation test"="permutation"))
    } else if (length(input$diff_select_sample_groups) == 2) {
      radioButtons("diff_sel_test_method",
                   "Select test method",
                   list("t test"="ttest",
                        "wilcoxon test (nonparametric)"="wilcox",
                        "Permutation test"="permutation"))
    }
  })
  
  # Render UI for differential test squeeze variance check box
  output$diff_sel_squeezevar <- renderUI({
    if ((input$diff_sel_test_method %in% c("anovatest", "permutation")) && (length(input$diff_select_sample_groups) > 2)) {
      checkboxInput("diff_squeezevar", "Use shrinkage to squeeze group variances", value = TRUE)
    }
  })
  
  # Render UI for selecting permutation number
  output$diff_permu_num_ui <- renderUI({
    if ((length(input$diff_sel_test_method) > 0) && (input$diff_sel_test_method == "permutation")) {
      sliderInput("diff_permu_num",
                  "Number of permutations",
                  min = 100, 
                  max = 1000, 
                  value = 100, 
                  step = 100)
    }
  })
  
  # Render UI for differential test alternative hypothesis
  output$diff_test_alt_hyp_ui <- renderUI({
    if (length(input$diff_select_sample_groups) == 2) {
      radioButtons("diff_test_alt_hyp",
                   "Select alternative hypothesis type",
                   c("two.sided", "less", "greater"))
    }
  })
  
  # Render UI for differential test alternative hypothesis message
  output$diff_test_alt_msg_ui <- renderUI({
    if (length(input$diff_select_sample_groups) == 2) {
      clu <- diff_sample_groups()
      clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
      uclu <- unique(clu)
      if ((! is.null(input$diff_test_alt_hyp)) && (input$diff_test_alt_hyp == "two.sided")) {
        p(paste0("Group ",uclu[1]," will be compared with group ",uclu[2],". The alternative hypothesis is that group ",uclu[1]," is not equal to group ",uclu[2],"."))
      } else {
        p(paste0("Group ",uclu[1]," will be compared with group ",uclu[2],". The alternative hypothesis is that group ",uclu[1]," is ",input$diff_test_alt_hyp," than group ",uclu[2],"."))
      }
    }
  })
  
  # Render UI for differential test run button
  output$run_diff_test_button_ui <- renderUI({
    if (length(input$diff_select_sample_groups) < 2) {
      return(tags$span(style="color:red", "Please select at least 2 sample groups to perform differential test. "))
    } 
    clu <- diff_sample_groups()
    clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
    if (length(clu) == length(input$diff_select_sample_groups)) {
      tags$span(style="color:red", "Please select at least 1 group containing more than 1 sample to perform differential test, as group size of 1 for all groups causes 0 degree of freedom. ")
    } else {
      actionButton("run_diff_test","Perform Test")
    }
  })
  
  # Update selected sample groups on select all check box
  observeEvent(input$diff_select_all_sample_groups, {
    if (input$diff_select_all_sample_groups) {
      updateSelectInput(
        session, 
        "diff_select_sample_groups", 
        selected = sort(unique(diff_sample_groups()))
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of PCs
  observeEvent(input$diff_select_sample_groups, {
    if (! all(sort(unique(diff_sample_groups())) %in% input$diff_select_sample_groups)) {
      updateCheckboxInput(
        session, 
        "diff_select_all_sample_groups", 
        value = FALSE
      )
    }
  })
  
  # Perform differential tests (adapted from SCRAT)
  diff_test_res <- reactive({
    if ((! is.null(input$run_diff_test)) && (input$run_diff_test > 0)) {
      showModal(modalDialog("Performing test...", footer = NULL, easyClose = TRUE, size = "s"))
      isolate({
        if (length(input$diff_select_sample_groups) > 2) {
          clu <- diff_sample_groups()
          data <- pred_mat()[, clu %in% as.numeric(input$diff_select_sample_groups)]
          data <- data[rowVars(data) > 0, ] # Remove zero variance bins
          clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
          if (input$diff_scale) {
            dm <- dimnames(data)
            data <- apply(data,2,scale)
            dimnames(data) <- dm
          }
          if (input$diff_sel_test_method=="kw") {
            res <- t(apply(data,1,function(rowdata) {
              tmp <- kruskal.test(rowdata,clu)
              c(tmp$statistic,tmp$p.value)
            }))
            stat <- res[,1]
            FDR <- p.adjust(res[,2],method="fdr")
            removeModal()
            return(data.frame(genomic_bin=row.names(data),statistics=stat,pvalue=res[,2],FDR=FDR,stringsAsFactors = F))
          }
          if (! input$diff_squeezevar) {
            # Remove rows with 0 SSW
            bad_rows <- which(rowSums(sapply(unique(clu),function(i) {
              rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2)
            })) == 0)
            if (length(bad_rows) > 0) {
              data <- data[- bad_rows, ]
            }
            cluSS <- sapply(unique(clu),function(i) {
              rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2)
            })
          } else {
            cluSS <- sapply(unique(clu),function(i) {
              suppressWarnings(squeezeVar(rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2), 
                                          df = sum(clu==i))$var.post)
            })
          }
          if (input$diff_sel_test_method=="anovatest") {
            totalSS <- rowSums((sweep(data,1,rowMeans(data),"-"))^2)
            stat <- ((totalSS-rowSums(cluSS))/(length(unique(clu)) - 1))/(rowSums(cluSS)/(ncol(data) - length(unique(clu))))
            pval <- pf(stat,(length(unique(clu)) - 1),(ncol(data) - length(unique(clu))),lower.tail = F)
            FDR <- p.adjust(pval,method="fdr")
          } else if (input$diff_sel_test_method=="permutation") {
            totalSS <- rowSums((sweep(data,1,rowMeans(data),"-"))^2)
            stat <- ((totalSS-rowSums(cluSS))/(length(unique(clu)) - 1))/(rowSums(cluSS)/(ncol(data) - length(unique(clu))))
            permustat <- sapply(1:as.numeric(input$diff_permu_num),function(id) {
              sampclu <- sample(clu)
              if (input$diff_squeezevar) {
                cluSS <- sapply(unique(sampclu),function(i) {
                  suppressWarnings(squeezeVar(rowSums((sweep(data[,sampclu==i,drop=F],1,rowMeans(data[,sampclu==i,drop=F]),"-"))^2), 
                                              df = sum(sampclu==i))$var.post)
                })
              } else {
                cluSS <- sapply(unique(sampclu),function(i) {
                  rowSums((sweep(data[,sampclu==i,drop=F],1,rowMeans(data[,sampclu==i,drop=F]),"-"))^2)
                })
              }
              ((totalSS-rowSums(cluSS))/(length(unique(clu)) - 1))/(rowSums(cluSS)/(ncol(data) - length(unique(clu))))
            })
            pval <- rowMeans(sweep(permustat,1,stat,"-") > 0)
            FDR <- p.adjust(pval,method="fdr")
          }
          removeModal()
          return(data.frame(genomic_bin=row.names(data),statistics=stat,pvalue=pval,FDR=FDR,stringsAsFactors = F))
        } else if (length(input$diff_select_sample_groups) == 2) {
          clu <- diff_sample_groups()
          data <- pred_mat()[, clu %in% as.numeric(input$diff_select_sample_groups)]
          data <- data[rowVars(data) > 0, ] # Remove zero variance bins
          clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
          
          if (input$diff_scale) {
            dm <- dimnames(data)
            data <- apply(data,2,scale)
            dimnames(data) <- dm
          }
          uclu <- unique(clu)
          if (input$diff_sel_test_method=="permutation") {
            sampmat <- t(sapply(1:as.numeric(input$diff_permu_num),function(i) {
              sample(clu)
            }))
          }
          if (input$diff_sel_test_method!="wilcox") {
            # Remove rows with 0 SSW
            bad_rows <- which(rowSums(sapply(unique(clu),function(i) {
              rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2)
            })) == 0)
            if (length(bad_rows) > 0) {
              data <- data[- bad_rows, ]
            }
          }
          res <- t(apply(data,1,function(i) {
            if (input$diff_sel_test_method=="wilcox") {
              suppressWarnings(tmptest <- wilcox.test(i[clu==uclu[1]],i[clu==uclu[2]],alternative = input$diff_test_alt_hyp,var.equal = T))
              c(tmptest$statistic,tmptest$p.value)
            } else if (input$diff_sel_test_method=="ttest") {
              tmptest <- t.test(i[clu==uclu[1]],i[clu==uclu[2]],alternative = input$diff_test_alt_hyp,var.equal = T)      
              c(tmptest$statistic,tmptest$p.value)
            } else if (input$diff_sel_test_method=="permutation") {
              tmptest <- t.test(i[clu==uclu[1]],i[clu==uclu[2]],alternative = input$diff_test_alt_hyp,var.equal = T)$statistic
              permut <- sapply(1:as.numeric(input$diff_permu_num),function(id) {
                sampclu <- sampmat[id,]
                samp1 <- i[sampclu==uclu[1]]
                samp2 <- i[sampclu==uclu[2]]
                mean1 <- mean(samp1)
                mean2 <- mean(samp2)
                var1 <- var(samp1)
                if (length(samp1) == 1) {
                  var1 <- 0
                }
                var2 <- var(samp2)
                if (length(samp2) == 1) {
                  var1 <- 0
                }
                n1 <- length(samp1)
                n2 <- length(samp2)
                (mean1 - mean2)/sqrt((1/n1+1/n2)*((n1-1)*var1+(n2-1)*var2)/(n1+n2-2))
              })
              if (input$diff_test_alt_hyp == "greater") {
                pval <- mean(tmptest < permut)      
              } else if (input$diff_test_alt_hyp == "less") {
                pval <- mean(tmptest > permut)      
              } else if (input$diff_test_alt_hyp == "two.sided") {
                pval <- mean(abs(tmptest) < abs(permut))      
              }
              c(tmptest,pval)
            }
          }))
          FDR <- p.adjust(res[,2],method="fdr")
          removeModal()
          return(data.frame(genomic_bin=row.names(data),statistics=res[,1],pvalue=res[,2],FDR=FDR,stringsAsFactors = F))
        }
      })
      removeModal()
    }
  })
  
  # Render differential analysis results panels
  output$diff_res_panels <- renderUI({
    if (! is.null(diff_test_res())) {
      tabsetPanel(
        tabPanel("Results",
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   h4("Differential test results table"),
                   downloadButton("diff_res_download", "Download results table"),
                   DT::dataTableOutput("diff_res_table")
                 )),
        tabPanel("Summary",
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   wellPanel(
                     h4("Significant bins summary"),
                     fluidRow(
                       column(6, sliderInput("diff_alpha", 
                                             "Level of significance (FDR): ", 
                                             min = 0.0001, 
                                             max = 0.5, 
                                             value = 0.05)), 
                       column(6, downloadButton("diff_res_sig_bed_download", "Download significant bins BED file"))
                     ),
                     textOutput("diff_sum_text")
                   ),
                   wellPanel(
                     radioButtons("diff_res_hist_val",
                                  "Histogram of: ",
                                  c("statistics", "p-value", "FDR")),
                     h4("Histogram summary"),
                     plotOutput("diff_sum_hist"), 
                     bsTooltip("diff_sum_hist", 
                               title = "Histogram of selected value", 
                               placement = "top", 
                               options = list(container = "body")), 
                     actionButton("diff_sum_hist_download", "Download plot")
                   ), 
                   wellPanel(
                     h4("p-value adjustment line plot"),
                     plotOutput("diff_sum_lineplot"), 
                     bsTooltip("diff_sum_lineplot", 
                               title = "Line plot of sorted p-values for all bins before and after FDR adjustment. Dashed line indicates the selected significance level. ", 
                               placement = "top", 
                               options = list(container = "body")), 
                     actionButton("diff_sum_lineplot_download", "Download plot")
                   )
                 )), 
        tabPanel("Volcano plot", 
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   wellPanel(
                     fluidRow(
                       column(6, 
                              selectInput(
                                'diff_fc_from', 
                                'Calculate fold change from group:', 
                                c("", input$diff_select_sample_groups)
                              )), 
                       column(6, 
                              selectInput(
                                'diff_fc_to', 
                                'To group:', 
                                c("", input$diff_select_sample_groups)
                              ))
                     ),
                     radioButtons(
                       'diff_volcano_y', 
                       'Vertical axis variable:', 
                       c('p-value', 'FDR')
                     ),
                     uiOutput('diff_volcano_run_button_ui')
                   ), 
                   uiOutput('diff_volcano_plot_ui')
                 )),
        tabPanel("Gene ontology", 
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   wellPanel(
                     wellPanel(
                       # GO options
                       fluidRow(
                         column(
                           6, 
                           radioButtons(
                             "diff_go_alpha_var", 
                             "Apply significance level cut-off to: ", 
                             c("FDR", 
                               "p-value")
                           )
                         ), 
                         column(
                           6, 
                           sliderInput(
                             "diff_go_alpha", 
                             "Level of significance: ", 
                             min = 0.0001, 
                             max = 0.5, 
                             value = 0.05
                           )
                         )
                       ),
                       checkboxInput(
                         "diff_go_use_logfc_cut", 
                         "Use logFC cut-off"
                       ),
                       uiOutput("diff_go_logfc_cut_ui"),
                       uiOutput("diff_go_gene_maxdist_ui"),
                       textOutput("diff_go_sig_genes_msg"), 
                       uiOutput("diff_go_external_tool_ui"), 
                       bsTooltip("diff_go_external_tool_ui", 
                                 title = "Use and external tool to analyze significant regions/genes in greater detail. ", 
                                 placement = "left", 
                                 options = list(container = "body")),
                       checkboxInput("diff_go_show_sig_bins_table", 
                                     "Show table mapping significant bins to nearest genes"), 
                       uiOutput('diff_go_sig_bins_table_ui')
                     ),
                     radioButtons("diff_go_ctrl", 
                                  "Control gene list: ", 
                                  c("All genes near selected genomic range",
                                    "All genes near BIRD default prediction range")), 
                     bsTooltip("diff_go_ctrl", 
                               title = "Using only genes near the selected genomic range as control genes is recommended as using all genes will greatly slow down the runtime. ", 
                               placement = "left", 
                               options = list(container = "body")),
                     radioButtons("diff_go_ontology", 
                                  "GO ontology: ", 
                                  c("Biological Process" = "BP", 
                                    "Molecular function" = "MF", 
                                    "Cellular component" = "CC")), 
                     sliderInput("diff_go_top_n", 
                                 "Number of top GO terms to return: ", 
                                 min = 10, 
                                 max = 500, 
                                 value = 20, 
                                 step = 10), 
                     actionButton("run_diff_go", "Find top GO terms")
                   ), 
                   textOutput('no_feasible_go_terms_warning'), 
                   uiOutput('diff_go_sel_res_ui')
                 ))
      )
    } else {
      p("Select sample groups and click on Perform Test to perform differential test on selected groups. ")
    }
  })
  
  # Differential test result table
  output$diff_res_table <- DT::renderDataTable({
    if (! is.null(diff_test_res())) {
      diff_test_res() %>% 
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = "none") %>% 
        formatRound(columns=c('statistics', 'pvalue', "FDR"), digits=4)
    }
  })
  
  # Differential test result download
  output$diff_res_download <- downloadHandler(
    filename = function() { "BIRD_predictions_differential_analysis.txt" },
    content = function(file) {
      write.table(diff_test_res(),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Differential test significant bins BED file download
  output$diff_res_sig_bed_download <- downloadHandler(
    filename = "BIRD_predictions_significant_differential_bins.bed", 
    content = function(file) {
      significant_bins <- diff_test_res()[diff_test_res()$FDR < input$diff_alpha, 1]
      write.table(parse_gbin(significant_bins), 
                  file, 
                  col.names = FALSE, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render text message for number of significant bins
  output$diff_sum_text <- renderText({
    if (!is.null(diff_test_res())) {
      paste("There are ",sum(diff_test_res()$FDR < input$diff_alpha),"significant bins, which is",round(mean(diff_test_res()$FDR < input$diff_alpha),digits=4) * 100,"percent of all selected genomic bins")
    }
  })
  
  diff_sum_hist <- reactive({
    if (!is.null(diff_test_res())) {
      if (input$diff_res_hist_val == "statistics") {
        g <- ggplot(diff_test_res(), aes(statistics)) + geom_histogram() 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="Statistics", y="Frequency")
        g
      } else if (input$diff_res_hist_val == "FDR") {
        g <- ggplot(diff_test_res(), aes(FDR)) + geom_histogram() 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="FDR", y="Frequency")
        g <- g + geom_vline(xintercept = input$diff_alpha, linetype = "dotted", colour = "blue")
        g
      } else if (input$diff_res_hist_val == "p-value") {
        g <- ggplot(diff_test_res(), aes(pvalue)) + geom_histogram() 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="p-value", y="Frequency")
        g
      }
    }
  })
  
  # Render summary histogram for differential test result
  output$diff_sum_hist <- renderPlot({
    diff_sum_hist()
  })
  
  observeEvent(input$diff_sum_hist_download, {
    download_plot(diff_sum_hist())
  })
  
  diff_sum_lineplot <- reactive({
    g <- ggplot(diff_test_res()[order(diff_test_res()$pvalue), ], aes(1:nrow(diff_test_res())))
    g <- g + geom_line(aes(y=pvalue, color = "red")) + geom_line(aes(y=FDR, color = "blue"))
    g <- g + geom_hline(yintercept = input$diff_alpha, linetype = "dotted", colour = "blue")
    g <- g + theme(panel.background = element_blank())
    g <- g + labs(x="Genomic bins sorted by p-values", y="Values")
    g <- g + scale_colour_manual(name = 'Values', 
                                 values = c('blue'='blue','red'='red'), 
                                 labels = c('FDR','p-value'))
    g
  })
  
  # Render summary line plot for differential test result
  output$diff_sum_lineplot <- renderPlot({
    diff_sum_lineplot()
  })
  
  observeEvent(input$diff_sum_lineplot_download, {
    download_plot(diff_sum_lineplot())
  })
  
  # Render UI for differential test volcano plot run button
  output$diff_volcano_run_button_ui <- renderUI({
    if ((input$diff_fc_from == "") || (input$diff_fc_to == "")) {
      p("Please select 2 groups for fold change calculation. ")
    } else if (input$diff_fc_from == input$diff_fc_to) {
      p("Selected groups cannot be the same group. Please select 2 different groups. ")
    } else {
      actionButton("diff_volcano_run_button", "Make volcano plot")
    }
  })
  
  # Calculate fold change
  diff_logfc <- reactive({
    if ((! is.null(input$diff_volcano_run_button)) && (input$diff_volcano_run_button > 0)) {
      isolate({
        data <- pred_mat()[diff_test_res()$genomic_bin, ]
        logFC <- apply(data, 1, function(x) {
          mean(x[diff_sample_groups() == input$diff_fc_to]) - mean(x[diff_sample_groups() == input$diff_fc_from])
        })
        return(logFC)
      })
    }
  })
  
  # Render UI for differential test volcano plot
  output$diff_volcano_plot_ui <- renderUI({
    if ((! is.null(diff_logfc())) && (input$diff_volcano_run_button > 0)) {
      tagList(
        tags$div(
          id = "diff_volcano_params",
          fluidRow(
            column(6, 
                   sliderInput(
                     "diff_volcano_alpha", 
                     paste("Select", isolate(input$diff_volcano_y), "significance level"), 
                     min = 0, 
                     max = 1, 
                     value = 0.05
                   )), 
            column(6, 
                   sliderInput(
                     "diff_volcano_logfc_threshold", 
                     "Select log(FC) threshold", 
                     min = 0, 
                     max = ceiling(max(abs(diff_logfc()))), 
                     value = min(ceiling(max(abs(diff_logfc()))), 1), 
                     step = 0.01
                   ))
          )
        ), 
        bsTooltip("diff_volcano_params", 
                  title = "These are cut-offs beyond which the points (genomic bins) in the volcano plot will be colored and annotated as significantly more or less accessible. ", 
                  placement = "top", 
                  options = list(container = "body")),
        h4("Volcano plot of differential test results"),
        plotOutput("diff_volcano_plot", brush = "diff_volcano_plot_brush"), 
        bsTooltip("diff_volcano_plot", 
                  title = paste0("Each data point in the plot refers to a genomic bin. The plot shows the -log<sub>10</sub>", input$diff_volcano_y, " plotted against log<sub>2</sub> fold change"), 
                  placement = "top", 
                  options = list(container = "body")),
        actionButton("diff_volcano_plot_download", "Download plot"),
        hr(), 
        h4("Volcano plot brushed genomic bins"),
        downloadButton("diff_volcano_plot_brushed_download", "Download brushed points table"), 
        DT::dataTableOutput("diff_volcano_plot_brushed")
      )
    }
  })
  
  diff_volcano_plot <- reactive({
    req(input$diff_volcano_alpha)
    req(input$diff_volcano_logfc_threshold)
    if (input$diff_volcano_run_button > 0) {
      isolate({
        if (input$diff_volcano_y == 'FDR') {
          df <- data.frame(pvalue = - log10(diff_test_res()$FDR), 
                           logFC = diff_logfc())
        } else if (input$diff_volcano_y == 'p-value') {
          df <- data.frame(pvalue = - log10(diff_test_res()$pvalue), 
                           logFC = diff_logfc())
        }
        change <- rep('non-significant', length(diff_logfc()))
        change[(df$pvalue > - log10(input$diff_volcano_alpha)) & (df$logFC > input$diff_volcano_logfc_threshold)] <- 'more accessible'
        change[(df$pvalue > - log10(input$diff_volcano_alpha)) & (df$logFC < - input$diff_volcano_logfc_threshold)] <- 'less accessible'
        df$change <- change
        color <- c('red', 'blue', 'grey')
        names(color) <- c('more accessible', 'less accessible', 'non-significant')
        g <- ggplot(df, mapping = aes(x = logFC, y = pvalue, color = change))
        g <- g + geom_point()
        g <- g + scale_color_manual(values = color)
        g <- g + xlab(expression(log[2]*FC))
        if (input$diff_volcano_y == 'FDR') {
          g <- g + ylab(expression(-log[10]*FDR))
        } else if (input$diff_volcano_y == 'p-value') {
          g <- g + ylab(expression(-log[10]*pvalue))
        }
        # Remove grid lines and add axis lines
        g <- g + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                       panel.background = element_blank(), axis.line = element_line(colour = "black"))
        g
      })
    }
  })
  
  # Render differential test volcano plot
  output$diff_volcano_plot <- renderPlot({
    diff_volcano_plot()
  })
  
  observeEvent(input$diff_volcano_plot, {
    download_plot(diff_volcano_plot())
  })
  
  diff_volcano_plot_brushed_table <- reactiveVal()
  
  # Make volcano plot brushed points table
  observeEvent(input$diff_volcano_plot_brush, {
    if (input$diff_volcano_y == 'FDR') {
      df <- data.frame(genomic_bin = diff_test_res()$genomic_bin, 
                       pvalue = - log10(diff_test_res()$FDR), 
                       logFC = diff_logfc())
    } else if (input$diff_volcano_y == 'p-value') {
      df <- data.frame(genomic_bin = diff_test_res()$genomic_bin, 
                       pvalue = - log10(diff_test_res()$pvalue), 
                       logFC = diff_logfc())
    }
    df <- brushedPoints(df, input$diff_volcano_plot_brush)
    gbin_names <- df$genomic_bin
    df <- parse_gbin(gbin_names)
    brushed_gbin_tss <- gbin_tss[gbin_names, ]
    brushed_gbin_snp <- gbin_snp[gbin_names, ]
    df$nearest_gene <- as.factor(brushed_gbin_tss$gene)
    df$distance_to_gene <- brushed_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(brushed_gbin_tss$relative_position_to_tss)
    df$nearest_snp <- brushed_gbin_snp$snp_id
    df$snp_position <- brushed_gbin_snp$position
    df$snp_associated_trait <- brushed_gbin_snp[, 3]
    df$distance_to_snp <- brushed_gbin_snp$distance
    diff_volcano_plot_brushed_table(df)
    output$diff_volcano_plot_brushed <- DT::renderDataTable(df, 
                                                            rownames = FALSE,
                                                            filter = list(position = 'top', clear = FALSE), 
                                                            selection = 'single', 
                                                            options = list(scrollX = TRUE))
  })
  
  # Differential test volcano plot brushed points table file download
  output$diff_volcano_plot_brushed_download <- downloadHandler(
    filename = "Differential_test_volcano_brushed_points.txt", 
    content = function(file) {
      write.table(diff_volcano_plot_brushed_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render UI for choosing logFC cut-off
  output$diff_go_logfc_cut_ui <- renderUI({
    if (input$diff_go_use_logfc_cut) {
      wellPanel(
        fluidRow(
          column(
            4,
            selectInput(
              'diff_go_fc_from', 
              'Use fold change from group:', 
              c("", input$diff_select_sample_groups)
            )
          ), 
          column(
            4, 
            selectInput(
              'diff_go_fc_to', 
              'To group:', 
              c("", input$diff_select_sample_groups)
            )
          ),
          column(
            4, 
            uiOutput("diff_go_fc_confirm_ui")
          )
        ), 
        uiOutput("diff_go_logfc_cut_slider"), 
        radioButtons(
          "diff_go_use_which_sig_bins", 
          "Use genomic bins that are:", 
          choices = c("Both significantly more accessible and less accessible" = "both", 
                      "Significantly more accessible" = "more", 
                      "Significantly less accessible" = "less")
        )
      )
    }
  })
  
  output$diff_go_fc_confirm_ui <- renderUI({
    if ((input$diff_go_fc_from == "") || (input$diff_go_fc_to == "")) {
      p("Please select 2 groups for fold change calculation. ")
    } else if (input$diff_go_fc_from == input$diff_go_fc_to) {
      p("Selected groups cannot be the same group. Please select 2 different groups. ")
    } else {
      actionButton("diff_go_fc_confirm_groups", "Confirm groups")
    }
  })
  
  # Calculate fold change
  diff_go_logfc <- reactive({
    if ((! is.null(input$diff_go_fc_confirm_groups)) && (input$diff_go_fc_confirm_groups > 0)) {
      isolate({
        data <- pred_mat()[diff_test_res()$genomic_bin, ]
        logFC <- apply(data, 1, function(x) {
          mean(x[diff_sample_groups() == input$diff_go_fc_to]) - mean(x[diff_sample_groups() == input$diff_go_fc_from])
        })
        return(logFC)
      })
    }
  })
  
  output$diff_go_logfc_cut_slider <- renderUI({
    if ((! is.null(input$diff_go_fc_confirm_groups)) && (input$diff_go_fc_confirm_groups > 0)) {
      isolate({
        sliderInput(
          "diff_go_logfc_cut",
          "LogFC threshold: ", 
          max = max(abs(diff_go_logfc())), 
          min = 0, 
          value = min(1, max(abs(diff_go_logfc())))
        )
      })
    }
  })
  
  # Significant bins used for GO analysis
  diff_go_sig_bins <- reactive({
    significant_bins <- diff_test_res()
    if ((input$diff_go_use_logfc_cut) && (! is.null(input$diff_go_fc_confirm_groups)) && (input$diff_go_fc_confirm_groups > 0)) {
      if (input$diff_go_use_which_sig_bins == "both") {
        significant_bins <- significant_bins[abs(diff_go_logfc()) > input$diff_go_logfc_cut, ]
      } else if (input$diff_go_use_which_sig_bins == "less") {
        significant_bins <- significant_bins[diff_go_logfc() < - input$diff_go_logfc_cut, ]
      } else if (input$diff_go_use_which_sig_bins == "more") {
        significant_bins <- significant_bins[diff_go_logfc() > input$diff_go_logfc_cut, ]
      }
    }
    if (input$diff_go_alpha_var == "FDR") {
      significant_bins <- significant_bins[significant_bins$FDR < input$diff_go_alpha, 1]
    } else {
      significant_bins <- significant_bins[significant_bins$pvalue < input$diff_go_alpha, 1]
    }
    significant_bins
  })
  
  output$diff_go_gene_maxdist_ui <- renderUI({
    if ((!is.null(diff_test_res())) && (input$run_diff_test > 0)) {
      isolate({
        tagList(
          sliderInput("diff_go_gene_maxdist", 
                      "Maximum distance limit of bins to nearest gene TSS",
                      min = 0, 
                      max = 1e6, 
                      value = 500, 
                      post = "bp",
                      step = 100), 
          plotlyOutput("diff_go_gene_dist_plot")
        )
      })
    }
  })
  
  diff_go_nearest_genes <- reactive({
    gbin_names <- diff_go_sig_bins()
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= input$diff_go_gene_maxdist, ]$gene)
    nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    nearest_genes
  })
  
  output$diff_go_gene_dist_plot <- renderPlotly({
    gbin_names <- diff_go_sig_bins()
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$diff_go_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$diff_go_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Significant genomic bins distance distribution to nearest gene TSS")
    ggplotly(g)
  })
  
  # Render text message for number of significant bins and nearest genes
  output$diff_go_sig_genes_msg <- renderText({
    if (!is.null(diff_test_res())) {
      significant_bins <- diff_go_sig_bins()
      sig_genes <- diff_go_nearest_genes()
      paste("There are ", 
            length(significant_bins[! is.na(significant_bins)]), 
            "significant bins, which maps to", 
            length(sig_genes), 
            "nearest genes that will be used in GO term enrichment analysis. ")
    }
  })
  
  output$diff_go_external_tool_ui <- renderUI({
    tagList(
      fluidRow(
        column(6, wellPanel(uiOutput("diff_go_ext_gene_func"))), 
        column(6, wellPanel(uiOutput("diff_go_ext_gbin_func"))), 
      )
    )
  })
  
  output$diff_go_ext_gene_func <- renderUI({
    significant_bins <- diff_go_sig_bins()
    sig_genes <- diff_go_nearest_genes()
    sig_genes_text <- paste(sig_genes, collapse = "\n")
    if (sig_genes_text == "") {
      sig_genes_text <- " "
    }
    tagList(
      h4("Gene set analysis"), 
      actionButton(
        inputId = "diff_enrichr_link", 
        label = "Go to Enrichr", 
        onclick = "window.open('https://maayanlab.cloud/Enrichr/')", 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(),
      rclipButton(
        inputId = "diff_go_sig_genes_clipbtn", 
        label = "Copy significant genes", 
        clipText = sig_genes_text, 
        icon = icon("clipboard"), 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(), 
      downloadButton("diff_go_ext_genes_txt_download", "Download significant genes text file", style = "width: 100%; border: 1px solid white;")
    )
  })
  
  output$diff_go_ext_gbin_func <- renderUI({
    df <- parse_gbin(diff_go_sig_bins())
    clip_bed <- paste(capture.output(write.table(df, 
                                                 col.names = FALSE, 
                                                 row.names = FALSE, 
                                                 quote = FALSE, 
                                                 sep = "\t")), 
                      collapse = "\n")
    if (clip_bed == "") {
      clip_bed <- " "
    }
    tagList(
      h4("Genomic regions analysis"), 
      actionButton(
        inputId = "diff_great_link", 
        label = "Go to GREAT", 
        onclick = "window.open('https://great.stanford.edu/great/public/html/')", 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(),
      rclipButton(
        inputId = "diff_go_sig_gbins_clipbtn", 
        label = "Copy significant bins BED", 
        clipText = clip_bed, 
        icon = icon("clipboard"), 
        style = "width: 100%; border: 1px solid white;"
      ), 
      br(), 
      downloadButton("diff_go_ext_bed_download", "Download significant bins BED", style = "width: 100%; border: 1px solid white;")
    )
  })
  
  output$diff_go_ext_genes_txt_download <- downloadHandler(
    filename = "Significant_genes.txt", 
    content = function(file) {
      significant_bins <- diff_go_sig_bins()
      sig_genes <- diff_go_nearest_genes()
      writeLines(sig_genes, file)
    }
  )
  
  output$diff_go_ext_bed_download <- downloadHandler(
    filename = "Significant_bins.bed", 
    content = function(file) {
      write.table(parse_gbin(diff_go_sig_bins()), 
                  file, 
                  col.names = FALSE, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # UI for significant bins table
  output$diff_go_sig_bins_table_ui <- renderUI({
    if (input$diff_go_show_sig_bins_table) {
      tagList(
        h4("Significant genomic bins and their nearest genes table"),
        downloadButton('diff_go_sig_bins_table_download', "Download significant bins and nearest genes table"),
        DT::dataTableOutput('diff_go_sig_bins_table')
      )
    }
  })
  
  # Reactive significant bins table
  diff_go_sig_bins_table <- reactive({
    significant_bins <- diff_go_sig_bins()
    df <- parse_gbin(significant_bins)
    sig_gbin_tss <- gbin_tss[significant_bins, ]
    df$nearest_gene <- as.factor(sig_gbin_tss$gene)
    df$distance_to_gene <- sig_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(sig_gbin_tss$relative_position_to_tss)
    df
  })
  
  # Differential test significant bins and nearest genes file download
  output$diff_go_sig_bins_table_download <- downloadHandler(
    filename = "Significant_differential_bins_genes.txt", 
    content = function(file) {
      write.table(diff_go_sig_bins_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render table showing significant bins and nearest genes
  output$diff_go_sig_bins_table <- DT::renderDataTable(diff_go_sig_bins_table() %>%
                                                         datatable(rownames = FALSE,
                                                                   filter = list(position = 'top', clear = FALSE), 
                                                                   selection = "none", 
                                                                   options = list(scrollX = TRUE)))
  
  # Record whether there is no feasible GO terms found for current submission
  no_feasible_go_terms <- reactiveVal(FALSE)
  
  # Warning message when there is no feasible GO terms found for current submission
  output$no_feasible_go_terms_warning <- renderText({
    if (no_feasible_go_terms()) {
      paste("No enrichment can pe performed - no genes have feasible GO mapping. \nPlease include more genes. ")
    }
  })
  
  # Conditional MLE odds ratio calculation
  cond_or <- function(x) {
    m <- sum(x[, 1L])
    n <- sum(x[, 2L])
    k <- sum(x[1L, ])
    x <- x[1L, 1L]
    lo <- max(0L, k - n)
    hi <- min(k, m)
    
    support <- lo:hi #Interval of definition of Hypergeometric Distribution
    
    logdc <- dhyper(support, m, n, k, log = TRUE) #log of Hypergeometric Probability Function
    
    dnhyper <- function(ncp) {
      d <- logdc + log(ncp) * support
      d <- exp(d - max(d))
      d/sum(d)
    }
    
    mnhyper <- function(ncp) {
      if (ncp == 0) 
        return(lo)
      if (ncp == Inf) 
        return(hi)
      sum(support * dnhyper(ncp))
    }
    
    mle <- function(x) {
      if (x == lo) 
        return(0)
      if (x == hi) 
        return(Inf)
      mu <- mnhyper(1)
      if (mu > x) 
        uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
      else if (mu < x) 
        1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 
                                                  1))$root
      else 1
    }
    
    mle(x)
  }
  
  # Unconditional MLE odds ratio calculation
  uncond_or <- function(x) {
    x[1, 1] * x[2, 2] / (x[1, 2] * x[2, 1])
  }
  
  # Find top GO terms associated with genes near significant differential bins
  diff_top_go_terms <- reactive({
    if ((! is.null(input$run_diff_go)) && (input$run_diff_go > 0)) {
      isolate({
        showModal(modalDialog("Finding top GO terms...", footer = NULL, easyClose = TRUE, size = "s"))
        significant_bins <- diff_go_sig_bins()
        sig_genes <- diff_go_nearest_genes()
        ctrl_genes <- NULL
        if (input$diff_go_ctrl == "All genes near BIRD default prediction range") {
          ctrl_genes <- unique(gbin_tss$gene)
        } else if (input$diff_go_ctrl == "All genes near selected genomic range") {
          ctrl_genes <- unique(gbin_tss[rownames(pred_mat()), ]$gene)
        }
        ctrl_genes <- ctrl_genes[! is.na(ctrl_genes)]
        top_go_table <- gene_GO(sig_genes, ctrl_genes, top = input$diff_go_top_n, go_ontology = input$diff_go_ontology)
        if (is.null(top_go_table)) {
          no_feasible_go_terms(TRUE)
        } else {
          no_feasible_go_terms(FALSE)
        }
        removeModal()
        return(top_go_table)
      })
    }
  })
  
  # Render UI for selecting differential analysis results to display
  output$diff_go_sel_res_ui <- renderUI({
    if (! is.null(diff_top_go_terms())) {
      tagList(
        selectInput(
          'diff_go_sel_res', 
          'Select GO result to show: ', 
          c('Top GO terms table', 
            'GO terms p-value graph', 
            'GO terms FDR graph', 
            'Volcano plot', 
            'GO terms bar plot')
        ), 
        uiOutput('diff_go_res_ui')
      )
    }
  })
  
  # Render Ui for displaying GO analysis results
  output$diff_go_res_ui <- renderUI({
    if (input$diff_go_sel_res == 'Top GO terms table') {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Top GO terms table")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_table_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_table_info",
          title = "<h4>Top GO terms table</h4>",
          content = do.call(paste0, 
                            popover_contents$go_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        br(),
        downloadButton('diff_go_table_download', "Download top GO terms table"),
        DT::dataTableOutput("diff_go_table")
      )
    } else if (input$diff_go_sel_res == 'GO terms p-value graph') {
      tagList(
        sliderInput(
          'diff_go_pval_graph_alpha', 
          'Significance level', 
          min = 0.0001, 
          max = 1, 
          value = 0.05
        ), 
        # bsTooltip("diff_go_pval_graph_alpha", 
        #           title = "Control position of p-value threshold (dashed line)", 
        #           placement = "top", 
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms p-value graph")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_pval_graph_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_pval_graph_info",
          title = "<h4>GO terms p-value graph</h4>",
          content = do.call(paste0, 
                            popover_contents$go_pval_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotlyOutput('diff_go_pval_graph'), 
        bsTooltip("diff_go_pval_graph", 
                  title = "Graph of -log<sub>10</sub>p-values vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ", 
                  placement = "top", 
                  options = list(container = "body")),
        hr(), 
        h4("GO terms p-value graph selected points"),
        DT::dataTableOutput('diff_go_pval_graph_brushed')
      )
    } else if (input$diff_go_sel_res == 'GO terms FDR graph') {
      tagList(
        sliderInput(
          'diff_go_fdr_graph_alpha', 
          'Significance level', 
          min = 0.0001, 
          max = 1, 
          value = 0.05
        ), 
        # bsTooltip("diff_go_fdr_graph_alpha", 
        #           title = "Control position of FDR threshold (dashed line)", 
        #           placement = "top", 
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms FDR graph")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_fdr_graph_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_fdr_graph_info",
          title = "<h4>GO terms FDR graph</h4>",
          content = do.call(paste0, 
                            popover_contents$go_fdr_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotlyOutput('diff_go_fdr_graph'), 
        bsTooltip("diff_go_fdr_graph", 
                  title = "Graph of -log<sub>10</sub>FDR vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ", 
                  placement = "top", 
                  options = list(container = "body")),
        hr(), 
        h4("GO terms FDR graph selected points"),
        DT::dataTableOutput('diff_go_fdr_graph_brushed')
      )
    } else if (input$diff_go_sel_res == 'Volcano plot') {
      max_odds_ratio <- max(diff_top_go_terms_df()$odds_ratio_pseudo[is.finite(diff_top_go_terms_df()$odds_ratio_pseudo)])
      tagList(
        tags$div(
          id = "diff_go_volcano_plot_params",
          fluidRow(
            column(6, 
                   sliderInput(
                     'diff_go_volcano_plot_alpha', 
                     'Significance level', 
                     min = 0.0001, 
                     max = 1, 
                     value = 0.05
                   )),
            column(6, 
                   sliderInput(
                     'diff_go_volcano_plot_or_threshold', 
                     'Odds ratio threshold',
                     min = 0, 
                     max = max_odds_ratio, 
                     value = min(1, max_odds_ratio)
                   ))
          )
        ),
        # bsTooltip("diff_go_volcano_plot_params", 
        #           title = "Adjust these cut-offs to color significant vs. non-significant GO terms differently in volcano plot. ", 
        #           placement = "top", 
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms volcano plot")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_volcano_plot_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_volcano_plot_info",
          title = "<h4>GO terms volcano plot</h4>",
          content = do.call(paste0, 
                            popover_contents$go_volcano_plot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotlyOutput('diff_go_volcano_plot'), 
        bsTooltip("diff_go_volcano_plot", 
                  title = "For each GO term, -log<sub>10</sub>p-value is plotted against odds ratio (computed with pseudo-count). ", 
                  placement = "top", 
                  options = list(container = "body"))
      )
    } else if (input$diff_go_sel_res == 'GO terms bar plot') {
      tagList(
        radioButtons(
          "diff_go_barplot_var", 
          "Bar plot value: ", 
          choices = c("- log10 p-value" = "p-value", 
                      "- log10 FDR" = "FDR")
        ),
        fluidRow(
          column(
            width = 4, 
            radioButtons(
              "diff_go_barplot_sort_by", 
              label = "Sort bar plot by: ", 
              choices = c("Default order" = "default", 
                          "Decreasing value" = "decrease", 
                          "Increasing value" = "increase", 
                          "Custom order" = "custom")
            )
          ), 
          column(
            width = 8, 
            uiOutput("diff_go_barplot_sort_details_ui")
          )
        ), 
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "diff_go_barplot_top_cut", 
              "Number of top GO terms to show: ", 
              min = 2, 
              max = nrow(diff_top_go_terms()), 
              value = min(10, nrow(diff_top_go_terms())), 
              step = 1
            )
          ), 
          column(
            width = 4, 
            sliderInput(
              "diff_go_barplot_bar_width", 
              "Bar width: ", 
              min = 0.1, 
              max = 1.0, 
              value = 0.5,
              step = 0.1
            )
          ),
          column(
            width = 4, 
            uiOutput("diff_go_barplot_xlim_ui")
          )
        ),
        checkboxInput(
          "diff_go_barplot_show_des", 
          "Show GO term descriptions", 
          value = FALSE
        ),
        uiOutput("diff_go_barplot_des_details_ui"),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms bar plot")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_barplot_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_barplot_info",
          title = "<h4>GO terms bar plot</h4>",
          content = do.call(paste0, 
                            popover_contents$go_barplot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotOutput("diff_go_barplot"), 
        actionButton("diff_go_barplot_download", "Download plot")
      )
    }
  })
  
  # Render UI for bar plot xlim
  output$diff_go_barplot_xlim_ui <- renderUI({
    req(input$diff_go_barplot_var)
    req(input$diff_go_barplot_sort_by)
    req(input$diff_go_barplot_top_cut)
    # Set bar values
    if (input$diff_go_barplot_var == "p-value") {
      df <- data.frame(go_term = diff_top_go_terms()$GO.ID, 
                       value = - log10(diff_top_go_terms()$pvalue))
    } else if (input$diff_go_barplot_var == "FDR") {
      df <- data.frame(go_term = diff_top_go_terms()$GO.ID, 
                       value = - log10(diff_top_go_terms()$FDR))
    }
    # Sort barplot
    if (input$diff_go_barplot_sort_by == "decrease") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value)])
    } else if (input$diff_go_barplot_sort_by == "increase") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value, decreasing = TRUE)])
    } else if (input$diff_go_barplot_sort_by == "custom") {
      df$go_term <- factor(df$go_term, levels = rev(diff_go_barplot_custom_order()))
    }
    # Top n bars cut-off
    df <- df[order(df$go_term)[1:input$diff_go_barplot_top_cut], ]
    sliderInput(
      "diff_go_barplot_xlim", 
      "Minimum x value: ", 
      min = 0, 
      max = min(df$value), 
      value = min(df$value) - (max(df$value) - min(df$value)) / 3
    )
  })
  
  # Render UI for bar plot show description details
  output$diff_go_barplot_des_details_ui <- renderUI({
    if (input$diff_go_barplot_show_des) {
      wellPanel(
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "diff_go_barplot_show_des_size", 
              "GO term description font size", 
              min = 1, 
              max = 10, 
              value = 4
            )
          ),
          column(
            width = 4, 
            radioButtons(
              "diff_go_barplot_show_des_opt", 
              "GO description display options", 
              choices = c("Show full description", 
                          "Show truncated description", 
                          "Split description into multiple lines")
            )
          ), 
          column(
            width = 4, 
            uiOutput("diff_go_barplot_show_des_opt_format")
          )
        )
      )
    }
  })
  
  # Render UI for bar plot GO description formatting options
  output$diff_go_barplot_show_des_opt_format <- renderUI({
    if (input$diff_go_barplot_show_des_opt == "Show truncated description") {
      tagList(
        radioButtons(
          "diff_go_barplot_des_trim_mode", 
          "Truncation mode: ", 
          choices = c("Fixed length", "Proportional to bar length"), 
          selected = "Fixed length"
        ), 
        sliderInput(
          "diff_go_barplot_des_trim_len", 
          "Truncation length: ", 
          min = 0, max = 1, value = 0.8, step = 0.01
        )
      )
    } else if (input$diff_go_barplot_show_des_opt == "Split description into multiple lines") {
      tagList(
        radioButtons(
          "diff_go_barplot_des_split_mode", 
          "Split mode: ", 
          choices = c("Fixed line length", "Line length proportional to bar length"),
          selected = "Fixed line length"
        ), 
        sliderInput(
          "diff_go_barplot_des_split_len", 
          "Line length: ", 
          min = 0, max = 1, value = 0.5, step = 0.01
        )
      )
    }
  })
  
  # Render UI for bar plot sort details
  output$diff_go_barplot_sort_details_ui <- renderUI({
    if (input$diff_go_barplot_sort_by == "custom") {
      fluidRow(
        column(
          width = 6, 
          radioButtons(
            "diff_go_barplot_custom_sort_method", 
            "Input custom order by: ", 
            choices = c("Text input", 
                        "Drag to sort")
          )
        ), 
        column(
          width = 6, 
          uiOutput("diff_go_barplot_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for GO bar plot custom sorting options
  output$diff_go_barplot_custom_sort_ui <- renderUI({
    if (input$diff_go_barplot_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "diff_go_barplot_custom_sort_text", 
          "Input GO IDs separated by line breaks: "
        ),
        fileInput(
          "diff_go_barplot_custom_sort_txt_file", 
          "Upload txt file indicating sort order", 
          accept = "text/plain"
        ),
        actionButton("submit_diff_go_barplot_custom_sort", "Confirm order"), 
        textOutput("diff_go_barplot_custom_sort_submission_text")
      )
    } else if (input$diff_go_barplot_custom_sort_method == "Drag to sort") {
      actionButton("diff_go_barplot_custom_sort_drag_button", "Sort samples")
    }
  })
  
  # Update GO bar plot custom sort text area input value based on uploaded file
  observeEvent(input$diff_go_barplot_custom_sort_txt_file, {
    if (! is.null(input$diff_go_barplot_custom_sort_txt_file)) {
      go_sort_text <- paste(readLines(input$diff_go_barplot_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "diff_go_barplot_custom_sort_text", 
        value = go_sort_text
      )
    }
  })
  
  # Disease bar plot custom order value
  diff_go_barplot_custom_order <- reactiveVal()
  
  # Update default custom order when GO results are computed
  observeEvent(diff_top_go_terms(), {
    diff_go_barplot_custom_order(diff_top_go_terms()$GO.ID)
  })
  
  # Render pop-up modal for GO bar plot custom drag sort
  observeEvent(input$diff_go_barplot_custom_sort_drag_button, {
    if (is.null(diff_go_barplot_custom_order())) {
      go_order <- diff_top_go_terms()$GO.ID
    } else {
      go_order <- diff_go_barplot_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = go_order,
      input_id = "go_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("submit_diff_go_barplot_custom_sort", "Confirm order"), 
        textOutput("diff_go_barplot_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for GO bar plot custom sort
  output$diff_go_barplot_custom_sort_submission_text <- renderText({
    diff_go_barplot_custom_sort_submission_text()
  })
  
  # Process GO bar plot custom sort request
  diff_go_barplot_custom_sort_submission_text <- eventReactive(input$submit_diff_go_barplot_custom_sort, {
    if (input$diff_go_barplot_custom_sort_method == "Text input") {
      # Read GO terms from submitted text
      go_terms <- unlist(strsplit(input$diff_go_barplot_custom_sort_text, split = "\n"))
      go_terms <- sapply(go_terms, function(go) {
        go <- gsub(" ", "", go)
        go <- gsub("\t", "", go)
        go
      })
      go <- go[go != ""]
      # Check for non-selected GO terms
      extra <- go_terms[! (go_terms %in% diff_top_go_terms()$GO.ID)]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected GO terms:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated GO terms
      counts <- sapply(diff_top_go_terms()$GO.ID, function(go) {
        sum(go_terms %in% go)
      })
      if (any(counts > 1)) {
        return(paste("The following GO terms are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing GO terms
      if (any(counts == 0)) {
        return(paste("The following GO terms are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      diff_go_barplot_custom_order(go_terms)
      return(paste("Sorting complete!"))
    } else if (input$diff_go_barplot_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      diff_go_barplot_custom_order(input$go_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  diff_go_barplot <- reactive({
    req(input$diff_go_barplot_xlim)
    # Set bar values
    if (input$diff_go_barplot_var == "p-value") {
      df <- data.frame(go_term = diff_top_go_terms()$GO.ID, 
                       go_des =  diff_top_go_terms()$Term, 
                       value = - log10(diff_top_go_terms()$pvalue))
    } else if (input$diff_go_barplot_var == "FDR") {
      df <- data.frame(go_term = diff_top_go_terms()$GO.ID, 
                       go_des =  diff_top_go_terms()$Term, 
                       value = - log10(diff_top_go_terms()$FDR))
    }
    # Sort barplot
    if (input$diff_go_barplot_sort_by == "decrease") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value)])
    } else if (input$diff_go_barplot_sort_by == "increase") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value, decreasing = TRUE)])
    } else if (input$diff_go_barplot_sort_by == "custom") {
      df$go_term <- factor(df$go_term, levels = rev(diff_go_barplot_custom_order()))
    }
    # Top n bars cut-off
    df <- df[order(df$go_term)[1:input$diff_go_barplot_top_cut], ]
    if (input$diff_go_barplot_show_des) {
      req(input$diff_go_barplot_show_des_opt)
      # Show GO descriptions
      # Get description lengths
      des_width <- sapply(df$go_des, function(des){
        strwidth(des, units = "inches", family = "sans")
      })
      if (input$diff_go_barplot_show_des_opt == "Show truncated description") {
        req(input$diff_go_barplot_des_trim_mode)
        req(input$diff_go_barplot_des_trim_len)
        abbrev_len <- strwidth("...", units = "inches", family = "sans")
        if (input$diff_go_barplot_des_trim_mode == "Fixed length") {
          trim_len <- rep(abbrev_len + input$diff_go_barplot_des_trim_len * (max(des_width) - abbrev_len), length(des_width))
          names(trim_len) <- df$go_des
        } else {
          bar_len <- df$value - input$diff_go_barplot_xlim
          max_len <- abbrev_len + input$diff_go_barplot_des_trim_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - abbrev_len)
          trim_len <- max_len * bar_len / (max(df$value) - input$diff_go_barplot_xlim)
          names(trim_len) <- df$go_des
        }
        # Trim terms
        trim_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= trim_len[term]) {
            return(term)
          } else {
            # Find approximate nchar to trim
            keep_nchar <- floor(nchar(term) * (trim_len[term] - abbrev_len) / des_width[term])
            while (strwidth(substring(term, 1, keep_nchar), units = "inches", family = "sans") > trim_len[term] - abbrev_len) {
              keep_nchar <- keep_nchar - 1
            }
            return(paste0(substring(term, 1, keep_nchar), "..."))
          }
        })
        df$go_des <- trim_terms
      } else if (input$diff_go_barplot_show_des_opt == "Split description into multiple lines") {
        req(input$diff_go_barplot_des_split_mode)
        req(input$diff_go_barplot_des_split_len)
        if (input$diff_go_barplot_des_split_mode == "Fixed line length") {
          min_len <- max(des_width) / 2
          line_len <- rep(min_len + input$diff_go_barplot_des_split_len * 
                            (max(des_width) - min_len), length(des_width))
          names(line_len) <- df$go_des
        } else {
          bar_len <- df$value - input$diff_go_barplot_xlim
          min_len <- max(des_width) / 2
          max_len <- min_len + input$diff_go_barplot_des_split_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - min_len)
          line_len <- sapply(df$go_des, function(term) {
            ratio <- bar_len[df$go_des == term] / (max(df$value) - input$diff_go_barplot_xlim)
            if ((max(df$value) - input$diff_go_barplot_xlim) == 0) {
              ratio <- 1
            }
            max_len * ratio
          })
          names(line_len) <- df$go_des
        }
        # Format terms
        format_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= line_len[term]) {
            return(term)
          } else {
            # Find approximate nchar in a single line
            remain_term <- term
            split_lines <- c()
            line_nchar <- floor(nchar(term) * line_len[term] / des_width[term])
            while (strwidth(remain_term, units = "inches", family = "sans") > line_len[term] &&
                   ! -1 %in% unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))) {
              breaks <- unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))
              breaks <- breaks[!(breaks + 1) %in% breaks]
              break_i <- if (length(breaks) && min(breaks) <= line_nchar) {
                which.max(breaks[breaks <= line_nchar])
              } else {1}
              while (strwidth(trimws(substring(remain_term, 1, breaks[break_i])), 
                              units = "inches", family = "sans") > line_len[term] &&
                     break_i > 1) {
                break_i <- break_i - 1
              }
              split_lines <- c(split_lines, trimws(substring(remain_term, 1, breaks[break_i])))
              remain_term <- trimws(substring(remain_term, breaks[break_i] + 1, ))
            }
            split_lines <- c(split_lines, remain_term)
            return(paste(split_lines, collapse = "\n"))
          }
        })
        df$go_des <- format_terms
      }
    }
    g <- ggplot(df, aes(x = go_term, y = value, fill = value))
    g <- g + xlab("GO terms")
    if (input$diff_go_barplot_var == "p-value") {
      g <- g + ylab('- log10 p-value')
      g <- g + labs(fill = '- log10 p-value')
    } else if (input$diff_go_barplot_var == "FDR") {
      g <- g + ylab('- log10 FDR')
      g <- g + labs(fill = '- log10 FDR')
    }
    g <- g + geom_bar(stat = 'identity', width = input$diff_go_barplot_bar_width) + theme_bw()
    g <- g + coord_flip(ylim = c(input$diff_go_barplot_xlim, max(df$value)))
    if (input$diff_go_barplot_show_des) {
      g <- g + geom_text(aes(x = go_term, y = input$diff_go_barplot_xlim,
                             label = go_des, hjust = "left"),
                         color = "white", lineheight = 0.7,
                         size = input$diff_go_barplot_show_des_size)
    }
    return(g)
  })
  
  # Render GO bar plot
  output$diff_go_barplot <- renderPlot({
    diff_go_barplot()
  })
  
  observeEvent(input$diff_go_barplot_download, {
    download_plot(diff_go_barplot())
  })
  
  # Data frame of top GO terms with go column containing integer GO ids
  diff_top_go_terms_df <- reactive({
    if (! is.null(diff_top_go_terms())) {
      go_df <- as.data.frame.matrix(diff_top_go_terms())
      go_df$go <- as.integer(gsub("GO:", "", go_df$GO.ID))
      go_df
    }
  })
  
  # Render plot for GO terms p values
  output$diff_go_pval_graph <- renderPlotly({
    if (! is.null(diff_top_go_terms())) {
      df <- data.frame(go = diff_top_go_terms_df()$go, 
                       GO.ID = diff_top_go_terms_df()$GO.ID,
                       logpvalue = - log10(as.numeric(diff_top_go_terms_df()$pvalue)), 
                       pvalue = diff_top_go_terms_df()$pvalue, 
                       annotated = diff_top_go_terms_df()$Annotated, 
                       term = diff_top_go_terms_df()$Term, 
                       fdr = diff_top_go_terms_df()$FDR, 
                       odds_ratio = diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df, 
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go, 
                     y = ~logpvalue, 
                     color = ~logpvalue, 
                     size = ~annotated, 
                     text = ~paste("GO id: ", GO.ID, 
                                   '<br>Annotated: ', annotated, 
                                   '<br>GO term: ', term, 
                                   '<br>FDR: ', fdr, 
                                   '<br>Odds ratio: ', odds_ratio, 
                                   '<br>p-value: ', pvalue), 
                     hoverinfo = 'text', 
                     source = "go_pval_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$diff_go_ontology)), 
                                         showticklabels = FALSE, 
                                         zeroline = FALSE), 
                            yaxis = list(title = '-log<sub>10</sub>pvalue'), 
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$diff_go_pval_graph_alpha),
                                y1 = - log10(input$diff_go_pval_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Make GO terms p-value plotly graph brushed points table
  observeEvent({
    event_data(event = "plotly_selected", 
               source = "go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  },{
    go_selected <- event_data(event = "plotly_selected", 
                              source = "go_pval_graph",
                              session = shiny::getDefaultReactiveDomain())
    df <- diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
    output$diff_go_pval_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                             rownames = FALSE,
                                                             filter = list(position = 'top', clear = FALSE), 
                                                             selection = "none")
  })
  
  # Show detailed info modal on GO terms p-value graph click event
  observeEvent({
    event_data(event = "plotly_click", 
               source = "go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  }, {
    go_clicked <- event_data(event = "plotly_click", 
                             source = "go_pval_graph",
                             session = shiny::getDefaultReactiveDomain())
    go_info <- diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(diff_top_go_terms_df()) != 'go']
    go_info$gene <- gsub(",", "<br/>", go_info$gene)
    go_info <- t(go_info)
    rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
    rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
    output$diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info, 
                                                                               colnames = "", 
                                                                               selection = "none", 
                                                                               escape = FALSE))
    showModal(modalDialog(
      tagList(
        downloadButton("go_genes_download", "Download significant genes"),
        DT::dataTableOutput("diff_go_graph_pt_details_table")
      ), 
      easyClose = TRUE
    ))
  })
  
  # Render plot for GO terms FDR
  output$diff_go_fdr_graph <- renderPlotly({
    if (! is.null(diff_top_go_terms())) {
      df <- data.frame(go = diff_top_go_terms_df()$go, 
                       GO.ID = diff_top_go_terms_df()$GO.ID, 
                       logfdr = - log10(as.numeric(diff_top_go_terms_df()$FDR)), 
                       pvalue = diff_top_go_terms_df()$pvalue, 
                       annotated = diff_top_go_terms_df()$Annotated, 
                       term = diff_top_go_terms_df()$Term, 
                       fdr = diff_top_go_terms_df()$FDR, 
                       odds_ratio = diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df, 
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go, 
                     y = ~logfdr, 
                     color = ~logfdr, 
                     size = ~annotated, 
                     text = ~paste("GO id: ", GO.ID, 
                                   '<br>Annotated: ', annotated, 
                                   '<br>GO term: ', term, 
                                   '<br>FDR: ', fdr, 
                                   '<br>Odds ratio: ', odds_ratio, 
                                   '<br>p-value: ', pvalue), 
                     hoverinfo = 'text', 
                     source = "go_fdr_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$diff_go_ontology)), 
                                         showticklabels = FALSE, 
                                         zeroline = FALSE), 
                            yaxis = list(title = '-log<sub>10</sub>FDR'), 
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$diff_go_fdr_graph_alpha),
                                y1 = - log10(input$diff_go_fdr_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Make GO terms FDR plotly graph brushed points table
  observeEvent(
    suppressWarnings(event_data(event = "plotly_selected", 
                                source = "go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())), 
    {
      go_selected <- event_data(event = "plotly_selected", 
                                source = "go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())
      df <- diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
      output$diff_go_fdr_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                              rownames = FALSE,
                                                              filter = list(position = 'top', clear = FALSE), 
                                                              selection = "none")
    })
  
  # Show detailed info modal on GO terms FDR graph click event
  observeEvent(
    suppressWarnings(event_data(event = "plotly_click", 
                                source = "go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())),
    {
      go_clicked <- event_data(event = "plotly_click", 
                               source = "go_fdr_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(diff_top_go_terms_df()) != 'go']
      go_info$gene <- gsub(",", "<br/>", go_info$gene)
      go_info <- t(go_info)
      rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
      rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
      output$diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info, 
                                                                                 colnames = "", 
                                                                                 selection = "none", 
                                                                                 escape = FALSE))
      showModal(modalDialog(
        tagList(
          downloadButton("go_genes_download", "Download significant genes"),
          DT::dataTableOutput("diff_go_graph_pt_details_table")
        ), 
        easyClose = TRUE
      ))
    }
  )
  
  # Render GO terms volcano plot
  output$diff_go_volcano_plot <- renderPlotly({
    if (! is.null(diff_top_go_terms())) {
      df <- data.frame(GO.ID = diff_top_go_terms_df()$GO.ID, 
                       logpvalue = - log10(as.numeric(diff_top_go_terms_df()$pvalue)), 
                       pvalue = diff_top_go_terms_df()$pvalue, 
                       annotated = diff_top_go_terms_df()$Annotated, 
                       term = diff_top_go_terms_df()$Term, 
                       fdr = diff_top_go_terms_df()$FDR, 
                       odds_ratio = diff_top_go_terms_df()$odds_ratio_pseudo)
      # Only keep finite odds ratio rows
      df <- df[is.finite(df$odds_ratio), ]
      # Indicate significance in df
      df$significance <- rep("non-significant", nrow(df))
      df$significance[(df$pvalue < input$diff_go_volcano_plot_alpha) & (df$odds_ratio > input$diff_go_volcano_plot_or_threshold)] <- "significant"
      # Set colors
      pal <- c("grey", "blue")
      pal <- setNames(pal, c("non-significant", "significant"))
      fig <- plot_ly(type = 'scatter',
                     mode = 'markers', 
                     source = "go_volcano_plot", 
                     data = df, 
                     x = ~odds_ratio, 
                     y = ~logpvalue, 
                     color = ~significance, 
                     colors = pal,
                     text = ~paste("GO id: ", GO.ID, 
                                   '<br>Annotated: ', annotated, 
                                   '<br>GO term: ', term, 
                                   '<br>FDR: ', fdr, 
                                   '<br>Odds ratio: ', odds_ratio, 
                                   '<br>p-value: ', pvalue), 
                     hoverinfo = 'text')
      fig <- fig %>% layout(xaxis = list(title = 'Odds ratio'), 
                            yaxis = list(title = '-log<sub>10</sub>pvalue'))
      fig
    }
  })
  
  # Download GO term significant genes in modal pop-up
  output$go_genes_download <- downloadHandler(
    filename = {
      go_clicked <- event_data(event = "plotly_click", 
                               source = "go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      paste0(diff_top_go_terms_df()[go_clicked$pointNumber + 1, 'GO.ID'], "_significant_genes.txt")
    }, 
    content = function(file) {
      go_clicked <- event_data(event = "plotly_click", 
                               source = "go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(diff_top_go_terms_df()) != 'go']
      write.table(unlist(strsplit(go_info$gene, ",")), 
                  file, 
                  row.names = FALSE, 
                  col.names = FALSE,
                  quote = FALSE)
    }
  )
  
  # Differential test top GO terms download
  output$diff_go_table_download <- downloadHandler(
    filename = "Top_GO_terms.txt", 
    content = function(file) {
      write.table(diff_top_go_terms(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render significant differential bins nearest genes associated top GO terms table
  output$diff_go_table <- DT::renderDataTable({
    if (! is.null(diff_top_go_terms())) {
      diff_top_go_terms() %>% 
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = "none", 
                  options = list(scrollX = TRUE)) %>%
        formatRound(columns=c('pvalue', 'FDR', "odds_ratio_conditional", 
                              "odds_ratio_unconditional", "odds_ratio_pseudo"), 
                    digits=4)
    }
  })
  
  # Render disease snp analysis page ui
  output$disease_page_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to perform disease SNP analysis. ")
    } else {
      sidebarLayout(
        sidebarPanel(
          selectizeInput(
            "disease_sel", 
            "Select a disease/trait to investigate:", 
            choices = unique(snp_gbin$disease.trait), 
            multiple = TRUE
          ),
          actionButton(
            "show_disease_snp_table", 
            "Show disease associated SNPs table"
          ), 
          shinyWidgets::sliderTextInput(
            "disease_snp_ext", 
            "SNP window extension length:", 
            choices = c(100, 500, 1000, 5000, 1e4, 2e4, 5e4, 1e5, 1.5e5), 
            selected = 500
          ),
          textOutput("disease_snp_nbins_msg"),
          actionButton("show_disease_snp_bins_table", "Show table of genomic bins covered by SNP windows"),
          downloadButton("disease_snp_bins_download", "Download BED file of genomic bins covered by SNP windows"), 
          uiOutput("disease_run_analysis_ui")
        ), 
        mainPanel(
          uiOutput("disease_res_ui")
        )
      )
    }
  })
  
  # Disease SNP table
  disease_snp_table <- reactive({
    tb <- snp_gbin[snp_gbin$disease.trait %in% input$disease_sel, ]
    tb$disease.trait <- as.factor(tb$disease.trait)
    tb$snp_id <- as.factor(tb$snp_id)
    tb$chromosome <- as.factor(tb$chromosome)
    # Reset disease SNP selection
    disease_snp_sel(NULL)
    tb
  })
  
  # Selected SNPs
  disease_snp_sel <- reactiveVal()
  
  # Render disease SNP table on button click
  observeEvent(input$show_disease_snp_table, {
    output$disease_snp_table <- DT::renderDataTable(disease_snp_table(), 
                                                    rownames = FALSE,
                                                    filter = list(position = 'top', clear = FALSE), 
                                                    selection = "multiple")
    showModal(
      modalDialog(
        downloadButton("disease_snp_table_download", "Download table"),
        DT::dataTableOutput("disease_snp_table"), 
        actionButton("submit_disease_snp_sel", "Confirm SNP subset"),
        textOutput("disease_snp_sel_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render disease SNP subset submission text
  output$disease_snp_sel_submission_text <- renderText({
    disease_snp_sel_submission_text()
  })
  
  # Update disease SNP selection results
  disease_snp_sel_submission_text <- eventReactive(input$submit_disease_snp_sel, {
    if (length(input$disease_snp_table_rows_selected) == 0) {
      return(paste("Failed: no SNP have been selected. "))
    }
    disease_snp_sel(disease_snp_table()[input$disease_snp_table_rows_selected, 'snp_id'])
    return(paste("Subset complete! "))
  })
  
  # Download disease SNP table
  output$disease_snp_table_download <- downloadHandler(
    filename = paste0(snp_gbin$disease.trait, "_snp.txt"), 
    content = function(file) {
      write.table(disease_snp_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Genomic bins covered by SNP windows (as GRange object)
  disease_gbins <- reactiveVal()
  
  # SNP windows to genomic bins table
  disease_gbins_table <- reactiveVal(
    setNames(data.frame(matrix(ncol = 6, nrow = 0)), 
             c("disease_trait", "snp_id", "chromosome", "position", "covered_bin_start", "covered_bin_end"))
  )
  
  # Update disease_gbins and disease_gbins_table
  observe({
    disease_snps <- disease_snp_table()
    if (! is.null(disease_snp_sel())) {
      disease_snps <- disease_snp_table()[disease_snp_table()$snp_id %in% disease_snp_sel(), ]
    }
    snp_ranges <- GRanges(seqnames = disease_snps$chromosome, 
                          ranges = IRanges(start = disease_snps$position - input$disease_snp_ext, 
                                           end = disease_snps$position + input$disease_snp_ext))
    hits <- findOverlaps(snp_ranges, bird_ranges)
    disease_gbins(bird_ranges[unique(hits@to)])
    gbin_hits <- bird_ranges[hits@to]
    disease_gbins_table(data.frame(disease_trait = as.factor(disease_snps[hits@from, 'disease.trait']),
                                   snp_id = as.factor(disease_snps[hits@from, 'snp_id']), 
                                   chromosome = as.factor(disease_snps[hits@from, 'chromosome']), 
                                   position = disease_snps[hits@from, 'position'], 
                                   covered_bin_start = start(gbin_hits), 
                                   covered_bin_end = end(gbin_hits)))
  })
  
  # Text message for number of bins in SNP windows
  output$disease_snp_nbins_msg <- renderText({
    paste("There are", length(disease_gbins()), "genomic bins in your SNP windows. ")
  })
  
  # Render SNP bins table on button click
  observeEvent(input$show_disease_snp_bins_table, {
    output$disease_snp_nbins_table <- DT::renderDataTable(disease_gbins_table(), 
                                                          rownames = FALSE,
                                                          filter = list(position = 'top', clear = FALSE), 
                                                          selection = "none")
    showModal(
      modalDialog(
        downloadButton("disease_snp_nbins_table_download", "Download table"),
        DT::dataTableOutput("disease_snp_nbins_table"), 
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Download disease SNP bins table
  output$disease_snp_nbins_table_download <- downloadHandler(
    filename = "snp_bins.txt", 
    content = function(file) {
      write.table(disease_gbins_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Download BED file for SNP covered bins
  output$disease_snp_bins_download <- downloadHandler(
    filename = "snp_windows.bed", 
    content = function(file) {
      disease_snps <- disease_snp_table()[disease_snp_table()$snp_id %in% disease_snp_sel(), ]
      write.table(data.frame(chromosome = disease_snps$chromosome, 
                             start = disease_snps$position - input$disease_snp_ext, 
                             end = disease_snps$position + input$disease_snp_ext), 
                  file, 
                  row.names = FALSE, 
                  col.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render UI panel for disease run analysis button
  output$disease_run_analysis_ui <- renderUI({
    if (length(disease_gbins()) == 0) {
      p("There are no genomic bins in the SNP window. Please use a larger SNP window extension. ")
    } else {
      actionButton("disease_run_analysis", "Run disease SNP analysis")
    }
  })
  
  full_pred_df <- reactive({
    req(nrow(selected_samples()) > 0)
    database_pred_df <- get_database_pred_df(bird_ranges)
    nlocal_samps <- sum(selected_samples()$read_from == "local")
    local_pred_mat <- get_local_pred_mat(bird_ranges)
    pred_df <- database_pred_df
    if (nlocal_samps > 0) {
      # Have local samples
      pred_df <- cbind(pred_df, local_pred_mat)
    } 
    pred_df
  })
  
  # Prediction data.frame for disease bins
  disease_pred_df <- reactive({
    showModal(modalDialog('Retrieving sample predictions...', footer = NULL, easyClose = TRUE, size = "s"))
    hits <- findOverlaps(bird_ranges, disease_gbins())
    bird_i <- sort(unique(hits@from))
    df <- full_pred_df()[bird_i, , drop=F]
    removeModal()
    df
  })
  
  # Prediction matrix for disease bins
  disease_pred_mat <- reactive({
    mat <- data.matrix(sapply(disease_pred_df()[, 4:ncol(disease_pred_df())], as.numeric))
    if (nrow(disease_pred_df()) == 1) {
      mat <- t(mat)
    }
    rownames(mat) <- paste0(disease_pred_df()$Chromosome, ' (', disease_pred_df()$Start, '-', disease_pred_df()$End, ')')
    mat
  })
  
  sample_avgs <- reactive({
    req(nrow(selected_samples()) > 0)
    colMeans(full_pred_df()[, 4:ncol(full_pred_df())])
  })
  
  # Disease mean and normalized mean tables
  disease_mean <- reactiveVal()
  disease_normalized_mean <- reactiveVal()
  
  # Run disease SNP analysis
  observeEvent(input$disease_run_analysis, {
    gbins_names <- paste0(disease_gbins_table()$chromosome, 
                          ' (', disease_gbins_table()$covered_bin_start, '-', 
                          disease_gbins_table()$covered_bin_end, ')')
    sel_disease <- unique(disease_gbins_table()$disease_trait)
    mean_table <- sapply(sel_disease, function(disease) {
      disease_gbin_names <- gbins_names[disease_gbins_table()$disease_trait == disease]
      colMeans(disease_pred_mat()[disease_gbin_names, , drop=F])
    })
    colnames(mean_table) <- sel_disease
    disease_mean(mean_table)
    sample_all_means <- sample_avgs()[colnames(disease_pred_mat())]
    names(sample_all_means) <- colnames(disease_pred_mat())
    normalized_mean_table <- t(sapply(colnames(disease_pred_mat()), function(sample) {
      mean_table[sample, ] / sample_all_means[sample]
    }))
    if (length(sel_disease) == 1) {
      normalized_mean_table <- matrix(normalized_mean_table, ncol = 1)
      rownames(normalized_mean_table) <- colnames(disease_pred_mat())
    } 
    colnames(normalized_mean_table) <- sel_disease
    disease_normalized_mean(normalized_mean_table)
  })
  
  # Render table for single disease/trait sample means
  output$disease_single_res_table <- DT::renderDataTable(data.frame(sample = rownames(disease_mean()), 
                                                                    snps_accessibility = disease_mean()[, 1], 
                                                                    normalized_snps_accessibility = disease_normalized_mean()[, 1]) %>% 
                                                           datatable(rownames = FALSE,
                                                                     filter = list(position = 'top', clear = FALSE), 
                                                                     selection = "none") %>%
                                                           formatRound(columns=c("snps_accessibility", "normalized_snps_accessibility"), digits=4))
  
  # Render table of disease/trait sample means
  output$disease_res_mean_table <- DT::renderDataTable(data.frame(sample = rownames(disease_mean()), 
                                                                  disease_mean()) %>%
                                                         datatable(rownames = FALSE,
                                                                   filter = list(position = 'top', clear = FALSE), 
                                                                   selection = "none", 
                                                                   options = list(scrollX = TRUE, 
                                                                                  autoWidth = TRUE, 
                                                                                  columnDefs = list(list(width = '200px', targets = "_all")))) %>%
                                                         formatRound(columns=2:(ncol(disease_mean()) + 1), digits=4))
  
  # Render table of disease/trait sample normalized means
  output$disease_res_normalized_mean_table <- DT::renderDataTable(data.frame(sample = rownames(disease_normalized_mean()), 
                                                                             disease_normalized_mean()) %>%
                                                                    datatable(rownames = FALSE,
                                                                              filter = list(position = 'top', clear = FALSE), 
                                                                              selection = "none", 
                                                                              options = list(scrollX = TRUE, 
                                                                                             autoWidth = TRUE,
                                                                                             columnDefs = list(list(width = '200px', targets = "_all")))) %>%
                                                                    formatRound(columns=2:(ncol(disease_normalized_mean()) + 1), digits=4))
  
  # Render UI panel for disease SNP analysis results
  output$disease_res_ui <- renderUI({
    if ((! is.null(input$disease_run_analysis)) && (input$disease_run_analysis > 0)) {
      if (length(unique(disease_gbins_table()$disease_trait)) == 1) {
        # For single disease/trait selection
        tabsetPanel(
          tabPanel(
            title = "Result table", 
            downloadButton("download_disease_single_res", "Download result table"),
            DT::dataTableOutput("disease_single_res_table")
          ), 
          tabPanel(
            title = "Bar plot", 
            radioButtons(
              "disease_barplot_var", 
              "", 
              choices = list("Normalized mean log2 predicted accessibility" = "normalized_mean",
                             "Mean log2 predicted accessibility" = "mean")
            ), 
            fluidRow(
              column(
                width = 4, 
                radioButtons(
                  "disease_barplot_sort_by", 
                  label = "Sort bar plot rows by: ", 
                  choices = c("Default order" = "default", 
                              "Decreasing accessibility" = "decrease", 
                              "Increasing accessibility" = "increase", 
                              "Custom order" = "custom")
                )
              ), 
              column(
                width = 8, 
                uiOutput("disease_barplot_sort_details_ui")
              )
            ), 
            plotlyOutput("disease_barplot")
          ),
          tabPanel(
            title = "Heat map", 
            uiOutput("disease_heatmap_ui")
          )
        )
      } else {
        # For multiple disease/traits
        tabsetPanel(
          tabPanel(
            title = "Result table", 
            p("Mean sample disease/trait predicted accessibility table"),
            downloadButton("download_disease_res_mean", "Download mean table"),
            DT::dataTableOutput("disease_res_mean_table"),
            p("Normalized mean sample disease/trait predicted accessibility table"),
            downloadButton("download_disease_res_normalized_mean", "Download normalized mean table"),
            DT::dataTableOutput("disease_res_normalized_mean_table")
          ), 
          tabPanel(
            title = "Disease/trait heat map", 
            radioButtons(
              "disease_heatmap_var", 
              "", 
              choices = list("Normalized mean log2 predicted accessibility" = "normalized_mean",
                             "Mean log2 predicted accessibility" = "mean")
            ), 
            uiOutput("disease_heatmap_ui")
          )
        )
      }
    }
  })
  
  # Render UI for bar plot sort details
  output$disease_barplot_sort_details_ui <- renderUI({
    if (input$disease_barplot_sort_by == "custom") {
      fluidRow(
        column(
          width = 6, 
          radioButtons(
            "disease_barplot_custom_sort_method", 
            "Input custom order by: ", 
            choices = c("Text input", 
                        "Drag to sort")
          )
        ), 
        column(
          width = 6, 
          uiOutput("disease_barplot_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for disease bar plot custom sorting options
  output$disease_barplot_custom_sort_ui <- renderUI({
    if (input$disease_barplot_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "disease_barplot_custom_sort_text", 
          "Input sample names separated by line breaks: "
        ),
        fileInput(
          "disease_barplot_custom_sort_txt_file", 
          "Upload txt file indicating sort order", 
          accept = "text/plain"
        ),
        actionButton("submit_disease_barplot_custom_sort", "Confirm order"), 
        textOutput("disease_barplot_custom_sort_submission_text")
      )
    } else if (input$disease_barplot_custom_sort_method == "Drag to sort") {
      actionButton("disease_barplot_custom_sort_drag_button", "Sort samples")
    }
  })
  
  # Update disease bar plot custom sort text area input value based on uploaded file
  observeEvent(input$disease_barplot_custom_sort_txt_file, {
    if (! is.null(input$disease_barplot_custom_sort_txt_file)) {
      sample_sort_text <- paste(readLines(input$disease_barplot_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "disease_barplot_custom_sort_text", 
        value = sample_sort_text
      )
    }
  })
  
  # Disease bar plot custom order value
  disease_barplot_custom_order <- reactiveVal()
  
  # Update default custom order when disease mean is calculated
  observeEvent(disease_mean(), {
    disease_barplot_custom_order(rownames(disease_mean()))
  })
  
  # Render pop-up modal for disease bar plot custom drag sort
  observeEvent(input$disease_barplot_custom_sort_drag_button, {
    if (is.null(disease_barplot_custom_order())) {
      samples_order <- rownames(disease_mean())
    } else {
      samples_order <- disease_barplot_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = samples_order,
      input_id = "samples_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("submit_disease_barplot_custom_sort", "Confirm order"), 
        textOutput("disease_barplot_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for disease bar plot custom sort
  output$disease_barplot_custom_sort_submission_text <- renderText({
    disease_barplot_custom_sort_submission_text()
  })
  
  # Process disease bar plot custom sort request
  disease_barplot_custom_sort_submission_text <- eventReactive(input$submit_disease_barplot_custom_sort, {
    if (input$disease_barplot_custom_sort_method == "Text input") {
      # Read samples from submitted text
      samples <- unlist(strsplit(input$disease_barplot_custom_sort_text, split = "\n"))
      samples <- sapply(samples, function(sample) {
        sample <- gsub(" ", "", sample)
        sample <- gsub("\t", "", sample)
        sample
      })
      samples <- samples[samples != ""]
      # Check for non-selected samples
      extra <- samples[! (samples %in% rownames(disease_mean()))]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected samples:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated samples
      counts <- sapply(rownames(disease_mean()), function(sample) {
        sum(samples %in% sample)
      })
      if (any(counts > 1)) {
        return(paste("The following samples are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing samples
      if (any(counts == 0)) {
        return(paste("The following samples are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      disease_barplot_custom_order(samples)
      return(paste("Sorting complete!"))
    } else if (input$disease_barplot_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      disease_barplot_custom_order(input$samples_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  # Download single disease means table
  output$download_disease_single_res <- downloadHandler(
    filename = paste0(colnames(disease_mean()), "_means.txt"), 
    content = function(file) {
      write.table(data.frame(sample = rownames(disease_normalized_mean()), 
                             snps_accessibility = disease_mean()[, 1], 
                             normalized_snps_accessibility = disease_normalized_mean()[, 1]), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Download disease means table
  output$download_disease_res_mean <- downloadHandler(
    filename = "disease_trait_means.txt", 
    content = function(file) {
      write.table(data.frame(sample = rownames(disease_mean()), 
                             disease_mean()), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Download disease normalized means table
  output$download_disease_res_normalized_mean <- downloadHandler(
    filename = "disease_trait_normalized_means.txt", 
    content = function(file) {
      write.table(data.frame(sample = rownames(disease_normalized_mean()), 
                             disease_normalized_mean()), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render disease bar plot
  output$disease_barplot <- renderPlotly({
    if (input$disease_barplot_var == "mean") {
      df <- data.frame(sample = rownames(disease_normalized_mean()), 
                       accessibility = disease_mean()[, 1])
    } else {
      df <- data.frame(sample = rownames(disease_normalized_mean()), 
                       accessibility = disease_normalized_mean()[, 1])
    }
    if (input$disease_barplot_sort_by == "decrease") {
      df$sample <- factor(df$sample, levels = df$sample[order(df$accessibility)])
    } else if (input$disease_barplot_sort_by == "increase") {
      df$sample <- factor(df$sample, levels = df$sample[order(df$accessibility, decreasing = TRUE)])
    } else if (input$disease_barplot_sort_by == "custom") {
      df$sample <- factor(df$sample, levels = rev(disease_barplot_custom_order()))
    }
    g <- ggplot(df, aes(x = sample, y = accessibility, fill = accessibility))
    if (input$disease_barplot_var == "mean") {
      g <- g + ylab('Mean log<sub>2</sub> accessibility')
      g <- g + labs(fill = 'Mean log<sub>2</sub> accessibility')
      g <- g + geom_bar(stat = 'identity', width = 0.5) + coord_flip() + theme_bw()
      p <- ggplotly(g) %>% style(hoverinfo = 'none')
    } else if (input$disease_barplot_var == "normalized_mean") {
      g <- g + ylab('Normalized mean log<sub>2</sub> accessibility')
      g <- g + labs(fill = 'Normalized mean <br>log<sub>2</sub> accessibility')
      g <- g + geom_bar(stat = 'identity', width = 0.5) + coord_flip() + theme_bw()
      p <- ggplotly(g) %>% style(hoverinfo = 'none')
    }
    p
  })
  
  # Render UI panel for disease SNP heatmap results
  output$disease_heatmap_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to display a heatmap. ")
    } else {
      if (length(unique(disease_gbins_table()$disease_trait)) == 1) {
        # Single disease/trait heat map
        if (length(disease_gbins()) < 2) {
          p("There must be at least 2 genomic bins covered by SNP windows to display a heatmap. ")
        } else {
          tagList(
            # checkboxInput(
            #   "disease_heatmap_snp_subset", 
            #   label = "Show heatmap for a specific SNP window",
            #   value = FALSE
            # ),
            # uiOutput("disease_heatmap_snp_subset_ui"),
            sliderInput(
              "disease_heatmap_top_var", 
              label = "Number of top variance rows to include in heat map", 
              min = 1000, 
              max = 10000, 
              value = 2000, 
              step = 100
            ),
            radioButtons(
              "disease_heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            ), 
            actionButton("disease_show_interactive_gbins_heatmap", "Show interactive heat map"),
            plotOutput("disease_gbins_heat_map"), 
            actionButton("disease_gbins_heat_map_download", "Download plot")
          )
        }
      } else {
        # Multiple disease/traits heat map
        sort_choices <- list("default", "decrease", "increase", "custom")
        if (input$disease_heatmap_var == "mean") {
          names(sort_choices) <- c("Sample clusters", 
                                   "Decreasing mean accessibility", 
                                   "Increasing mean accessibility", 
                                   "Custom order")
        } else {
          names(sort_choices) <- c("Sample clusters", 
                                   "Decreasing normalized mean accessibility", 
                                   "Increasing normalized mean accessibility", 
                                   "Custom order")
        }
        tagList(
          fluidRow(
            column(
              width = 4, 
              radioButtons(
                "disease_heatmap_sort_by", 
                label = "Sort heat map rows by: ", 
                choices = sort_choices
              )
            ), 
            column(
              width = 8, 
              uiOutput("disease_heatmap_sort_details_ui")
            )
          ), 
          actionButton("disease_show_interactive_heatmap", "Show interactive heat map"),
          plotOutput("disease_heat_map"), 
          actionButton("disease_heat_map_download", "Download plot")
        )
      }
    }
  })
  
  # Render UI for heat map sort details
  output$disease_heatmap_sort_details_ui <- renderUI({
    if ((input$disease_heatmap_sort_by == "decrease") || (input$disease_heatmap_sort_by == "increase")) {
      selectInput(
        "disease_heatmap_sort_trait_sel", 
        "Sort heat map rows by accessibility for this trait: ", 
        choices = colnames(disease_mean())
      )
    } else if (input$disease_heatmap_sort_by == "custom") {
      fluidRow(
        column(
          width = 6, 
          radioButtons(
            "disease_heatmap_custom_sort_method", 
            "Input custom order by: ", 
            choices = c("Text input", 
                        "Drag to sort")
          )
        ), 
        column(
          width = 6, 
          uiOutput("disease_heatmap_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for disease heat map custom sorting options
  output$disease_heatmap_custom_sort_ui <- renderUI({
    if (input$disease_heatmap_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "disease_heatmap_custom_sort_text", 
          "Input sample names separated by line breaks: "
        ),
        fileInput(
          "disease_heatmap_custom_sort_txt_file", 
          "Upload txt file indicating sort order", 
          accept = "text/plain"
        ),
        actionButton("submit_disease_heatmap_custom_sort", "Confirm order"), 
        textOutput("disease_heatmap_custom_sort_submission_text")
      )
    } else if (input$disease_heatmap_custom_sort_method == "Drag to sort") {
      actionButton("disease_heatmap_custom_sort_drag_button", "Sort samples")
    }
  })
  
  # Update disease heat map custom sort text area input value based on uploaded file
  observeEvent(input$disease_heatmap_custom_sort_txt_file, {
    if (! is.null(input$disease_heatmap_custom_sort_txt_file)) {
      sample_sort_text <- paste(readLines(input$disease_heatmap_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "disease_heatmap_custom_sort_text", 
        value = sample_sort_text
      )
    }
  })
  
  # Disease heat map custom order value
  disease_heatmap_custom_order <- reactiveVal()
  
  # Update default custom order when disease mean is calculated
  observeEvent(disease_mean(), {
    disease_heatmap_custom_order(rownames(disease_mean()))
  })
  
  # Render pop-up modal for disease heat map custom drag sort
  observeEvent(input$disease_heatmap_custom_sort_drag_button, {
    if (is.null(disease_heatmap_custom_order())) {
      samples_order <- rownames(disease_mean())
    } else {
      samples_order <- disease_heatmap_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = samples_order,
      input_id = "samples_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("submit_disease_heatmap_custom_sort", "Confirm order"), 
        textOutput("disease_heatmap_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for disease heat map custom sort
  output$disease_heatmap_custom_sort_submission_text <- renderText({
    disease_heatmap_custom_sort_submission_text()
  })
  
  # Process disease heat map custom sort request
  disease_heatmap_custom_sort_submission_text <- eventReactive(input$submit_disease_heatmap_custom_sort, {
    if (input$disease_heatmap_custom_sort_method == "Text input") {
      # Read samples from submitted text
      samples <- unlist(strsplit(input$disease_heatmap_custom_sort_text, split = "\n"))
      samples <- sapply(samples, function(sample) {
        sample <- gsub(" ", "", sample)
        sample <- gsub("\t", "", sample)
        sample
      })
      samples <- samples[samples != ""]
      # Check for non-selected samples
      extra <- samples[! (samples %in% rownames(disease_mean()))]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected samples:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated samples
      counts <- sapply(rownames(disease_mean()), function(sample) {
        sum(samples %in% sample)
      })
      if (any(counts > 1)) {
        return(paste("The following samples are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing samples
      if (any(counts == 0)) {
        return(paste("The following samples are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      disease_heatmap_custom_order(samples)
      return(paste("Sorting complete!"))
    } else if (input$disease_heatmap_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      disease_heatmap_custom_order(input$samples_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  # Render UI for showing specific SNPs in heat map
  output$disease_heatmap_snp_subset_ui <- renderUI({
    if (input$disease_heatmap_snp_subset) {
      snp_counts <- table(disease_gbins_table()$snp_id)
      selectInput(
        'disease_heatmap_snp_sel', 
        'Select a SNP:', 
        choices = c(names(snp_counts[snp_counts > 1]))
      )
    }
  })
  
  # Create genomic bins heat map object
  disease_gbins_heat_map <- reactive({
    if (length(disease_gbins()) < 2) {
      return(NULL)
    }
    filtered_pred_mat <- disease_pred_mat()
    if (! is.null(input$disease_heatmap_snp_sel)) {
      snp_gbins_info <- disease_gbins_table()[as.character(disease_gbins_table()$snp_id) == input$disease_heatmap_snp_sel, ]
      sel_gbins <- paste0(snp_gbins_info$chromosome, ' (', snp_gbins_info$covered_bin_start, '-', snp_gbins_info$covered_bin_end, ')')
      filtered_pred_mat <- filtered_pred_mat[sel_gbins, ]
    }
    n_top_var <- min(input$disease_heatmap_top_var, nrow(filtered_pred_mat))
    disease_pred_hypervar <- hypervar_bulk(filtered_pred_mat)
    top_var_idx <- base::sort(disease_pred_hypervar$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    
    # Filter prediction matrix by top variance rows
    pred_mat_sorted <- filtered_pred_mat[disease_pred_hypervar$feature[top_var_idx], ] # This is sorted by decreasing variance
    pred_mat_sorted_gbins <- rownames(pred_mat_sorted)
    
    # Make heat map
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$disease_heatmap_sort_by == "Decreasing variance") {
      row.order <- order(1:nrow(pred_mat_sorted))
      cluster.rows <- FALSE
    } else if (input$disease_heatmap_sort_by == "Genomic position") {
      sorted_gbins <- disease_pred_hypervar$feature[base::sort(top_var_idx)] # Genomic bins sorted by genomic position
      row.order <- sapply(pred_mat_sorted_gbins, function(x) {
        which(sorted_gbins == x)
      })
      row.order <- order(row.order)
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    ht <- Heatmap(pred_mat_sorted, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "log2 predicted \nchromatin \naccessibility"))
    removeModal()
    return(draw(ht))
  })
  
  # Render genomic bins heat map
  output$disease_gbins_heat_map <- renderPlot({
    disease_gbins_heat_map()
  })
  
  observeEvent(input$disease_gbins_heat_map_download, {
    download_plot(disease_gbins_heat_map())
  })
  
  # Interactive heat map
  observeEvent(input$disease_show_interactive_gbins_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, disease_gbins_heat_map())
  })
  
  # Create disease heat map object
  disease_heat_map <- reactive({
    if (input$disease_heatmap_var == "mean") {
      df <- disease_mean()
      legend_title <- "Mean log2 predicted \naccessibility"
    } else {
      df <- disease_normalized_mean()
      legend_title <- "Normalized mean log2 \npredicted accessibility"
    }
    if (input$disease_heatmap_sort_by == "default") {
      cluster.rows <- TRUE
    } else {
      cluster.rows <- FALSE
    }
    row.order <- NULL
    if (input$disease_heatmap_sort_by == "custom") {
      row.order <- sapply(disease_heatmap_custom_order(), function(sample) {
        which(rownames(disease_mean()) == sample)
      })
    } else if ((! is.null(input$disease_heatmap_sort_trait_sel)) && 
               ((input$disease_heatmap_sort_by == "decrease") || 
                (input$disease_heatmap_sort_by == "increase"))) {
      decreasing <- input$disease_heatmap_sort_by == "decrease"
      row.order <- sort(df[, input$disease_heatmap_sort_trait_sel], 
                        decreasing = decreasing, 
                        index.return = TRUE)$ix
    }
    ht <- Heatmap(df, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = legend_title))
    return(draw(ht))
  })
  
  # Render disease heat map
  output$disease_heat_map <- renderPlot({
    disease_heat_map()
  })
  
  observeEvent(input$disease_heat_map_download, {
    download_plot(disease_heat_map())
  })
  
  # Interactive heat map
  observeEvent(input$disease_show_interactive_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, disease_heat_map())
  })
  
  # Remove temporary directory on session end
  session$onSessionEnded(function() {
    unlink(tmp_dir, recursive = TRUE)
  })
}

shiny::shinyApp(ui = ui, server = server)

# [END]