if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

pkgs <- c("shiny", "shinyBS", "shinythemes", "caret", "sortable", "mgcv", "igraph", 
          "umap", "dplyr", "purrr", "plotly", "shinyWidgets", "shinyjs", "DT", "reshape2", 
          "rclipboard", "shinyFiles", "heatmaply")
bioc_pkgs <- c("recount3", "GenomicRanges", "ComplexHeatmap", "org.Hs.eg.db", 
               "InteractiveComplexHeatmap", 
               "topGO", "limma", "GenomicAlignments", "DESeq2", "preprocessCore")

req_pkgs <- sapply(pkgs, function(pkg) {! requireNamespace(pkg, quietly = TRUE)})
if (any(req_pkgs)) 
  install.packages(pkgs[req_pkgs], dependencies = TRUE)
req_bioc_pkgs <- sapply(bioc_pkgs, function(pkg) {! requireNamespace(pkg, quietly = TRUE)})
if (any(req_bioc_pkgs)) 
  BiocManager::install(bioc_pkgs[req_bioc_pkgs])

suppressMessages(library(shiny))
suppressMessages(library(shinyBS))
suppressMessages(library(shinythemes))
suppressMessages(library(shinyWidgets))
suppressMessages(library(shinyjs))
suppressMessages(library(shinyFiles))
suppressMessages(library(DT))
suppressMessages(library(plotly))
suppressMessages(library(dplyr))
suppressMessages(library(purrr))
suppressMessages(library(rclipboard))
suppressMessages(library(GenomicRanges))
# suppressMessages(library(recount3))
# suppressMessages(library(caret))
# suppressMessages(library(sortable))
# suppressMessages(library(ComplexHeatmap))
# suppressMessages(library(InteractiveComplexHeatmap))
# suppressMessages(library(topGO))
# suppressMessages(library(org.Hs.eg.db))
# suppressMessages(library(mgcv))
# suppressMessages(library(igraph))
# suppressMessages(library(umap))
# suppressMessages(library(limma))
# suppressMessages(library(GenomicAlignments))
# suppressMessages(library(reshape2))
# suppressMessages(library(DESeq2))
# suppressMessages(library(preprocessCore))
# suppressMessages(library(heatmaply))

#options(shiny.error = browser)
options(timeout = 800)

# Set recount3 url
recount3_url <- "https://recount-opendata.s3.amazonaws.com/recount3/release"

# Create temporary directory to hold all temporary files generated by this Shiny session
tmp_dir <- tempfile(pattern = "pddb")
dir.create(tmp_dir)

chromosomes <- paste0("chr", c(1:22, "X"))

# Max number of clusters for genomic bin clustering used in pseudo time accessibility
max_n_gbin <- 20

# Max number of sample clusters for differential test
diff_max_n_sample_clust <- 10

ui <- fluidPage(
  
  rclipboardSetup(),
  
  theme = shinytheme("united"),
  
  title = "ChromBIRD", 
  
  tags$head(
    tags$style(HTML('.important-btn:hover{background-color:#d14715}
                      .important-btn{color: white; background-color: #e95420; border: 1px solid white;}'))
  ),
  
  tags$head(
    tags$style(HTML('.regular-btn:hover{background-color:#ffb499; color: #e95420; }
                      .regular-btn{color: #e95420; background-color: #ffd7c8; border: 1px solid white;}'))
  ),
  
  navbarPage(
    title = "ChromBIRD", 
    id = "chrombird_nav",
    
    selected = "Home",
    
    tabPanel(
      title = "Home", 
      
      tags$div(
        style = "margin: 50px 0px;",
        fluidRow(
          column(
            6, 
            # Adapted from https://gist.github.com/markcaron/64c2d6dcc50c5e6857f187c1b6554709#file-figure-donut-chart-with-key-html
            tags$style(
              HTML("#stats_donut {display: flex;align-items: center;}
              #stats_donut div {height: 450px;}")
            ),
            tags$div(
              id = "stats_donut", 
              tags$div(
                id = "stats_donut_fig", 
                includeHTML("www/overview/stats_donut.html")
              ),
              tags$div(
                id = "stats_donut_legend", 
                style = "width:40%;height:100%",
                includeHTML("www/overview/stats_donut_legend.html")
              )
            ), 
          ),
          column(
            6, 
            style = "height:450px;display:flex;align-items:center;",
            tags$div(
              tags$style("p.title {font-size: 60px;}"), 
              HTML("<p class=\"title\"><font color=\"#159d79\"><b>ChromBIRD</b></font></p>"), 
              HTML("<h3><font color=\"#0f7056\">A chromatin accessibility predictions database</font></h3>"),
              hr(), 
              tags$div(
                style = "margin-left:50px;",
                HTML("<h4><font color=\"grey\"><i>A database of imputed human chromatin accessibility landscape</i></font></h4>")
              ),
              br(), 
              fluidRow(
                column(
                  4, 
                  actionButton("start_exploration", "Start exploring", 
                               width = "100%",
                             class = "important-btn")
                )
              ), 
              br(),
              fluidRow(
                column(
                  4, 
                  actionButton("to_tut", "Go to tutorial", 
                               width = "100%",
                               class = "regular-btn")
                ),
                column(
                  4, 
                  actionButton("to_demo", "Go to demo", 
                               width = "100%", 
                               class = "regular-btn")
                ),
                column(
                  4, 
                  uiOutput("run_from_local_ui")
                )
              )
            )
          )
        )
      ),
      
      hr(), 
      
      # Site map
      tags$div(
        style = "margin-left:10%; margin-right:10%",
        
        HTML("<h1><font color=\"#e95420\"><b>ChromBIRD workflow</b></font></h1>"), 
        tags$div(
          style = "position:relative;width:90%;padding-top:90%;margin:5% 5%;", 
          
          # Footer
          tags$div(
            style = "position:absolute;top:40%;left:30%;width:95%;",
            includeHTML("www/overview/footer_background.svg"), 
          ), 
          tags$div(
            style = "position:absolute;top:85%;left:95%;width:15%;",
            # Logo
            includeHTML("www/overview/chrombird_logo.svg")
          ),
          
          # Arrows
          tags$div(
            style="position:absolute;top:0;left:0;width:100%;height:100%", 
            tags$svg(
              viewBox="0 0 1000 1000", 
              
              tags$defs(
                tags$marker(
                  id='head',
                  orient="auto",
                  markerWidth='3',
                  markerHeight='4',
                  refX='1.1',
                  refY='2', 
                  tags$path(
                    d='M1 1 V3 L2 2 Z',
                    fill="#c7a192"
                  )
                )
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M300 100 L 330 100'
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M450 200 v 15 q 0 25 -25 25 L 175 240 q -25 0 -25 25 v 15'
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M450 200 v 15 q 0 25 25 25 L 825 240 q 25 0 25 25 v 15'
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M450 200 v 15 q 0 25 25 25 L 475 240 q 25 0 25 25 v 15'
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M150 500 v 30'
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M150 750 v 30'
              ), 
              tags$path(
                id='arrow-line',
                style="marker-end:url(#head);stroke-width:20;fill:none;stroke:#c7a192;",
                d='M500 500 v 30'
              ), 
            )
          ), 
          
          tags$style(".map_label {font-size:16px;}"),
          
          tags$div(
            class = "input_sel",
            style = "position:absolute;top:0%;left:15%;width:15%;height:20%;background:#20e9b2;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:#095d47;", 
              "Input Selection"
            ), 
            tags$style("#map_input_sel_samples {display: flex;align-items: center;}
                   #map_input_sel_samples div {display: flex;align-items: center;}
                   #map_input_sel_loci {display: flex;align-items: center;}
                   #map_input_sel_loci div {display: flex;align-items: center;}"),
            tags$div(
              id = "map_input_sel_samples",
              style = "position:absolute;top:35%;left:10%;width:100%;height:35%;",
              tags$div(
                style = "height:60%;width:30%;",
                includeHTML("www/overview/samples.svg")
              ), 
              tags$div(
                tags$p(
                  class = "map_label",
                  style = "padding-left:10px;margin:auto;color:#10a27b;", 
                  "Samples"
                )
              ), 
            ),
            tags$div(
              style= "position:absolute;top:65%;left:10%;width:75%;height:0%;border:solid #10a27b 1px;",
            ),
            tags$div(
              id = "map_input_sel_loci",
              style= "position:absolute;top:65%;left:10%;width:100%;height:35%;",
              tags$div(
                style = "height:60%;width:30%;",
                includeHTML("www/overview/loci.svg")
              ), 
              tags$div(
                tags$p(
                  class = "map_label",
                  style = "padding-left:10px;margin:auto;color:#10a27b;", 
                  "Loci"
                )
              )
            ),
            tags$head(tags$style("#map_input_sel:hover {outline:solid #0e8b6a 10px;}
                             #map_input_sel {transition: all 0.1s;}")),
            tags$button(
              id = "map_input_sel", 
              class = "btn action-button", 
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px"
            )
          ), 
          
          tags$div(
            style = "position:absolute;top:0%;left:35%;width:20%;height:20%;background:#10a27b;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "Retrieve/Download Prediction Data"
            ), 
            tags$div(
              style= "position:absolute;top:35%;left:0%;width:50%;height:65%;padding:0% 10%;text-align:center;",
              tags$p(
                class = "map_label",
                style = "color:#20e9b2;", 
                "RDS", 
                br(), 
                "Text", 
                br(), 
                "Bigwig"
              ), 
              tags$div(
                style = "position:absolute;bottom:0%;left:0%;width:100%;padding-left:20%;padding-right:20%;", 
                includeHTML("www/overview/download.svg")
              )
            ),
            tags$div(
              style= "position:absolute;top:45%;left:50%;width:0%;height:45%;border:solid #20e9b2 1px;"
            ),
            tags$div(
              style= "position:absolute;top:35%;left:50%;width:50%;height:65%;padding:10%;",
              tags$div(
                style = "position:absolute;top:0%;left:0%;width:100%;padding:0% 20%;", 
                includeHTML("www/overview/ucsc.svg")
              ),
              tags$p(
                class = "map_label",
                style = "position:absolute;bottom:0%;left:0%;width:100%;padding-left:10%;padding-right:10%;color:#20e9b2;text-align:center;", 
                "UCSC Genome Browser"
              )
            ),
            tags$head(tags$style("#map_download:hover {outline:solid #074635 7px;}
                             #map_download {transition: all 0.1s;}")),
            tags$button(
              id = "map_download", 
              class = "btn action-button", 
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            )
          ),
          
          tags$div(
            style = "position:absolute;top:0%;left:60%;width:30%;height:20%;background:#ffd7c8;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:#ff6933;", 
              "GTEx SNP Accessibility"
            ),
            tags$div(
              style = "position:absolute;top:20%;width:100%", 
              includeHTML("www/overview/gtex_snp.svg")
            ),
            tags$head(tags$style("#map_gtex_snp:hover {outline:solid #ff8f66 10px;}
                             #map_gtex_snp {transition: all 0.1s;}")),
            tags$button(
              id = "map_gtex_snp", 
              class = "btn action-button", 
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            )
          ), 
          
          tags$div(
            style = "position:absolute;top:30%;left:0%;width:30%;height:20%;background:#e95420;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "PCA and Pseudo-Temporal Analysis"
            ),
            tags$div(
              style = "position:absolute;top:35%;width:100%;", 
              includeHTML("www/overview/pca_pt.svg")
            ),
            tags$head(tags$style("#map_pca_pt:hover {outline:solid #f19574 10px;}
                             #map_pca_pt {transition: all 0.1s;}")),
            tags$button(
              id = "map_pca_pt",
              class = "btn action-button",
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            ),
          ), 
          
          tags$div(
            style = "position:absolute;top:55%;left:0%;width:30%;height:20%;background:#e95420;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "Differential Test Along Pseudotime"
            ),
            tags$div(
              style = "position:absolute;top:35%;width:100%;", 
              includeHTML("www/overview/diff_pt.svg")
            ),
            tags$head(tags$style("#map_pt_diff:hover {outline:solid #f19574 10px;}
                             #map_pt_diff {transition: all 0.1s;}")),
            tags$button(
              id = "map_pt_diff",
              class = "btn action-button",
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            ),
          ), 
          
          tags$div(
            style = "position:absolute;top:80%;left:0%;width:30%;height:20%;background:#e95420;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "GO Analysis"
            ),
            tags$div(
              style = "position:absolute;top:30%;left:10%;width:80%;height:8%;background:#f6b8a2;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#ef845d;padding-right:10px;margin:auto;", 
                "Term1"
              )
            ),
            tags$div(
              style = "position:absolute;top:42%;left:10%;width:70%;height:8%;background:#f6b8a2;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#ef845d;padding-right:10px;margin:auto;", 
                "Term2"
              )
            ),
            tags$div(
              style = "position:absolute;top:54%;left:10%;width:40%;height:8%;background:#f6b8a2;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#ef845d;padding-right:10px;margin:auto;", 
                "Term3"
              )
            ),
            tags$div(
              style = "position:absolute;top:66%;left:10%;width:30%;height:8%;background:#f6b8a2;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#ef845d;padding-right:10px;margin:auto;", 
                "Term4"
              )
            ),
            tags$div(
              style = "position:absolute;top:78%;left:10%;width:20%;height:8%;background:#f6b8a2;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#ef845d;padding-right:10px;margin:auto;", 
                "Term5"
              )
            ),
            tags$head(tags$style("#map_pt_go:hover {outline:solid #f19574 10px;}
                             #map_pt_go {transition: all 0.1s;}")),
            tags$button(
              id = "map_pt_go",
              class = "btn action-button",
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            ),
          ), 
          
          tags$div(
            style = "position:absolute;top:30%;left:35%;width:30%;height:20%;background:#a33e16;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "Differential Test Between Groups"
            ),
            tags$div(
              style = "position:absolute;top:35%;width:100%;", 
              includeHTML("www/overview/diff_group.svg")
            ),
            tags$head(tags$style("#map_group_diff:hover {outline:solid #e36635 10px;}
                             #map_group_diff {transition: all 0.1s;}")),
            tags$button(
              id = "map_group_diff",
              class = "btn action-button",
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            ),
          ), 
          
          tags$div(
            style = "position:absolute;top:55%;left:35%;width:30%;height:20%;background:#a33e16;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "GO Analysis"
            ),
            tags$div(
              style = "position:absolute;top:30%;left:10%;width:80%;height:8%;background:#ea8862;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#f3bba5;padding-right:10px;margin:auto;", 
                "Term1"
              )
            ),
            tags$div(
              style = "position:absolute;top:42%;left:10%;width:70%;height:8%;background:#ea8862;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#f3bba5;padding-right:10px;margin:auto;", 
                "Term2"
              )
            ),
            tags$div(
              style = "position:absolute;top:54%;left:10%;width:40%;height:8%;background:#ea8862;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#f3bba5;padding-right:10px;margin:auto;", 
                "Term3"
              )
            ),
            tags$div(
              style = "position:absolute;top:66%;left:10%;width:30%;height:8%;background:#ea8862;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#f3bba5;padding-right:10px;margin:auto;", 
                "Term4"
              )
            ),
            tags$div(
              style = "position:absolute;top:78%;left:10%;width:20%;height:8%;background:#ea8862;border:none;border-radius:5px", 
              tags$p(
                style = "text-align:right;color:#f3bba5;padding-right:10px;margin:auto;", 
                "Term5"
              )
            ),
            tags$head(tags$style("#map_group_go:hover {outline:solid #e36635 10px;}
                             #map_group_go {transition: all 0.1s;}")),
            tags$button(
              id = "map_group_go",
              class = "btn action-button",
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            ),
          ), 
          
          tags$div(
            style = "position:absolute;top:30%;left:70%;width:30%;height:20%;background:#16a37d;border:none;border-radius:25px", 
            tags$p(
              style = "position:absolute;top:10%;left:10%;max-width:80%;font-size:20px;color:white;", 
              "Disease SNP Analysis"
            ),
            tags$div(
              style = "position:absolute;top:20%;width:100%;", 
              includeHTML("www/overview/disease_snp.svg")
            ),
            tags$head(tags$style("#map_disease_snp:hover {outline:solid #35e3b5 10px;}
                             #map_disease_snp {transition: all 0.1s;}")),
            tags$button(
              id = "map_disease_snp",
              class = "btn action-button",
              style = "position:absolute;top:0%;left:0%;width:100%;height:100%;background:transparent;border:none;border-radius:25px",
            ),
          )
        )
      )
      
    ),
    
    tabPanel(
      title = "Input Selection", 
      
      uiOutput("input_sel_page_ui")
    ), 
    
    # Prediction download
    navbarMenu(
      title = "Prediction Download", 
      
      # Tab panel for txt prediction download
      tabPanel(
        title = "txt download", 
        
        uiOutput("download_zip_txt_ui")
      )
    ), 
    
    # Visualization
    navbarMenu(
      title = "Data Exploration Tools", 
      # Tab panel for PCA
      tabPanel(
        title = "PCA and pseudo-time", 
        
        uiOutput('pca_page_ui')
      ), 
      
      # Tab panel for heat map
      tabPanel(
        title = "Heat Map", 
        
        uiOutput("heatmap_page_ui")
      ), 
      
      # Tab panel for differential analysis
      tabPanel(
        title = "Group differential analysis", 
        
        uiOutput("diff_page_ui")
      ), 
      
      # Tab panel for disease SNP accessibility ranking
      tabPanel(
        title = "Disease SNP analysis", 
        
        uiOutput("disease_page_ui")
      )
    ), 
    
    # GTEx SNP panel
    tabPanel(
      title = "GTEx tissues SNPs", 
      uiOutput("gtex_snp_page_ui")
    ), 
    
    navbarMenu(
      title = "Help", 
      
      tabPanel(
        title = "Tutorial", 
        
        selectInput(
          "tut_page_sel", 
          "View tutorial:",
          choices = list("Input Selection and Download" = "input_sel_tut", 
                         "PCA and Pseudo-temporal Analysis" = "pca_pt_tut", 
                         "Differential Test between Groups" = "diff_group_tut", 
                         "Disease SNP Analysis" = "disease_snp_tut",
                         "GTEx SNP Accessibility Heatmap" = "gtex_snp_tut")
        ),
        
        tags$head(tags$style(".content_link {color:black;}
                               .content_link:hover {color:#e95420;text-decoration:underline;}")),
        
        uiOutput("tut_page_ui")
      ), 
      
      tabPanel(
        title = "Application Examples", 
        
        div(style = "display: inline-block;vertical-align: middle;", h2("Pseudo-temporal analysis application example")), 
        div(style = "display: inline-block;vertical-align: middle;"), 
        
        br(),
        br(),
        
        div(
          HTML("The purpose of this application demo is to give a quick 
               introduction to an example workflow. For a detailed guide, please 
               see the "), 
          actionLink("tut_link", "tutorial"), 
          HTML(". ")
        ),
        
        hr(),
        
        tags$div(
          
          style = "width:100%",
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/input_sel.svg")
          ),
          HTML("<p><b>Step 1</b>: Select the demo dataset as input by clicking on \"Select example dataset: 144 whole blood samples\". </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/pt_traj.svg")
          ),
          HTML("<p><b>Step 2</b>: Go to Data Exploration Tools, PCA and pseudo-time. 
               Go to Pseudo-time Analysis tab. Then, set parameters for pseudo-time 
               computation as shown to view the pseudo-temporal trajectory. From the 
               \"Choose pseudo-time analysis result panel to display\" drop-down, select 
               \"Psueod-time Trajectory\". </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/ridge.svg")
          ),
          HTML("<p>This plot shows the known age group (information extracted from GTEx) ridgeplot along constructed pseudo-time. Notice that age groups are distributed along pseudo-time by increasing age. </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/ht.svg")
          ),
          HTML("<p><b>Step 3</b>: Select \"Accessibility along pseudotime\" from 
               the \"Choose pseudo-time analysis result panel to display\" drop-down. 
               Select \"Individual genomic bin\" from \"Which accessibility to 
               visualize along pseudotime\", and choose \"Heatmap\" as your visualization 
               method to view a heat map of genomic bins accessibility along pseudotime. </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/gbin_clu_pt1.svg"), 
            includeHTML("www/demo/gbin_clu_pt2.svg")
          ),
          HTML("<p><b>Step 4</b>: Go to \"Pseudo-time Differential Test\" tab to 
          perform differential test along pseudo-time for each bin. Download the 
          significant bins BED file under summary tab. Then, go back to 
               \"Pseudo-time Analysis\" tab and select \"Accessibility along pseudotime\" 
               for \"Genomic bin clusters\". Check \"Filter genomic bins used in 
               clustering\", and upload the significant bins BED file to view the 
               significant bins clusters accessibility along pseudo-time. </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/gene_acc.svg")
          ),
          HTML("<p><b>Step 5</b>: Select \"Gene average\" and set distance limit to 2,000bp. Select a gene from table to view its accessibility along pseudo-time. </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/gene_expr.svg")
          ),
          HTML("<p><b>Step 6</b>: Select \"Nearest gene expression along pseudotime\" and \"Gene average\". Set distance limit to 2,000bp. Select a gene from table to view its expression along pseudo-time. </p>"),
          tags$br(),
          tags$br(),
          tags$br(),
          
          tags$div(
            style = "text-align:center",
            includeHTML("www/demo/go.svg")
          ),
          HTML("<p><b>Step 7</b>: Go to \"Pseudo-time Differential Test\" tab again and select \"Genomic bin clusters\". Upload the BED file again, and perform differnetial test on the cluster means.
    Go to \"Gene Ontology\" tab and run GO analysis for each genomic bin cluster separately. Remember to set the nearest gene mapping distance limit to 2,000bp. </p>"),
          tags$br(),
          tags$br(),
          tags$br()
          
        )
      ),
      
      tabPanel(
        title = "User Manual", 
        tags$iframe(style="height:600px; width:100%", 
                    src="user_manual.pdf")
      ), 
      
      tabPanel(
        title = "About", 
        
        h4("Why ChromBIRD? "), 
        p("Open chromatin is a hallmark of active regulatory elements and, 
          when combined with transcriptome profiles, provides crucial insights 
          into gene regulation during development and disease. Chromatin 
          accessibility assays such as DNase-seq and ATAC-seq enable genome-wide 
          mapping of open chromatin regions. However, most publicly available gene 
          expression samples lack accompanying chromatin accessibility data. 
          Moreover, the number of gene expression samples vastly exceeds the 
          number of chromatin accessibility profiles. For example, the Gene 
          Expression Omnibus (GEO) contains over 200,000 RNA-seq samples but 
          only around 40,000 DNase-seq and ATAC-seq samples."), 
        HTML("<p>To make better use of these transcriptome data for studying gene 
             regulation, we developed ChromBIRD, a database of genome-wide 
             chromatin accessibility landscapes for <b>345,118 human samples</b> 
             imputed from gene expression data. ChromBIRD includes <b>470 billion 
             imputed values</b> for <b>1,361,775 cis-regulatory elements (CREs)</b> in 
             approximately 270,000 bulk and 80,000 single-cell gene expression 
             samples from 8,741 studies compiled by recount3 from the 
             Sequence Read Archive (SRA), the Genotype-Tissue Expression (GTEx), 
             and The Cancer Genome Atlas Program (TCGA), covering a wide array of 
             tissues, cell types, diseases, and conditions. The BIRD algorithm, 
             previously shown to accurately predict variations in chromatin 
             accessibility using bulk and single-cell transcriptomes (Zhou et al. 
             <i>Nature Communications. </i>8:1038, 2017; Zhou et al. 
             <i>Nucleic Acids Research.</i> 47: e121, 2019), was used for imputation.</p>"), 
        p("The consistently processed and normalized imputation values in ChromBIRD 
          can be readily used for downstream data analysis and mining, greatly 
          enhancing the utility of the source gene expression data. Compared to 
          other existing human chromatin accessibility databases (e.g., ENCODE 
          with 2,083 human DNase-seq, ATAC-seq, and single-nucleus ATAC-seq samples, 
          and ATACdb with 1,493 samples), ChromBIRD's sample size, breadth, and 
          diversity are orders of magnitude larger."), 
        HTML("<p>ChromBIRD provides an interactive web user interface along with 
          multiple analysis tools for data querying, downloading, exploration, 
          and visualization. Using the imputed chromatin accessibility data, 
          users can identify regulatory elements with differential activities 
          across samples, reconstruct dynamic gene regulatory programs along 
          samples’ pseudo-temporal trajectories, and infer the functional 
          contexts of regulatory elements harboring disease-associated genetic 
          variants. ChromBIRD can be accessed online at 
          <a href=\"https://jhubiostatistics.shinyapps.io/ChromBIRD/\" target=\"_blank\">
          https://jhubiostatistics.shinyapps.io/ChromBIRD/</a> 
          and can also be installed locally to improve the efficiency of retrieving 
          and analyzing large datasets.</p>"), 
        
        hr(), 
        
        h4("Contact"), 
        
        p("Yuzi Li: yli493@jh.edu"), 
        p("Weiqiang Zhou: wzhou14@jhu.edu"),
        p("Hongkai Ji: hji@jhu.edu"),
        
        hr(), 
        
        h4("Citation"), 
        
        p("Zhou W, Sherwood B, Ji Z, Xue Y, Du F, Bai J, Ying M, Ji H. 
          Genome-wide prediction of DNase I hypersensitivity using gene expression. 
          Nat Commun. 2017 Oct 19;8(1):1038. doi: 10.1038/s41467-017-01188-x. 
          PMID: 29051481; PMCID: PMC5715040."), 
        
        p("Zhou W, Ji Z, Fang W, Ji H. Global prediction of chromatin accessibility 
          using small-cell-number and single-cell RNA-seq. Nucleic Acids Res. 
          2019 Nov 4;47(19):e121. doi: 10.1093/nar/gkz716. PMID: 31428792; PMCID: PMC6821224.")
      )
    ),
  )
)

server <- function(input, output, session) {
  
  # Load libraries upon going into new page
  start_input_sel <- reactiveVal()
  # pt, group diff, and disease snp libraries only load after input sel libraries loading
  start_pt <- reactiveVal()
  start_group_diff <- reactiveVal()
  start_disease_snp <- reactiveVal()
  start_heatmap <- reactiveVal()
  # gtex snp is independent of input sel libraries
  start_gtex_snp <- reactiveVal()
  
  observeEvent(input$chrombird_nav, {
    if (input$chrombird_nav == "Input Selection") {
      start_input_sel(TRUE)
    } else if (input$chrombird_nav == "PCA and pseudo-time") {
      start_pt(TRUE)
    } else if (input$chrombird_nav == "Group differential analysis") {
      start_group_diff(TRUE)
    } else if (input$chrombird_nav == "Disease SNP analysis") {
      start_disease_snp(TRUE)
    } else if (input$chrombird_nav == "GTEx tissues SNPs") {
      start_gtex_snp(TRUE)
    } 
  })
  
  observeEvent(start_input_sel(), {
    suppressMessages(library(sortable))
  })
  
  observeEvent(start_pt(), {
    suppressMessages(library(caret)) # Remove nearzerovar rows before pca
    suppressMessages(library(mgcv)) # GAM model fitting for hypervar calculation
    suppressMessages(library(MatrixGenerics)) # rowVars used in hypervar calculation
    suppressMessages(library(org.Hs.eg.db)) # For GO enrichment
    suppressMessages(library(topGO)) # For GO enrichment
    suppressMessages(library(igraph)) # For pt calculation
    suppressMessages(library(umap)) # For UMAP plots
    suppressMessages(library(reshape2)) # For melt function in GO along pt plots
    suppressMessages(library(ComplexHeatmap))
    suppressMessages(library(InteractiveComplexHeatmap))
  })
  
  observeEvent(start_group_diff(), {
    suppressMessages(library(caret)) # Remove nearzerovar rows before pca
    suppressMessages(library(mgcv)) # GAM model fitting for hypervar calculation
    suppressMessages(library(MatrixGenerics)) # rowVars used in hypervar calculation
    suppressMessages(library(org.Hs.eg.db)) # For GO enrichment
    suppressMessages(library(topGO)) # For GO enrichment
    suppressMessages(library(limma)) # For group differential test shrinkage
  })
  
  observeEvent(start_disease_snp(), {
    suppressMessages(library(mgcv)) # GAM model fitting for hypervar calculation
    suppressMessages(library(MatrixGenerics)) # rowVars used in hypervar calculation
    suppressMessages(library(ComplexHeatmap))
    suppressMessages(library(InteractiveComplexHeatmap))
  })
  
  observeEvent(start_heatmap(), {
    suppressMessages(library(mgcv)) # GAM model fitting for hypervar calculation
    suppressMessages(library(MatrixGenerics)) # rowVars used in hypervar calculation
    suppressMessages(library(ComplexHeatmap))
    suppressMessages(library(InteractiveComplexHeatmap))
  })
  
  observeEvent(start_gtex_snp(), {
    suppressMessages(library(heatmaply)) # Heatmaply
  })
  
  ### Read info when needed
  
  # Load popover contents
  popover_contents <- reactive({
    readRDS(url("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/popover_contents.rds"))
    # readRDS("../app files/popover_contents.rds")
  })
  
  # Get genomic ranges from file
  genomic_ranges <- reactive({
    readRDS(url("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/BIRD_output_ranges.rds"))
    # readRDS("../app files/BIRD_output_ranges.rds")
  })
  
  bird_ranges <- reactive({
    GRanges(seqnames = genomic_ranges()$Chromosome, 
            ranges = IRanges(start = genomic_ranges()$Start, 
                             end = genomic_ranges()$End))
  })
  
  # Get max ranges for each chromosome
  chr_max_ranges <- reactive({
    df <- data.frame(matrix(ncol = 2, nrow = 0))
    for (chr in chromosomes) {
      chr_start <- min(genomic_ranges()[genomic_ranges()$Chromosome == chr, "Start"])
      chr_end <- max(genomic_ranges()[genomic_ranges()$Chromosome == chr, "End"])
      df <- rbind(df, c(chr_start, chr_end))
    }
    colnames(df) <- c("start", "end")
    rownames(df) <- chromosomes
    df
  })
  
  # Get data.frame matching BIRD genomic ranges to nearest gene
  gbin_tss <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gbin_tss.rds'))
    # read.delim("../app files/gbin_tss.txt")
  })
  
  # Get data.frame matching genes to their TSS's
  gene_tss <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gene_tss.rds'))
    # read.delim("../app files/gene_tss.txt")
  })
  
  # Get data.frame matching diseases/traits to gbins
  snp_gbin <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/snp_gbin.rds'))
    # read.delim("../app files/snp_gbin.txt")
  })
  
  # Get data.frame matching gbins to diseases/traits
  gbin_snp <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gbin_snp.rds'))
    # read.delim("../app files/gbin_snp.txt")
  })
  
  # Get study batch info
  studies_batch <- reactive({
    read.delim("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/studies_batch.txt")
    # read.delim("../app files/studies_batch.txt")
  })
  
  # Read samples table
  all_samples_df <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/samples_df.rds'))
    # readRDS('../app files/samples_df.rds')
  })
  
  # Read database sample averages
  database_sample_avgs <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/sample_avgs.rds'))
    # readRDS('../app files/sample_avgs.rds')
  })
  
  # Read projects table
  proj_df <- reactive({
    df <- readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/proj_df.rds'))
    # df <- readRDS('../app files/proj_df.rds')
    df$file_source <- as.factor(df$file_source)
    df
  })
  
  # Example BLOOD dataset
  blood_example_samples <- reactive({
    # readLines("../tcga_gtex_analysis/blood/strat_age/blood_strat_age.txt")
    readLines(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/blood_example_samples.txt'))
  })
  
  # GTEx tissues SNP tables
  gtex_tissue_table <- reactive({
    df <- proj_df()[proj_df()$file_source == "gtex", c("project", "n_samples")]
    colnames(df) <- c("tissue", "n_samples")
    rownames(df) <- NULL
    df
  })
  
  # GTEx trait table
  gtex_trait_table <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gtex_trait_hypervar.rds'))
    # readRDS('../app files/gtex_trait_hypervar.rds')
  })
  
  # Read annotations (mapping between ENSEMBL and SYMBOL)
  annots <- reactive({
    readRDS(url("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/annots.rds"))
    # readRDS("../app files/annots.rds")
  })
  
  # Read GTEx SNP table
  gtex_trait <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gtex_traits.rds'))
    # readRDS('../app files/gtex_traits.rds')
  })
  
  # Read scaled GTEx SNP table
  scaled_gtex_trait <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/scaled_gtex_traits.rds'))
    # readRDS('../app files/scaled_gtex_traits.rds')
  })
  
  # Read TCGA barcodes
  tcga_barcode <- reactive({
    readRDS(url('http://jilab.biostat.jhsph.edu/software/PDDB/app_files/tcga_barcode.rds'))
    # readRDS('../app files/tcga_barcode.rds')
  })
  
  # Go to input selection on overview page button click
  observeEvent(input$start_exploration, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Input Selection")
  })
  
  # Go to tutorial on overview page button click
  observeEvent(input$to_tut, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
  })
  
  # Go to demo on overview page button click
  observeEvent(input$to_demo, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Application Examples")
  })
  
  # Button: instructions for running from local host
  output$run_from_local_ui <- renderUI({
    if (Sys.getenv('SHINY_PORT') != "") {
      actionButton("show_r_instructions", "Run from local R session", 
                   class = "regular-btn", width = "100%")
    }
  })
  
  # Modal for instructions for running from local host
  observeEvent(input$show_r_instructions, {
    runapp_code <- "if(!require(\"shiny\")) install.packages(\"shiny\")\nshiny::runGitHub(\"test-app\", \"rainali475\")"
    showModal(
      modalDialog(
        HTML(paste0("<p>You can run the app from local R session to work with large studies 
        and lift limits on genomic range selection. 
                    Run the following code from R to start app from local host: </p>")), 
        verbatimTextOutput("runapp_code"), 
        rclipButton(
          inputId = "runapp_code_copy", 
          label = "Copy code", 
          clipText = runapp_code, 
          icon = icon("clipboard"), 
          style = "border: 1px solid white;", 
          class = "regular-btn"
        ), 
        br(), 
        HTML(paste0("<p>There are 2 recommended options for working with large studies. 
              <ol>
              <li>Run app locally and read samples from database
              <p>Run app from local host and go to <b>Input Selection</b> ", icon("arrow-right"), 
                    " <b>Select or upload sample</b> ", icon("arrow-right"), 
                    " <b>Add sample by</b> ", icon("arrow-right"), 
                    " <b>Select from database</b> to add samples from database.</p>
              </li>
              <li>Run app locally and read samples from local path
              <p>Please go to <b>Prediction Download</b> ", icon("arrow-right"), 
                    " <b>RDS download</b> to download the compressed prediction 
                         files. Then, run this app from your <b>local host</b>, 
                        go to <b>Input Selection</b> ", icon("arrow-right"), 
                    " <b>Select or upload sample</b> ", icon("arrow-right"), 
                    " <b>Add sample by</b> ", icon("arrow-right"), 
                    " <b>Select from local path</b> to add local samples.</p>
              </li>
              </ol>
              </p>")),
        easyClose = TRUE
      )
    )
  })
  
  # Go to input selection tutorial on overview page button click
  observeEvent(input$map_input_sel, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "input_sel_tut")
  })
  
  # Go to input selection tutorial on overview page button click
  observeEvent(input$map_download, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "input_sel_tut")
  })
  
  # Go to gtex snp tutorial on overview page button click
  observeEvent(input$map_gtex_snp, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "gtex_snp_tut")
  })
  
  # Go to pca pt tutorial on overview page button click
  observeEvent(input$map_pca_pt, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "pca_pt_tut")
  })
  
  # Go to pca pt tutorial on overview page button click
  observeEvent(input$map_pt_diff, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "pca_pt_tut")
  })
  
  # Go to pca pt tutorial on overview page button click
  observeEvent(input$map_pt_go, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "pca_pt_tut")
  })
  
  # Go to group diff tutorial on overview page button click
  observeEvent(input$map_group_diff, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "diff_group_tut")
  })
  
  # Go to group diff tutorial on overview page button click
  observeEvent(input$map_group_go, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "diff_group_tut")
  })
  
  # Go to disease snp tutorial on overview page button click
  observeEvent(input$map_disease_snp, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "disease_snp_tut")
  })
  
  # Which plot are we downloading
  download_plot <- reactiveVal(NULL)
  
  # Show modal for plot parameter selection
  observeEvent(download_plot(), {
    showModal(
      modalDialog(
        title = "Plot download options", 
        selectInput(
          "plot_download_format", 
          "Format: ", 
          c("png", "tiff", "pdf", "eps")
        ), 
        # Units and color model
        uiOutput("plot_download_format_opt_ui"),
        uiOutput("plot_download_dim_ui"), 
        fluidRow(
          column(
            width = 6, 
            selectInput(
              "plot_download_font", 
              "Font: ", 
              c("Arial"="sans", 
                "Times New Roman"="serif", 
                "Courier"="mono", 
                "Standard Symbols"="symbol")
            )
          ), 
          column(
            width = 6,
            uiOutput("plot_download_ppi_ui")
          )
        ), 
        downloadButton("plot_download", "Confirm and download", 
                       class = "regular-btn"), 
        easyClose = FALSE, 
        footer = actionButton("close_plot_download_modal", "Close", 
                              class = "regular-btn")
      )
    )
  })
  
  # Render UI for plot download format-specific options
  output$plot_download_format_opt_ui <- renderUI({
    req(input$plot_download_format)
    if (input$plot_download_format %in% c("pdf", "eps")) {
      fluidRow(
        column(
          width = 6, 
          selectInput(
            "plot_download_units", 
            "Units: ", 
            list("inches" = "in", 
                 "cm" = "cm", 
                 "mm" = "mm")
          )
        ), 
        column(
          width = 6, 
          selectInput(
            "plot_download_color_model", 
            "Color model: ", 
            list("RGB" = "srgb", 
                 "CMYK" = "cmyk", 
                 "Grayscale" = "gray")
          )
        )
      )
    } else {
      fluidRow(
        column(
          width = 6, 
          selectInput(
            "plot_download_units", 
            "Units: ", 
            list("pixels" = "px", 
                 "inches" = "in", 
                 "cm" = "cm", 
                 "mm" = "mm")
          )
        )
      )
    }
  })
  
  # Render UI for plot download dimensions
  output$plot_download_dim_ui <- renderUI({
    req(input$plot_download_format)
    dim_min <- 4
    dim_max <- 40
    if (input$plot_download_format %in% c("png", "tiff")) {
      req(input$plot_download_units)
      if (input$plot_download_units == "px") {
        dim_min <- 400
        dim_max <- 4000
      } else if (input$plot_download_units == "cm") {
        dim_min <- 100
        dim_max <- 1000
      } else if (input$plot_download_units == "mm") {
        dim_min <- 1000
        dim_max <- 10000
      }
    }
    default_height <- dim_min * 2
    default_width <- dim_min * 2.5
    fluidRow(
      column(
        width = 6,
        sliderInput(
          "plot_download_width", 
          "Width: ", 
          min = dim_min, 
          max = dim_max, 
          value = default_width
        )
      ), 
      column(
        width = 6,
        sliderInput(
          "plot_download_height", 
          "Height: ", 
          min = dim_min, 
          max = dim_max, 
          value = default_height
        )
      )
    )
  })
  
  # Render ppi selection for all formats except pdf
  output$plot_download_ppi_ui <- renderUI({
    req(input$plot_download_format)
    if (input$plot_download_format %in% c("pdf", "eps")) {
      return(NULL)
    } else {
      selectInput(
        "plot_download_ppi", 
        "Resolution (ppi): ", 
        c(72, 96, 300, 600, 900, 1200)
      )
    }
  })
  
  # Download plot
  output$plot_download <- downloadHandler(
    filename = function() {paste0("plot.", input$plot_download_format)},
    content = function(file) {
      if (input$plot_download_format == "png") {
        png(filename = file, 
            width = input$plot_download_width, 
            height = input$plot_download_height, 
            units = input$plot_download_units, 
            res = input$plot_download_ppi, 
            family = input$plot_download_font)
        print(download_plot())
        dev.off()
      } else if (input$plot_download_format == "tiff") {
        tiff(filename = file, 
             width = input$plot_download_width, 
             height = input$plot_download_height, 
             units = input$plot_download_units, 
             res = input$plot_download_ppi, 
             family = input$plot_download_font)
        print(download_plot())
        dev.off()
      } else if (input$plot_download_format == "pdf") {
        inch_width <- input$plot_download_width
        inch_height <- input$plot_download_height
        if (input$plot_download_units == "px") {
          inch_width <- inch_width / input$plot_download_ppi
          inch_height <- inch_height / input$plot_download_ppi
        } else if (input$plot_download_units == "cm") {
          inch_width <- inch_width / 2.54
          inch_height <- inch_height / 2.54
        } else if (input$plot_download_units == "mm") {
          inch_width <- inch_width / 25.4
          inch_height <- inch_height / 25.4
        }
        pdf(file = file, 
            width = inch_width, 
            height = inch_height, 
            family = input$plot_download_font, 
            colormodel = input$plot_download_color_model)
        print(download_plot())
        dev.off()
      } else if (input$plot_download_format == "eps") {
        inch_width <- input$plot_download_width
        inch_height <- input$plot_download_height
        if (input$plot_download_units == "px") {
          inch_width <- inch_width / input$plot_download_ppi
          inch_height <- inch_height / input$plot_download_ppi
        } else if (input$plot_download_units == "cm") {
          inch_width <- inch_width / 2.54
          inch_height <- inch_height / 2.54
        } else if (input$plot_download_units == "mm") {
          inch_width <- inch_width / 25.4
          inch_height <- inch_height / 25.4
        }
        postscript(file = file, 
                   width = inch_width, 
                   height = inch_height,  
                   family = input$plot_download_font, 
                   colormodel = input$plot_download_color_model)
        print(download_plot())
        dev.off()
      }
    }
  )
  
  # Close plot parameter selection modal when asked to
  observeEvent(input$close_plot_download_modal, {
    download_plot(NULL)
    removeModal()
  })
  
  # Which plotly plot are we downloading
  download_plotly <- reactiveVal(NULL)
  
  # Show modal for plot parameter selection
  observeEvent(download_plotly(), {
    showModal(
      modalDialog(
        title = "Plot download options", 
        selectInput(
          "plotly_download_format", 
          "Format: ", 
          c("png", "pdf", "svg")
        ), 
        fluidRow(
          column(
            width = 6,
            sliderInput(
              "plotly_download_width", 
              "Width: ", 
              min = 400, 
              max = 4000, 
              value = 1000
            )
          ), 
          column(
            width = 6,
            sliderInput(
              "plotly_download_height", 
              "Height: ", 
              min = 400, 
              max = 4000, 
              value = 800
            )
          )
        ),
        downloadButton("plotly_download", "Confirm and download", 
                       class = "regular-btn"), 
        easyClose = FALSE, 
        footer = actionButton("close_plotly_download_modal", "Close", 
                              class = "regular-btn")
      )
    )
  })
  
  # Download plot
  output$plotly_download <- downloadHandler(
    filename = function() {paste0("plot.", input$plotly_download_format)},
    content = function(file) {
      file <- gsub("\\\\", "/", file)
      save_image(download_plotly(), 
                 file, 
                 width = input$plotly_download_width, 
                 height = input$plotly_download_height)
    }
  )
  
  # Close plotly parameter selection modal when asked to
  observeEvent(input$close_plotly_download_modal, {
    download_plotly(NULL)
    removeModal()
  })
  
  output$input_sel_page_ui <- renderUI({
    tagList(
      div(style = "display: inline-block;vertical-align: middle;", h2("Input Selection")), 
      div(style = "display: inline-block;vertical-align: middle;", 
          bsButton(
            "input_selection_page_info", 
            label = "", 
            icon = icon("info"), 
            style = "info", 
            size = "extra-small"
          )), 
      bsPopover(
        id = "input_selection_page_info",
        title = "<h3>Input selection steps</h3>",
        content = do.call(paste0, 
                          popover_contents()$input_selection_page_info),
        placement = "right",
        trigger = "focus",
        options = list(container = "body", 
                       html = TRUE)
      ),
      
      tabsetPanel(
        # Tab panel for sample upload and selection
        tabPanel(
          title = "Select or upload sample", 
          tags$div(
            style = "margin-bottom:50px; margin-top:50px;",
            sidebarLayout(
              sidebarPanel(
                uiOutput("sample_add_method_ui"), 
                actionButton("show_sel_samples_table", "Show selected samples table", 
                             class = "important-btn",
                             style = "width: 100%; border: 1px solid white;"), 
                bsTooltip(
                  "show_sel_samples_table", 
                  title = "You will be able to subset the selected samples in this table", 
                  placement = "right",
                  options = list(container = "body", 
                                 html = TRUE)
                ),
                actionButton("sel_example_dat", "Select example dataset: 144 whole blood samples", 
                             style = "width: 100%; border: 1px solid white;", 
                             class = "important-btn"),
                actionButton("clear_sel_samples", "Clear sample selection", 
                             style = "width: 100%; border: 1px solid white;", 
                             class = "regular-btn")
              ), 
              mainPanel(
                uiOutput("sample_add_ui")
              )
            )
          )
        ), 
        
        # Tab panel for genomic range selection
        tabPanel(
          title = "Sample range selection", 
          tags$div(
            style = "margin-bottom:50px; margin-top:50px;",
            
            # Show number of selected bins
            htmlOutput("n_bins_msg"), 
            
            # Button for showing table of selected bins
            actionButton("show_sel_bins_table", "Show selected bins in table", 
                         class = "regular-btn"),
            
            br(),br(),
            
            # Panel for range selection for all samples
            selectInput(
              inputId = "all_sel_method",
              label = tags$span("Range Selection Mode",
                                bsButton("range_sel_method_info", 
                                         label = "", 
                                         icon = icon("info"), 
                                         style = "info", 
                                         size = "extra-small")), 
              choices = c("Use default range", 
                          "Use entire BIRD range", 
                          "BED input", 
                          "Manual")
            ),
            bsPopover(
              id = "range_sel_method_info",
              title = "<h4>Range selection methods</h4>",
              content = do.call(paste0, 
                                popover_contents()$range_sel_method_info),
              placement = "right",
              trigger = "focus",
              options = list(container = "body", 
                             html = TRUE)
            ),
            
            # Default range
            conditionalPanel(
              condition = "input.all_sel_method == 'Use default range'", 
              p("100,000 random BIRD bins throughout the genome are selected. ")
            ),
            
            # BIRD range
            conditionalPanel(
              condition = "input.all_sel_method == 'Use entire BIRD range'", 
              downloadButton("download_bird_range_bed", "Download BIRD output range BED", 
                             class = "regular-btn")
            ),
            
            # BED input
            conditionalPanel(
              condition = "input.all_sel_method == 'BED input'", 
              fileInput("all_bed", 
                        label = "Choose BED file"), 
              textOutput("all_bed_text")
            ), 
            
            # Manual selection
            conditionalPanel(
              condition = "input.all_sel_method == 'Manual'", 
              sidebarLayout(
                sidebarPanel(
                  checkboxInput(
                    "all_sel_all_chr", 
                    label = "Select all chromosomes", 
                    value = FALSE
                  ),
                  checkboxGroupInput(
                    "all_sel_chr", 
                    label = h5("Select chromosome"), 
                    choices = chromosomes), 
                  width = 3
                ), 
                mainPanel(
                  # Add one check box for each chromosome
                  lapply(c(1:22, "X"), function(i) {
                    default_min <- chr_max_ranges()[paste0("chr", i), "start"]
                    default_max <- chr_max_ranges()[paste0("chr", i), "end"]
                    conditionalPanel(
                      condition = paste0("input.all_sel_chr.includes('chr", i, "')"),
                      fluidRow(
                        column(
                          3, 
                          numericInput(paste0("gr", i, "min"), 
                                       "Min", 
                                       default_min)
                        ), 
                        column(
                          6, 
                          sliderInput(
                            paste0("all_genomic_range", i), 
                            label = h5(paste("Chromosome", i, "Range")), 
                            min = default_min, 
                            max = default_max, 
                            value = c(default_min, default_max))
                        ),
                        column(
                          3, 
                          numericInput(paste0("gr", i, "max"), 
                                       "Max", 
                                       default_max)
                        )
                      )
                    )
                  })
                )
              )
            )
          )
        )
      )
    )
  })
  
  # Render UI for sample selection method
  output$sample_add_method_ui <- renderUI({
    method_choices <- list(
      "Select from prediction database" = "sel_db"
      # "Upload text file (under construction)" = "upload_txt", 
      # "Upload bam file (under construction)" = "upload_bam"
    )
    is_local <- Sys.getenv('SHINY_PORT') == ""
    if (is_local) {
      method_choices <- list(
        "Select from prediction database" = "sel_db",
        "Select from local path" = "sel_loc_path"
        # "Upload text file (under construction)" = "upload_txt", 
        # "Upload bam file (under construction)" = "upload_bam"
      )
    }
    tagList(
      selectInput(
        "sample_add_method", 
        label = tags$span("Add sample by: ", 
                          bsButton("sample_add_method_info", 
                                   label = "", 
                                   icon = icon("info"), 
                                   style = "info", 
                                   size = "extra-small")), 
        choices = method_choices
      ), 
      bsPopover(
        id = "sample_add_method_info",
        title = "<h4>Sample selection methods and steps</h4>",
        content = do.call(paste0, 
                          popover_contents()$sample_add_method_info),
        placement = "right",
        trigger = "focus",
        options = list(container = "body", 
                       html = TRUE)
      ),
    )
  })
  
  if (Sys.getenv('SHINY_PORT') == "") {
    dir_roots <- c(working=paste0(getwd(), "/"))
    if (.Platform$OS.type == "windows") {
      sysdrivereport <- system("wmic logicaldisk get caption", intern = TRUE)
      drives <- substr(sysdrivereport[-c(1, length(sysdrivereport))], 1, 1)
      for (d in drives) {
        dir_roots[d] <- paste0(d, ":/")
      }
    } else {
      # unix OS
      dir_roots["root"] <- "/"
    }
    shinyDirChoose(input, 'loc_path', roots=dir_roots, filetypes=c("", "rds"))
  }
  
  loc_path <- reactiveVal(NULL)
  
  # Render message stating selected local path 
  output$loc_path_msg <- renderText({
    req(input$loc_path)
    if (all(class(input$loc_path) == "list")) {
      loc_path(paste0(dir_roots[input$loc_path$root], do.call(file.path, input$loc_path$path[-1])))
      paste("Selected directory:", loc_path())
    } else {
      loc_path(NULL)
      "No path has been selected. "
    }
  })
  
  # Render UI for sample selection and upload
  output$sample_add_ui <- renderUI({
    req(input$sample_add_method)
    if (input$sample_add_method == "sel_db") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Add samples from database")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "database_sel_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "database_sel_info",
          title = "<h3>BIRD predictions database</h3>",
          content = do.call(paste0, 
                            popover_contents()$database_sel_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        HTML("<p>All predictions in database are <b>log<sub>2</sub>-transformed</b>. </p>"),
        tabsetPanel(
          # Tab panel for project selection
          tabPanel(
            title = "Step 1: Project Selection", 
            tags$div(
              style = "margin-top:30px; margin-bottom:30px;", 
              radioButtons(
                "proj_sel_method", 
                "Project selection method: ",
                choices = c("Select from table", "Select with text input"), 
                selected = "Select from table"
              ),
              uiOutput("proj_sel_ui")
            )
          ), 
          
          # Tab panel for samples selection
          tabPanel(
            title = "Step 2: Sample Selection", 
            tags$div(
              style = "margin-top:30px; margin-bottom:30px;", 
              radioButtons(
                "sample_sel_method", 
                "Sample selection method: ",
                choices = c("Select from table", "Select with text input"), 
                selected = "Select from table"
              ),
              uiOutput("sample_sel_ui")
            )
          )
        )
      )
    } else if (input$sample_add_method == "sel_loc_path") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Add samples from local path")), 
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "loc_path_sel_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "loc_path_sel_info",
          title = "<h3>BIRD predictions database</h3>",
          content = do.call(paste0,
                            popover_contents()$loc_path_sel_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        HTML("<p>All predictions assumed to be <b>log<sub>2</sub>-transformed</b>. </p>"),
        shinyDirButton('loc_path', 'Select a local directory', 'Please select a directory', FALSE, 
                       class = "important-btn"), 
        textOutput("loc_path_msg"), 
        HTML("<p>Please make sure the rds files in your indicated path are <b>downloaded from our 
             database</b> or <b>follow the format requirement</b> listed in the popover content (information icon above). </p>"),
        HTML("<p><b>Please be aware that selecting a new directory will cause all previously selected local samples to be removed from selection. </b></p>"), 
        uiOutput("loc_path_sample_add_ui")
      )
    } else if (input$sample_add_method == "upload_txt") {
      tagList(
        fileInput("sample_add_txt_file", 
                  accept = "text/plain", 
                  multiple = TRUE,
                  label = "Choose text file"), 
        textOutput('sample_add_txt_upload_msg'),
        DT::dataTableOutput("sample_add_txt_upload_table"), 
        selectInput("sample_add_txt_file_transform", 
                    "Transformation applied on values: ", 
                    choices = c("log-transformed", "none")),
        actionButton("submit_sample_add_txt_file", "Confirm samples upload", 
                     class = "regular-btn"),
        textOutput("sample_add_txt_submission_msg")
      )
    } else if (input$sample_add_method == "upload_bam") {
      tagList(
        fileInput("sample_add_bam_file", 
                  accept = ".bam", 
                  multiple = TRUE, 
                  label = "Choose BAM files"), 
        DT::dataTableOutput("sample_add_bam_upload_table"), 
        actionButton("submit_add_bam_file", "Confirm samples selection", 
                     class = "regular-btn"), 
        textOutput("sample_add_bam_submission_msg")
      )
    }
  })
  
  # Render UI for local path files selection
  output$loc_path_sample_add_ui <- renderUI({
    req(loc_path())
    tabsetPanel(
      # Tab panel for project selection
      tabPanel(
        title = "Step 1: Project Selection", 
        textOutput("loc_proj_rds_msg"),
        tags$div(
          style = "margin-top:30px; margin-bottom:30px;", 
          div(style = "display: inline-block;vertical-align: middle;", h4("Local project selection table")), 
          div(style = "display: inline-block;vertical-align: middle;", bsButton("loc_project_sel_table_info", 
                                                                                label = "", 
                                                                                icon = icon("info"), 
                                                                                style = "info", 
                                                                                size = "extra-small")), 
          bsPopover(
            id = "loc_project_sel_table_info",
            title = "<h4>Local project selection table</h4>",
            content = do.call(paste0, 
                              popover_contents()$loc_project_sel_table_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          # Display table with project info
          DT::dataTableOutput('loc_proj_table'), 
          actionButton("loc_proj_sel_check", "Check project RDS file", 
                       class = "important-btn"), 
          textOutput("loc_proj_sel_msg")
        )
      ), 
      
      # Tab panel for samples selection
      tabPanel(
        title = "Step 2: Sample Selection", 
        tags$div(
          style = "margin-top:30px; margin-bottom:30px;", 
          radioButtons(
            "loc_sample_sel_method", 
            "Sample selection method: ",
            choices = c("Select from table", "Select with text input"), 
            selected = "Select from table"
          ),
          uiOutput("loc_sample_sel_ui")
        )
      )
    )
  })
  
  # Local path studies
  loc_studies <- reactiveVal(character())
  
  # Update local path studies, clear sample selection table
  observeEvent(loc_path(), {
    # Update local path studies
    rds_files <- list.files(path = loc_path(), pattern = ".rds$")
    studies <- gsub(".rds$", "", rds_files)
    studies <- studies[studies %in% proj_df()$project]
    loc_studies(studies)
    # Clear selected local samples
    selected_samples(selected_samples()[selected_samples()$read_from != "local", ])
    # Clear read local studies list and sample selection table
    loc_studies_li(list())
  })
  
  # Render message for rds files read from local path
  output$loc_proj_rds_msg <- renderText({
    # List local path rds
    rds_files <- list.files(path = loc_path(), pattern = ".rds$")
    if (length(rds_files) == 0) {
      return("No valid files found. Please select a different directory. ")
    }
    paste0("The following rds files are found in your selected directory: ", 
           paste(rds_files, collapse = ", "), 
           ". The files matching existing project ids are listed below.")
  })
  
  # Render local project table
  output$loc_proj_table <- DT::renderDataTable(proj_df()[proj_df()$project %in% loc_studies(), ],
                                               rownames = FALSE,
                                               filter = list(position = 'top', clear = FALSE))
  
  # Message for local project selection
  loc_proj_sel_msg <- reactiveVal(NULL)
  
  # Render message
  output$loc_proj_sel_msg <- renderText({loc_proj_sel_msg()})
  
  # Check selected local projects
  observeEvent(input$loc_proj_sel_check, {
    if (length(input$loc_proj_table_rows_selected) == 0) {
      loc_proj_sel_msg("You have not selected any projects. Please select projects by clicking on the table above. ")
      return(NULL)
    }
    loc_proj_table <- proj_df()[proj_df()$project %in% loc_studies(), ]
    sel_proj <- loc_proj_table$project[input$loc_proj_table_rows_selected]
    rds_files <- file.path(loc_path(), paste0(sel_proj, ".rds"))
    tot_nsamp <- sum(loc_proj_table$n_samples[input$loc_proj_table_rows_selected])
    expected_read_time <- tot_nsamp * 0.04
    read_min <- floor(expected_read_time / 60)
    read_sec <- signif(((expected_read_time / 60) - read_min) * 60, digits = 1)
    if (read_sec == 60) {
      read_sec <- 0
      read_min <- read_min + 1
    }
    showModal(modalDialog(
      p(paste0("You are about to read the following selected files: ", 
               paste(rds_files, collapse = ", "), 
               ". If these files are full studies downloaded from database, they 
               should together take approximately ", 
               read_min, "m", read_sec, "s to be read. Please be aware that 
               performing this action will cause any previously selected local 
               samples to be removed from sample selection table. ")), 
      actionButton("loc_proj_sel_submit", "Okay", 
                   class = "regular-btn"), 
      easyClose = TRUE
    ))
  })
  
  # Local studies matrix
  loc_studies_li <- reactiveVal(list())
  
  # Check selected projects 
  observeEvent(input$loc_proj_sel_submit, {
    loc_proj_table <- proj_df()[proj_df()$project %in% loc_studies(), ]
    sel_proj <- loc_proj_table$project[input$loc_proj_table_rows_selected]
    rds_files <- file.path(loc_path(), paste0(sel_proj, ".rds"))
    valid_proj <- c()
    # Update local studies matrices
    studies_li <- list()
    for (i in 1:length(sel_proj)) {
      proj_mat <- tryCatch({readRDS(rds_files[i])}, error = function(e) {NULL})
      if (is.null(proj_mat)) next
      if (! inherits(proj_mat, "matrix")) next
      if (mode(proj_mat) != "numeric") next
      if (nrow(proj_mat) != nrow(genomic_ranges())) next
      samps <- colnames(proj_mat)
      if (anyDuplicated(samps) || (length(samps) == 0)) next
      actual_samps <- all_samples_df()$sample_id[all_samples_df()$project_id == sel_proj[i]]
      if (! all(samps %in% actual_samps)) next
      if (! all(is.finite(proj_mat))) next
      studies_li[[sel_proj[i]]] <- proj_mat
      valid_proj <- c(valid_proj, sel_proj[i])
    }
    loc_studies_li(studies_li)
    loc_proj_sel_msg(
      if (length(valid_proj) == 0) {
        "No valid study RDS files found in selected files. "
      } else {
        paste0("The following studies are read from selected files: ", 
               paste(valid_proj, collapse = ", "))
      }
    )
    # Remove previously selected local samples from selected samples table
    selected_samples(selected_samples()[selected_samples()$read_from != "local", ])
    removeModal()
  })
  
  # Render UI for sample selection
  output$loc_sample_sel_ui <- renderUI({
    if (input$loc_sample_sel_method == "Select from table") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Sample selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("sample_sel_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "sample_sel_table_info",
          title = "<h4>Sample selection table</h4>",
          content = do.call(paste0, 
                            popover_contents()$sample_sel_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fluidRow(
          column(
            3, 
            actionButton(
              "loc_sample_table_sel_all", 
              "Select all", 
              width = "100%", 
              class = "regular-btn"
            )
          ), 
          column(
            3, 
            actionButton(
              "loc_sample_table_sel_none", 
              "Deselect all", 
              width = "100%", 
              class = "regular-btn"
            )
          )
        ),
        # Display table with sample info
        DT::dataTableOutput('loc_sample_table'), 
        actionButton(
          "loc_submit_sample_sel_table", 
          label = "Confirm sample selection", 
          class = "important-btn"
        ), 
        textOutput("loc_sample_sel_table_submission_msg")
      )
    } else if (input$loc_sample_sel_method == "Select with text input") {
      tagList(
        textAreaInput(
          "loc_sample_sel_text", 
          label = tags$span("Input sample ids (one sample id in each line)", 
                            bsButton("sample_sel_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5
        ),
        bsPopover(
          id = "sample_sel_text_info",
          title = "<h4>Sample selection text</h4>",
          content = do.call(paste0, 
                            popover_contents()$sample_sel_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "loc_sample_sel_txt_file", 
          "Upload txt file indicating sample ids", 
          accept = "text/plain"
        ),
        actionButton(
          "loc_submit_sample_sel_text", 
          label = "Confirm sample selection", 
          class = "important-btn"
        ),
        textOutput("loc_sample_sel_text_submission_msg")
      )
    }
  })
  
  # Define samples data.frame based on user selection
  loc_samples_df <- reactive({
    sel_proj <- names(loc_studies_li())
    df <- all_samples_df()[all_samples_df()$project_id %in% sel_proj, ]
    df$project_id <- as.factor(df$project_id)
    samples <- unique(unlist(lapply(loc_studies_li(), colnames)))
    df <- df[df$sample_id %in% samples,]
    df
  })
  
  # Render output samples table
  output$loc_sample_table <- DT::renderDataTable({
    if (nrow(loc_samples_df()) > 0) {
      df <- data.frame(loc_samples_df(), selected="")
      df$selected[df$sample_id %in% selected_samples()$sample] <- as.character(icon("check"))
      df$selected <- as.factor(df$selected)
    } else {
      df <- NULL
    }
    DT::datatable(df,
                  rownames = FALSE, 
                  filter = list(position = 'top', clear = FALSE), 
                  escape = FALSE)
  })
  
  # Make proxy for controlling selected rows
  loc_sample_table_proxy <- DT::dataTableProxy("loc_sample_table")
  
  # Select all of local sample table
  observeEvent(input$loc_sample_table_sel_all, {
    loc_sample_table_proxy %>% selectRows(input$loc_sample_table_rows_all)
  })
  
  # Deselect all of sample table
  observeEvent(input$loc_sample_table_sel_none, {
    loc_sample_table_proxy %>% selectRows(NULL)
  })
  
  # Update selected samples when data table selection occurs and output message
  loc_sample_sel_table_submission_msg <- reactiveVal("")
  
  # Render sample selection table submission message
  output$loc_sample_sel_table_submission_msg <- renderText({
    loc_sample_sel_table_submission_msg()
  })
  
  # Update selected samples when data table selection occurs
  observeEvent(input$loc_submit_sample_sel_table, {
    if (length(input$loc_sample_table_rows_selected) > 0) {
      # Make samples data.frame from selected samples
      new_samples <- loc_samples_df()[input$loc_sample_table_rows_selected, c('project_id', 'sample_id')]
      colnames(new_samples) <- c('project', 'sample')
      proj_sources <- proj_df()[proj_df()$project %in% new_samples$project, c('project', 'file_source')]
      proj_sources$file_source <- as.character(proj_sources$file_source)
      new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
      # Re-order columns
      new_samples <- new_samples[, c("file_source", "project", "sample")]
      new_samples$read_from <- "local"
      # Remove redundant sample ids
      redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
      # Update selected samples table
      selected_samples(rbind(selected_samples(), new_samples[! new_samples$sample %in% redundant_ids, ]))
      # Clear samples table selected rows
      loc_sample_table_proxy %>% selectRows(NULL)
      if (length(redundant_ids) > 0) {
        loc_sample_sel_table_submission_msg(
          paste("Samples added to selection. The following samples are already present in the current selection:", 
                paste(redundant_ids, collapse = ", "))
        )
      } else {
        loc_sample_sel_table_submission_msg(paste("Selection successful! Samples added to selection. "))
      }
    }
  })
  
  # Update sample selection text area input value based on uploaded file
  observeEvent(input$loc_sample_sel_txt_file, {
    if (! is.null(input$loc_sample_sel_txt_file)) {
      sample_sel_text <- paste(readLines(input$loc_sample_sel_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "loc_sample_sel_text", 
        value = sample_sel_text
      )
    }
  })
  
  # Render sample selection submission text
  output$loc_sample_sel_text_submission_msg <- renderText({
    loc_sample_sel_text_submission_msg()
  })
  
  # Update submission text based on action button and text evaluation results
  loc_sample_sel_text_submission_msg <- eventReactive(input$loc_submit_sample_sel_text, {
    # Read sample ids from submitted text
    sample_ids <- unlist(strsplit(input$loc_sample_sel_text, split = "\n"))
    sample_ids <- sapply(sample_ids, function(sample_id) {
      sample_id <- gsub(" ", "", sample_id)
      sample_id <- gsub("\t", "", sample_id)
      sample_id
    })
    sample_ids <- sample_ids[sample_ids != ""]
    sample_ids <- unique(sample_ids)
    if (length(sample_ids) == 0) {
      return(paste("Selection failed - input is empty."))
    }
    # Check if sample ids exist
    if (any(! sample_ids %in% loc_samples_df()$sample_id)) {
      bad_samples <- sample_ids[which(! sample_ids %in% loc_samples_df()$sample_id)]
      return(paste0("Selection failed. The following samples are not found in selected projects: ", 
                    paste(unique(bad_samples), collapse = ", ")))
    }
    new_samples <- loc_samples_df()[loc_samples_df()$sample_id %in% sample_ids, c('project_id', 'sample_id')]
    colnames(new_samples) <- c('project', 'sample')
    proj_sources <- proj_df()[proj_df()$project %in% new_samples$project, c('project', 'file_source')]
    proj_sources$file_source <- as.character(proj_sources$file_source)
    new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
    # Re-order columns
    new_samples <- new_samples[, c("file_source", "project", "sample")]
    new_samples$read_from <- "local"
    # Check if there is any redundant sample ids
    redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
    # Update selected samples table
    selected_samples(rbind(selected_samples(), new_samples[! new_samples$sample %in% redundant_ids, ]))
    if (length(redundant_ids) > 0) {
      return(paste("Samples added to selection. The following samples are already present in the current selection:", 
                   paste(redundant_ids, collapse = ", ")))
    }
    return(paste("Selection completed!"))
  })
  
  # Render UI for project selection
  output$proj_sel_ui <- renderUI({
    if (input$proj_sel_method == "Select from table") {
      tagList(
        uiOutput("large_studies_msg_ui"),
        div(style = "display: inline-block;vertical-align: middle;", h4("Project selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("project_sel_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "project_sel_table_info",
          title = "<h4>Project selection table</h4>",
          content = do.call(paste0, 
                            popover_contents()$project_sel_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fluidRow(
          column(
            3, 
            actionButton(
              "proj_table_sel_none", 
              "Deselect all", 
              width = "100%", 
              class = "regular-btn"
            )
          ), 
          column(
            2, 
            checkboxInput(
              "proj_table_show_title", 
              "Show study titles",
              value = TRUE
            )
          ),
          column(
            2, 
            checkboxInput(
              "proj_table_show_abstract", 
              "Show study abstracts",
              value = FALSE
            )
          ), 
          column(
            2, 
            checkboxInput(
              "proj_table_show_link", 
              "Show study link", 
              value = TRUE
            )
          )
        ),
        # Display table with project info
        DT::dataTableOutput('proj_table'), 
        uiOutput("rds_download_ui")
      )
    } else if (input$proj_sel_method == "Select with text input") {
      tagList(
        textAreaInput(
          "proj_sel_text", 
          label = tags$span("Input project ids (one project id in each line)", 
                            bsButton("proj_sel_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5),
        bsPopover(
          id = "proj_sel_text_info",
          title = "<h3>Project selection text</h3>",
          content = do.call(paste0, 
                            popover_contents()$proj_sel_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "proj_sel_txt_file", 
          "Upload txt file indicating project ids", 
          accept = "text/plain"
        ),
        actionButton(
          "submit_proj_sel_text", 
          label = "Confirm project selection", 
          class = "regular-btn"
        ),
        textOutput("proj_sel_submission_text")
      )
    }
  })
  
  output$rds_download_ui <- renderUI({
    req(input$proj_table_rows_selected)
    if (length(input$proj_table_rows_selected) > 0) {
      downloadButton(
        "rds_download", 
        "Download RDS file(s)", 
        width = "100%", 
        class = "regular-btn"
      )
    }
  })
  
  # UI for large study manipulation message for app running on server
  output$large_studies_msg_ui <- renderUI({
    if (Sys.getenv('SHINY_PORT') != "") {
      wellPanel(
        fluidRow(
          column(
            6, 
            p("Reading studies with more than 200 samples exceeds shinyapps.io RAM limit, 
              so such large studies are not shown in the project selection table. 
              You will need to run this app from local R session to work with these studies. 
              Click on button on the right to see instructions for working with large studies. ")
          ), 
          column(
            6, 
            actionButton(
              "show_large_study_instructions", 
              "Show instructions for working with large studies", 
              class = "regular-btn"
            ),
            checkboxInput(
              "proj_table_show_large_studies", 
              "Show large studies with more than 200 samples", 
              value = FALSE
            )
          )
        )
      )
    }
  })
  
  # Show large studies instructions
  observeEvent(input$show_large_study_instructions,{
    runapp_code <- "if(!require(\"shiny\")) install.packages(\"shiny\")\nshiny::runGitHub(\"test-app\", \"rainali475\")"
    showModal(
      modalDialog(
        HTML(paste0("<p>You need to run the app from local R session to work with large studies. 
                      Run the following code in R to start app from local host: </p>")), 
        verbatimTextOutput("runapp_code"), 
        rclipButton(
          inputId = "runapp_code_copy", 
          label = "Copy code", 
          clipText = runapp_code, 
          icon = icon("clipboard"), 
          style = "border: 1px solid white;", 
          class = "regular-btn"
        ), 
        br(), 
        HTML(paste0("<p>There are 2 recommended options for working with large studies. 
              <ol>
              <li>Run app locally and read samples from database
              <p>Run app from local host and go to <b>Input Selection</b> ", icon("arrow-right"), 
                    " <b>Select or upload sample</b> ", icon("arrow-right"), 
                    " <b>Add sample by</b> ", icon("arrow-right"), 
                    " <b>Select from database</b> to add samples from database.</p>
              </li>
              <li>Run app locally and read samples from local path
              <p>Please go to <b>Prediction Download</b> ", icon("arrow-right"), 
                    " <b>RDS download</b> to download the compressed prediction 
                         files. Then, run this app from your <b>local host</b>, 
                        go to <b>Input Selection</b> ", icon("arrow-right"), 
                    " <b>Select or upload sample</b> ", icon("arrow-right"), 
                    " <b>Add sample by</b> ", icon("arrow-right"), 
                    " <b>Select from local path</b> to add local samples.</p>
              </li>
              </ol>
              </p>")),
        easyClose = TRUE
      )
    )
  })
  
  # Reactive value containing selected projects index
  proj_table_rows_selected <- reactiveVal()
  
  proj_table <- reactive({
    df <- proj_df()
    if (!is.null(input$proj_table_show_large_studies) && (! input$proj_table_show_large_studies)) {
      df <- df[df$n_samples <= 200, ]
    }
    df
  })
  
  # Render project table
  output$proj_table <- DT::renderDataTable({
    df <- proj_table()
    if (input$proj_table_show_link) {
      df$link <- paste0("<a href=\"https://trace.ncbi.nlm.nih.gov/Traces/?view=study&acc=", 
                        df$project, "\" target=\"_blank\">", df$project, "</a>")
      df$link[df$file_source == "tcga"] <- paste0("<a href=\"https://portal.gdc.cancer.gov/projects/TCGA-", df$project[df$file_source == "tcga"], 
                                                  "\" target=\"_blank\">", df$project[df$file_source == "tcga"], 
                                                  "</a> (Select TCGA program within GDC Cohort Builder)")
      df$link[df$file_source == "gtex"] <- paste0("<a href=\"https://gtexportal.org/home/tissue/\" target=\"_blank\">GTEx tissues</a>")
    }
    rm <- c()
    if (! input$proj_table_show_title) {
      rm <- c(rm, which(colnames(proj_table()) == "study_title"))
    }
    if (! input$proj_table_show_abstract) {
      rm <- c(rm, which(colnames(proj_table()) == "study_abstract"))
    }
    if (length(rm) > 0) {
      df <- df[, - rm, drop=F]
    }
    DT::datatable(df,
                  rownames = FALSE,
                  escape = FALSE, 
                  filter = list(position = 'top', clear = FALSE))
  })
  
  proj_table_proxy <- dataTableProxy("proj_table")
  
  # Deselect all of project table
  observeEvent(input$proj_table_sel_none, {
    proj_table_proxy %>% selectRows(NULL)
  })
  
  # Update project selection text area input value based on uploaded file
  observeEvent(input$proj_sel_txt_file, {
    if (! is.null(input$proj_sel_txt_file)) {
      proj_sel_text <- paste(readLines(input$proj_sel_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "proj_sel_text", 
        value = proj_sel_text
      )
    }
  })
  
  # Update selected projects when data table selection occurs
  observeEvent(input$proj_table_rows_selected, ignoreNULL = FALSE, {
    proj_table_rows_selected(input$proj_table_rows_selected)
  })
  
  # Render project selection submission text
  output$proj_sel_submission_text <- renderText({
    proj_sel_submission_text()
  })
  
  # Update submission text based on action button and text evaluation results
  proj_sel_submission_text <- eventReactive(input$submit_proj_sel_text, {
    # Read group ids from submitted text
    proj_ids <- unlist(strsplit(input$proj_sel_text, split = "\n"))
    proj_ids <- sapply(proj_ids, function(proj_id) {
      proj_id <- gsub(" ", "", proj_id)
      proj_id <- gsub("\t", "", proj_id)
      proj_id
    })
    proj_ids <- proj_ids[proj_ids != ""]
    proj_ids <- unique(proj_ids)
    if (length(proj_ids) == 0) {
      return(paste("Selection failed - input is empty."))
    }
    # Check if project ids exist
    if (any(! proj_ids %in% proj_df()$project)) {
      bad_proj <- proj_ids[which(! proj_ids %in% proj_df()$project)]
      return(paste0("Selection failed. The following projects are not found in database: ", 
                    paste(unique(bad_proj), collapse = ", ")))
    }
    proj_table_rows_selected(which(proj_df()$project %in% proj_ids))
    paste("Selection completed!")
  })
  
  # Render UI for sample selection
  output$sample_sel_ui <- renderUI({
    if (input$sample_sel_method == "Select from table") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Sample selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("sample_sel_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "sample_sel_table_info",
          title = "<h4>Sample selection table</h4>",
          content = do.call(paste0, 
                            popover_contents()$sample_sel_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fluidRow(
          column(
            3, 
            actionButton(
              "sample_table_sel_all", 
              "Select all", 
              width = "100%", 
              class = "regular-btn"
            )
          ), 
          column(
            3, 
            actionButton(
              "sample_table_sel_none", 
              "Deselect all", 
              width = "100%", 
              class = "regular-btn"
            )
          )
        ),
        # Display table with sample info
        DT::dataTableOutput('sample_table'), 
        actionButton(
          "submit_sample_sel_table", 
          label = "Confirm sample selection", 
          class = "important-btn"
        ), 
        textOutput("sample_sel_table_submission_msg"),
        br(), 
        uiOutput("bw_download_ui")
      )
    } else if (input$sample_sel_method == "Select with text input") {
      tagList(
        textAreaInput(
          "sample_sel_text", 
          label = tags$span("Input sample ids (one sample id in each line)", 
                            bsButton("sample_sel_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5
        ),
        bsPopover(
          id = "sample_sel_text_info",
          title = "<h4>Sample selection text</h4>",
          content = do.call(paste0, 
                            popover_contents()$sample_sel_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "sample_sel_txt_file", 
          "Upload txt file indicating sample ids", 
          accept = "text/plain"
        ),
        actionButton(
          "submit_sample_sel_text", 
          label = "Confirm sample selection", 
          class = "important-btn"
        ),
        textOutput("sample_sel_text_submission_msg")
      )
    }
  })
  
  # Bigwig and UCSC genome browser session file download buttons
  output$bw_download_ui <- renderUI({
    if (length(input$sample_table_rows_selected) > 0) {
      fluidRow(
        column(
          3, 
          downloadButton("bw_download", "Download BigWig file(s)", 
                         class = "regular-btn")
        ), 
        column(
          3,
          div(style = "display: inline-block;vertical-align: middle;", 
              downloadButton("ucsc_session_download", "Download session file(s)", 
                             class = "regular-btn")), 
          div(style = "display: inline-block;vertical-align: middle;", 
              bsButton("ucsc_session_info", 
                       label = "", 
                       icon = icon("info"), 
                       style = "info", 
                       size = "extra-small")), 
          bsPopover(
            id = "ucsc_session_info",
            title = "<h4>Sample selection table</h4>",
            content = do.call(paste0, 
                              popover_contents()$ucsc_session_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          )
        )
      )
    }
  })
  
  # Reactive data.frame of selected samples info
  selected_samples <- reactiveVal(setNames(data.frame(matrix(ncol = 4, nrow = 0)), 
                                           c("file_source", "project", "sample", "read_from")))
  
  # Define samples data.frame based on user selection
  samples_df <- reactive({
    selected_proj <- proj_table()$project[proj_table_rows_selected()]
    df <- all_samples_df()[all_samples_df()$project_id %in% selected_proj, ]
    df$project_id <- as.factor(df$project_id)
    df
  })
  
  # Render output samples table
  output$sample_table <- DT::renderDataTable({
    req(samples_df())
    req(nrow(samples_df()) > 0)
    df <- samples_df()
    df$link <- paste0("<a href=\"https://www.ncbi.nlm.nih.gov/sra/?term=", 
                      df$sample_id, "\" target=\"_blank\">", df$sample_id, "</a>")
    file_source <- merge(df, proj_table()[, c("project", "file_source")], by.x = "project_id", by.y = "project")
    df$link[file_source$file_source == "gtex"] <- "<a href=\"https://gtexportal.org/home/histologyPage\" target=\"_blank\">GTEx Histology Viewer</a>"
    df$link[file_source$file_source == "tcga"] <- paste0("<a href=\"https://portal.gdc.cancer.gov/\" target=\"_blank\">GDC Data Portal</a> (Search for ", 
                                                         tcga_barcode()[df$sample_id[file_source$file_source == "tcga"]], ")")
    df$selected <- ""
    df$selected[df$sample_id %in% selected_samples()$sample] <- as.character(icon("check"))
    df$selected <- as.factor(df$selected)
    DT::datatable(df,
                  rownames = FALSE, 
                  filter = list(position = 'top', clear = FALSE), 
                  escape = FALSE)
  })
  
  # Make proxy for controlling selected rows
  sample_table_proxy <- DT::dataTableProxy("sample_table")
  
  # Render sample selection table submission message
  output$sample_sel_table_submission_msg <- renderText({
    sample_sel_table_submission_msg()
  })
  
  # Whether to show warning for number of selected samples
  sample_sel_limit_warn <- reactiveVal(TRUE)
  
  # Turn off warning when asked to
  observeEvent(input$confirm_warning_msg, {
    if (input$sample_sel_limit_warn_off) {
      sample_sel_limit_warn(FALSE)
    }
    removeModal()
  })
  
  # Code for starting app on local R session
  output$runapp_code <- renderText("if(!require(\"shiny\")) install.packages(\"shiny\")\nshiny::runGitHub(\"test-app\", \"rainali475\")")
  
  # Select all of sample table
  observeEvent(input$sample_table_sel_all, {
    sample_table_proxy %>% selectRows(input$sample_table_rows_all)
  })
  
  # Deselect all of sample table
  observeEvent(input$sample_table_sel_none, {
    sample_table_proxy %>% selectRows(NULL)
  })
  
  # Samples that user is trying to add to selection
  add_database_samples <- reactiveVal(NULL)
  
  observeEvent(add_database_samples(), {
    # Evaluate whether selected studies exceed size thresholds
    before_add <- sum(proj_df()$n_samples[proj_df()$project %in% selected_samples()$project])
    if (("BLOOD" %in% selected_samples()$project) && 
        (all(selected_samples()$sample[selected_samples()$project == "BLOOD"] %in% blood_example_samples()))) {
      # Only count BLOOD example dataset if all selected BLOOD samples contained in example dataset
      before_add <- before_add - 1048 + 144
    }
    after_add_proj <- union(unique(add_database_samples()$project), selected_samples()$project)
    after_add <- sum(proj_df()$n_samples[proj_df()$project %in% after_add_proj])
    if (("BLOOD" %in% after_add_proj) && 
        (all(selected_samples()$sample[selected_samples()$project == "BLOOD"] %in% blood_example_samples())) &&
        (all(add_database_samples()$sample[add_database_samples()$project == "BLOOD"] %in% blood_example_samples()))) {
      # Only count BLOOD example dataset if all selected BLOOD samples contained in example dataset
      after_add <- before_add - 1048 + 144
    }
    if (after_add > 200000) {
      # Exceeded size limit
      showModal(
        modalDialog(
          HTML(paste0("You tried to retrieve a set of studies with more than 200,000 samples in total. 
                        This amount of samples is not suitable for analysis with this app. Please 
                        select fewer studies. ")), 
          easyClose = TRUE
        )
      )
      sample_sel_table_submission_msg(paste("Selection failed. Study size limit exceeded. Please select fewer studies. "))
      return(NULL)
    }
    if ((after_add > 200) && (Sys.getenv('SHINY_PORT') != "")) {
      # Exceeded size limit for server
      runapp_code <- "if(!require(\"shiny\")) install.packages(\"shiny\")\nshiny::runGitHub(\"test-app\", \"rainali475\")"
      showModal(
        modalDialog(
          HTML(paste0("<p>You tried to retrieve a set of studies with more than 200 samples in total, 
              which exceeds shinyapps.io RAM limit. 
              You need to run the app from local R session to work with large studies. 
                      Run the following code in R to start app from local host: </p>")), 
          verbatimTextOutput("runapp_code"), 
          rclipButton(
            inputId = "runapp_code_copy", 
            label = "Copy code", 
            clipText = runapp_code, 
            icon = icon("clipboard"), 
            style = "border: 1px solid white;", 
            class = "regular-btn"
          ), 
          br(), 
          HTML(paste0("<p>There are 2 recommended options for working with large studies. 
              <ol>
              <li>Run app locally and read samples from database
              <p>Run app from local host and go to <b>Input Selection</b> ", icon("arrow-right"), 
                      " <b>Select or upload sample</b> ", icon("arrow-right"), 
                      " <b>Add sample by</b> ", icon("arrow-right"), 
                      " <b>Select from database</b> to add samples from database.</p>
              </li>
              <li>Run app locally and read samples from local path
              <p>Please go to <b>Prediction Download</b> ", icon("arrow-right"), 
                      " <b>RDS download</b> to download the compressed prediction 
                         files. Then, run this app from your <b>local host</b>, 
                        go to <b>Input Selection</b> ", icon("arrow-right"), 
                      " <b>Select or upload sample</b> ", icon("arrow-right"), 
                      " <b>Add sample by</b> ", icon("arrow-right"), 
                      " <b>Select from local path</b> to add local samples.</p>
              </li>
              </ol>
              </p>")),
          easyClose = TRUE
        )
      )
      sample_sel_table_submission_msg(paste("Selection failed. Study size limit exceeded. Please select fewer studies. "))
      return(NULL)
    }
    if (sample_sel_limit_warn()) {
      if (((before_add < 100) && (after_add >= 100)) ||
          ((before_add < 500) && (after_add >= 500)) ||
          ((before_add < 1000) && (after_add >= 1000)) ||
          ((before_add < 5000) && (after_add >= 5000)) ||
          ((before_add < 10000) && (after_add >= 10000))) {
        read_ram <- round(after_add / 100, digits = 1)
        read_min <- floor(after_add / 10 / 60)
        read_sec <- signif(((after_add / 10 / 60) - read_min) * 60, digits = 1)
        if (read_sec == 60) {
          read_sec <- 0
          read_min <- read_min + 1
        }
        msg <- paste0("The set of samples you selected require reading prediction data from ", 
                      length(union(unique(add_database_samples()$project), unique(selected_samples()$project))), 
                      " studies, which together contain ", after_add, 
                      " samples in total. Approximately <b>", read_ram, 
                      "GB</b> of RAM will be needed to read these studies. Data retrieval will take approximately <b>", 
                      read_min, "m", read_sec, "s</b>.")
        if (after_add >= 1000) {
          msg <- paste0(msg, "<br><br>Since you are trying to retrieve large studies, 
                         we recommend downloading compressed files of your studies 
                         of interest and reading them from a local path. Please go 
                         to <b>Prediction Download</b> ", icon("arrow-right"), 
                        " <b>RDS download</b> to download the compressed prediction 
                         files and go to <b>Input Selection</b> ", icon("arrow-right"), 
                        " <b>Select or upload sample</b> ", icon("arrow-right"), 
                        " <b>Add sample by</b> ", icon("arrow-right"), 
                        " <b>Select from local path</b> to add local samples to your selection.")
        }
        showModal(
          modalDialog(
            div(style = "display:inline-block; vertical-align:middle;", h4("Warning")), 
            br(), 
            HTML(msg), 
            checkboxInput(
              "sample_sel_limit_warn_off", 
              "Do not show this warning again", 
              value = FALSE
            ), 
            actionButton("confirm_warning_msg", "Okay", 
                         class = "regular-btn"), 
            easyClose = FALSE, 
            footer = NULL
          )
        )
      }
    }
    # Update selected samples table
    selected_samples(rbind(selected_samples(), add_database_samples()))
    add_database_samples(NULL)
  })
  
  # Update selected samples when data table selection occurs
  observeEvent(input$submit_sample_sel_table, {
    if (length(input$sample_table_rows_selected) > 0) {
      # Make samples data.frame from selected samples
      new_samples <- samples_df()[input$sample_table_rows_selected, c('project_id', 'sample_id')]
      colnames(new_samples) <- c('project', 'sample')
      proj_sources <- proj_df()[proj_df()$project %in% new_samples$project, c('project', 'file_source')]
      proj_sources$file_source <- as.character(proj_sources$file_source)
      new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
      # Re-order columns
      new_samples <- new_samples[, c("file_source", "project", "sample")]
      new_samples$read_from <- "database"
      # Remove redundant sample ids
      redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
      add_database_samples(new_samples[! new_samples$sample %in% redundant_ids, ])
      # Clear samples table selected rows
      sample_table_proxy %>% selectRows(NULL)
      if (length(redundant_ids) > 0) {
        sample_sel_table_submission_msg(
          paste("Samples added to selection. The following samples are already present in the current selection:", 
                paste(redundant_ids, collapse = ", "))
        )
      } else {
        sample_sel_table_submission_msg(paste("Selection successful! Samples added to selection. "))
      }
    }
  })
  
  # Update selected samples when data table selection occurs and output message
  sample_sel_table_submission_msg <- reactiveVal("")
  
  # Show pop-up modal for displaying selected samples on button click
  observeEvent(input$show_sel_samples_table, {
    showModal(
      modalDialog(
        div(style = "display:inline-block; vertical-align:middle;", h4("Selected samples table")), 
        div(style = "display:inline-block; vertical-align:middle;", 
            bsButton("sel_samples_table_info",
                     label = "", 
                     icon = icon("info"), 
                     style = "info", 
                     size = "extra-small")),
        bsPopover(
          id = "sel_samples_table_info",
          title = "<h4>Managing selected samples</h4>",
          content = do.call(paste0, 
                            popover_contents()$sel_samples_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        DT::dataTableOutput("sel_samples_table"),
        actionButton("rm_sel_samples", "Remove selected samples from table", 
                     class = "regular-btn"), 
        easyClose = TRUE
      )
    )
  })
  
  # Render selected samples table
  output$sel_samples_table <- DT::renderDataTable(selected_samples(), 
                                                  rownames = FALSE, 
                                                  filter = list(position = 'top', clear = FALSE))
  
  # Update sample selection text area input value based on uploaded file
  observeEvent(input$sample_sel_txt_file, {
    if (! is.null(input$sample_sel_txt_file)) {
      sample_sel_text <- paste(readLines(input$sample_sel_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "sample_sel_text", 
        value = sample_sel_text
      )
    }
  })
  
  # Render sample selection submission text
  output$sample_sel_text_submission_msg <- renderText({
    sample_sel_text_submission_msg()
  })
  
  # Update submission text based on action button and text evaluation results
  sample_sel_text_submission_msg <- eventReactive(input$submit_sample_sel_text, {
    # Read sample ids from submitted text
    sample_ids <- unlist(strsplit(input$sample_sel_text, split = "\n"))
    sample_ids <- sapply(sample_ids, function(sample_id) {
      sample_id <- gsub(" ", "", sample_id)
      sample_id <- gsub("\t", "", sample_id)
      sample_id
    })
    sample_ids <- sample_ids[sample_ids != ""]
    sample_ids <- unique(sample_ids)
    if (length(sample_ids) == 0) {
      return(paste("Selection failed - input is empty."))
    }
    # Check if sample ids exist
    if (any(! sample_ids %in% samples_df()$sample_id)) {
      bad_samples <- sample_ids[which(! sample_ids %in% samples_df()$sample_id)]
      return(paste0("Selection failed. The following samples are not found in selected projects: ", 
                    paste(unique(bad_samples), collapse = ", ")))
    }
    new_samples <- samples_df()[samples_df()$sample_id %in% sample_ids, c('project_id', 'sample_id')]
    colnames(new_samples) <- c('project', 'sample')
    proj_sources <- proj_df()[proj_df()$project %in% new_samples$project, c('project', 'file_source')]
    proj_sources$file_source <- as.character(proj_sources$file_source)
    new_samples <- merge(new_samples, proj_sources, all.x = TRUE)
    # Re-order columns
    new_samples <- new_samples[, c("file_source", "project", "sample")]
    new_samples$read_from <- "database"
    # Check if there is any redundant sample ids
    redundant_ids <- new_samples$sample[new_samples$sample %in% selected_samples()$sample]
    add_database_samples(new_samples[! new_samples$sample %in% redundant_ids, ])
    if (length(redundant_ids) > 0) {
      return(paste("Samples added to selection. The following samples are already present in the current selection:", 
                   paste(redundant_ids, collapse = ", ")))
    }
    return(paste("Selection completed!"))
  })
  
  # # User-input txt sample predictions list
  # user_txt_pred_list <- reactiveVal(list())
  # 
  # # Define sample selection txt files upload table
  # sample_add_txt_upload_table <- reactiveVal(setNames(data.frame(matrix(nrow = 0, ncol = 4)), 
  #                                                     c("file_name", "project", "sample", "n_bins")))
  # 
  # # Update sample selection txt files table according to upload list
  # observeEvent(user_txt_pred_list(), {
  #   upload_df <- setNames(data.frame(matrix(nrow = 0, ncol = 4)), 
  #                         c("file_name", "project", "sample", "n_bins"))
  #   fnames <- names(user_txt_pred_list())
  #   for (fname in fnames) {
  #     project <- gsub('\\.txt$', '', fname)
  #     pred <- user_txt_pred_list()[[fname]]$pred_mat
  #     samples <- colnames(pred)
  #     nbins <- nrow(pred)
  #     df <- data.frame(file_name = fname, 
  #                      project = project, 
  #                      sample = samples, 
  #                      n_bins = nbins)
  #     upload_df <- rbind(upload_df, df)
  #   }
  #   sample_add_txt_upload_table(upload_df)
  # })
  # 
  # # Render sample selection txt files table
  # output$sample_add_txt_upload_table <- DT::renderDataTable(sample_add_txt_upload_table(), 
  #                                                           rownames = FALSE, 
  #                                                           filter = list(position = 'top', clear = FALSE))
  # 
  # # Make proxy for controlling selected rows
  # txt_upload_table_proxy <- DT::dataTableProxy("sample_add_txt_upload_table")
  # 
  # # Render sample text file upload text
  # output$sample_add_txt_upload_msg <- renderText({
  #   cat(sample_add_txt_upload_msg())
  # })
  # 
  # # Define txt file upload message
  # sample_add_txt_upload_msg <- reactiveVal('')
  # 
  # # Update sample selection txt files upload message, list, and table
  # observeEvent(input$sample_add_txt_file, {
  #   txt_handle <- input$sample_add_txt_file
  #   filenum <- length(txt_handle$datapath)
  #   if (!is.null(txt_handle)) {
  #     # Reset upload list and message
  #     user_txt_pred_list(list())
  #     sample_add_txt_upload_msg('')
  #     withProgress(message = 'Reading in txt files',detail="0%",{
  #       for (i in 1:filenum) {
  #         txt_info <- list()
  #         incProgress(1/filenum, detail=paste0(round(i/filenum*100),"%"))
  #         name <- txt_handle$name[i]
  #         user_pred <- tryCatch({read.table(txt_handle$datapath[i], header = TRUE, check.names = FALSE)}, 
  #                               error = function(e) e)
  #         if (inherits(user_pred, "error")) {
  #           # Add message and move on to examine next file
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name, 
  #                                            " cannot be opened/read. Please check file format.", 
  #                                            "\n"))
  #           next
  #         }
  #         if ((length(colnames(user_pred)) < 4) || (! all(colnames(user_pred)[1:3] == c('Chromosome', "Start", "End")))) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " has invalid format. Please check text file format.", 
  #                                            "\n"))
  #           next
  #         }
  #         if (! all(user_pred$Chromosome %in% chromosomes)) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " has bad input in Chromosome column. Please check text file format.", 
  #                                            "\n"))
  #           next
  #         }
  #         if ((! is.integer(user_pred$Start)) || (! is.integer(user_pred$End))) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " has invalid format. Start and End columns must be integers.", 
  #                                            "\n"))
  #           next
  #         }
  #         if (! all(sapply(user_pred[, 4:ncol(user_pred)], is.numeric))) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " has invalid format. Sample chromatin accessibility values must all be numeric.", 
  #                                            "\n"))
  #           next
  #         }
  #         if (! all(user_pred[, 2:ncol(user_pred)] >= 0)) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " has invalid values. Genomic positions and chromatin accessibility values must not be negative.", 
  #                                            "\n"))
  #           next
  #         }
  #         if (any(table(colnames(user_pred)[4:ncol(user_pred)]) > 1)) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " contains redundant sample ids.", 
  #                                            "\n"))
  #           next
  #         }
  #         pred_matrix <- data.matrix(user_pred[, 4:ncol(user_pred), drop = FALSE])
  #         gr <- GRanges(seqnames = user_pred$Chromosome, 
  #                       ranges = IRanges(start = user_pred$Start, 
  #                                        end = user_pred$End))
  #         valid_bins <- gr %in% bird_ranges
  #         if (! all(valid_bins)) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " lines ", 
  #                                            paste(which(! valid_bins) + 1, collapse = ", "), 
  #                                            " contain genomic bins that do not match any BIRD prediction bins. ", 
  #                                            "Please check the BIRD output range file for a list of BIRD output bins.", 
  #                                            "\n"))
  #           next
  #         }
  #         if (length(unique(gr)) != length(gr)) {
  #           sample_add_txt_upload_msg(paste0(sample_add_txt_upload_msg(), 
  #                                            name,
  #                                            " contains repeated genomic bins.", 
  #                                            "\n"))
  #           next
  #         }
  #         txt_info[['gr']] <- gr
  #         txt_info[['pred_mat']] <- pred_matrix
  #         txt_info_list <- list()
  #         txt_info_list[[name]] <- txt_info
  #         # Add to upload list
  #         user_txt_pred_list(c(user_txt_pred_list(), txt_info_list))
  #       }
  #     })
  #   }
  # })
  # 
  # # User-input txt sample predictions data.frame
  # user_txt_pred_df <- reactiveVal(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
  # 
  # # User-input txt sample genomic ranges data.frame
  # user_txt_gr_list <- reactiveVal(list())
  # 
  # # Render sample text file selection submission text
  # output$sample_add_txt_submission_msg <- renderText({
  #   sample_add_txt_submission_msg()
  # })
  # 
  # # Update submission text based on text upload and evaluation results
  # sample_add_txt_submission_msg <- eventReactive(input$submit_sample_add_txt_file, {
  #   if (nrow(sample_add_txt_upload_table()) == 0) {
  #     return(paste("Sample selection failed. No txt file has been uploaded. Please upload BAM files first. "))
  #   }
  #   if (length(input$sample_add_txt_upload_table_rows_selected) == 0) {
  #     return(paste("Sample selection failed. No txt file has been selected in the above table. "))
  #   }
  #   sel_rows <- sample_add_txt_upload_table()[input$sample_add_txt_upload_table_rows_selected, ]
  #   # Check for redundant sample ids
  #   sel_fnames <- sel_rows$file_name
  #   sel_samples <- sel_rows$sample
  #   redundant_ids <- selected_samples()$sample[selected_samples()$sample %in% sel_samples]
  #   if (any(table(sel_samples) > 1)) {
  #     return(paste("Sample selection failed. Selected samples have redundant ids."))
  #   }
  #   if (length(redundant_ids) > 0) {
  #     return(paste("Sample selection failed. The following sample ids are already present in current selection:", 
  #                  paste(redundant_ids, collapse = ", ")))
  #   }
  #   # Check if project ranges incompatible with already selected project
  #   for (fname in unique(sel_fnames)) {
  #     gr <- user_txt_pred_list()[[fname]]$gr
  #     project <- unique(sel_rows[sel_fnames == fname, 'project'])
  #     if (project %in% names(user_txt_gr_list())) {
  #       sel_proj_gr <- user_txt_gr_list()[[project]]
  #       if ((! all(gr %in% sel_proj_gr)) || (! all(sel_proj_gr %in% gr))) {
  #         return(paste("Sample selection failed. Project", 
  #                      project, 
  #                      "genomic ranges do not match those of selected samples under same project name."))
  #       }
  #     }
  #   }
  #   # Check if project ranges are the same for same selected project
  #   sel_projects <- gsub('\\.txt$', '', sel_fnames)
  #   for (proj in unique(sel_projects)) {
  #     proj_files <- unique(sel_rows[sel_rows$project == proj, 'file_name'])
  #     if (length(proj_files) > 1) {
  #       for (i in 2:length(proj_files)) {
  #         gr1 <- user_txt_pred_list()[[proj_files[i-1]]]$gr
  #         gr2 <- user_txt_pred_list()[[proj_files[i]]]$gr
  #         if ((! all(gr1 %in% gr2)) || (! all(gr2 %in% gr1))) {
  #           return(paste("Sample selection failed. Project", 
  #                        project, 
  #                        "genomic ranges are not consistent."))
  #         }
  #       }
  #     }
  #   }
  #   for (fname in unique(sel_fnames)) {
  #     gr <- user_txt_pred_list()[[fname]]$gr
  #     file_samples <- sel_rows[sel_fnames == fname, 'sample']
  #     project <- sel_rows[sel_fnames == fname, 'project']
  #     pred_matrix <- user_txt_pred_list()[[fname]]$pred_mat[, file_samples, drop = FALSE]
  #     hits <- findOverlaps(bird_ranges, gr)
  #     full_pred <- matrix(0, length(bird_ranges), length(file_samples))
  #     colnames(full_pred) <- colnames(pred_matrix)
  #     full_pred[hits@from, ] <- pred_matrix
  #     # Log-transform
  #     if (input$sample_add_txt_file_transform == 'none') {
  #       full_pred <- log2(full_pred + 1)
  #     }
  #     # Add samples to selected txt samples data.frame
  #     user_txt_pred_df(cbind(user_txt_pred_df(), full_pred))
  #     if (! unique(project) %in% names(user_txt_gr_list())) {
  #       # Add samples range to selected txt samples range list
  #       new_gr_list <- list()
  #       new_gr_list[[unique(project)]] <- gr
  #       user_txt_gr_list(c(user_txt_gr_list(), new_gr_list))
  #     }
  #     # Add samples to selected samples table
  #     selected_samples(rbind(selected_samples(), data.frame(file_source = paste0("user_txt_upload/", fname), 
  #                                                           project = project, 
  #                                                           sample = file_samples)))
  #   }
  #   # Clear upload table selected rows
  #   txt_upload_table_proxy %>% selectRows(NULL)
  #   return(paste("Samples successfully added to selection. "))
  # })
  # 
  # # Define sample selection BAM files upload list
  # user_bam_upload_list <- reactiveVal(list())
  # 
  # # Define sample selection BAM files upload table
  # sample_add_bam_upload_table <- reactiveVal(setNames(data.frame(matrix(nrow = 0, ncol = 4)), 
  #                                                     c("name", "reads", "type", "n_covered_bins")))
  # 
  # # Update sample selection BAM files table according to upload list
  # observeEvent(user_bam_upload_list(), {
  #   fnames <- names(user_bam_upload_list())
  #   type <- sapply(fnames, function(x) {user_bam_upload_list()[[x]]$type})
  #   reads <- sapply(fnames, function(x) {user_bam_upload_list()[[x]]$reads})
  #   n_covered_bins <- sapply(fnames, function(x) {user_bam_upload_list()[[x]]$n_covered_bins})
  #   sample_add_bam_upload_table(data.frame(name = fnames, 
  #                                          reads = reads, 
  #                                          type = type, 
  #                                          n_covered_bins = n_covered_bins))
  # })
  # 
  # # Render sample selection BAM files table
  # output$sample_add_bam_upload_table <- DT::renderDataTable(sample_add_bam_upload_table(), 
  #                                                           rownames = FALSE, 
  #                                                           filter = list(position = 'top', clear = FALSE))
  # 
  # # Make proxy for controlling selected rows
  # bam_upload_table_proxy <- DT::dataTableProxy("sample_add_bam_upload_table")
  # 
  # # Update sample selection BAM files upload list and table
  # observeEvent(input$sample_add_bam_file, {
  #   bam_handle <- input$sample_add_bam_file
  #   filenum <- length(bam_handle$datapath)
  #   if (!is.null(bam_handle)) {
  #     user_bam_upload_list(list())
  #     withProgress(message = 'Reading in BAM files',detail="0%",{
  #       for (i in 1:filenum) {
  #         bam_info <- list()
  #         incProgress(1/filenum, detail=paste0(round(i/filenum*100),"%"))
  #         name <- bam_handle$name[i]
  #         bamfile <- BamFile(bam_handle$datapath[i])
  #         tmpsingle <- readGAlignments(bamfile)
  #         tmppair <- readGAlignmentPairs(bamfile)
  #         tmppair <- tmppair[!is.na(as.vector(seqnames(tmppair)))]
  #         pairendtf <- testPairedEndBam(bamfile)
  #         if (pairendtf) {
  #           tmp <- tmppair
  #           startpos <- pmin(start(first(tmp)),start(last(tmp)))
  #           endpos <- pmax(end(first(tmp)),end(last(tmp)))
  #           tmp <- GRanges(seqnames=seqnames(tmp),IRanges(start=startpos,end=endpos))
  #           bam_info[['type']] <- "paired-end"
  #         } else {
  #           tmp <- GRanges(tmpsingle)            
  #           bam_info[['type']] <- "single-end"
  #         }
  #         bam_info[['gr']] <- tmp
  #         bam_info[['reads']] <- length(tmp)
  #         hits <- findOverlaps(bird_ranges, tmp)
  #         bam_info[['n_covered_bins']] <- length(unique(hits@from))
  #         # Update upload list
  #         bam_info_list <- list()
  #         bam_info_list[[name]] <- bam_info
  #         user_bam_upload_list(c(user_bam_upload_list(), bam_info_list))
  #       }
  #     })
  #   }
  # })
  # 
  # # User-input BAM sample predictions data.frame
  # user_bam_pred_df <- reactiveVal(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
  # 
  # # Render sample BAM file selection submission text
  # output$sample_add_bam_submission_msg <- renderText({
  #   sample_add_bam_submission_msg()
  # })
  # 
  # # Update submission text based on BAM upload and evaluation results
  # sample_add_bam_submission_msg <- eventReactive(input$submit_add_bam_file, {
  #   if (nrow(sample_add_bam_upload_table()) == 0) {
  #     return(paste("Sample selection failed. No BAM file has been uploaded. Please upload BAM files first. "))
  #   }
  #   if (length(input$sample_add_bam_upload_table_rows_selected) == 0) {
  #     return(paste("Sample selection failed. No BAM file has been selected in the above table. "))
  #   }
  #   sel_rows <- sample_add_bam_upload_table()[input$sample_add_bam_upload_table_rows_selected, ]
  #   # Check for redundant sample ids
  #   sel_fnames <- sel_rows$name
  #   # Remove .bam extension
  #   sel_samples <- gsub(".bam", "", sel_fnames)
  #   redundant_ids <- selected_samples()$sample[selected_samples()$sample %in% sel_samples]
  #   if (length(redundant_ids) > 0) {
  #     return(paste("Sample selection failed. The following sample ids are already present in current selection:", 
  #                  paste(redundant_ids, collapse = ", ")))
  #   }
  #   # Check for samples outside of BIRD prediction range
  #   empty_samples <- sel_rows[sel_rows$n_covered_bins == 0, 'name']
  #   empty_samples <- gsub(".bam", "", empty_samples)
  #   if (length(empty_samples) > 0) {
  #     return(paste("Sample selection failed. The following samples have 0 reads mapped to BIRD output genomic bins:", 
  #                  paste(empty_samples, collapse = ", ")))
  #   }
  #   # Add samples to selected samples table
  #   selected_samples(rbind(selected_samples(), data.frame(file_source = "user_bam_upload", 
  #                                                         project = "bam_upload", 
  #                                                         sample = sel_samples)))
  #   # Add samples to uploaded BAM predictions data.frame
  #   log_pred_df <- sapply(sel_fnames, function(fname) {
  #     counts <- countOverlaps(bird_ranges, user_bam_upload_list()[[fname]]$gr)
  #     log2(counts + 1)
  #   })
  #   colnames(log_pred_df) <- sel_samples
  #   user_bam_pred_df(cbind(user_bam_pred_df(), log_pred_df))
  #   # Clear upload table selected rows
  #   bam_upload_table_proxy %>% selectRows(NULL)
  #   return(paste("Samples successfully added to selection. "))
  # })
  
  # Remove selected rows from samples table upon button click
  observeEvent(input$rm_sel_samples, {
    if (length(input$sel_samples_table_rows_selected) > 0) {
      rm_rows <- selected_samples()[input$sel_samples_table_rows_selected, ]
      selected_samples(selected_samples()[- input$sel_samples_table_rows_selected, ])
      if (any(startsWith(rm_rows$file_source, "user_txt_upload/"))) {
        rm_projects <- unique(rm_rows[startsWith(rm_rows$file_source, "user_txt_upload/"), "project"])
        rm_samples <- rm_rows[startsWith(rm_rows$file_source, "user_txt_upload/"), "sample"]
        # Remove projects from selected txt samples range list
        updated_gr_list <- user_txt_gr_list()
        updated_gr_list[rm_projects[! rm_projects %in% selected_samples()$project]] <- NULL
        user_txt_gr_list(updated_gr_list)
        # Remove samples from selected txt samples data.frame
        keep_samples <- ! (colnames(user_txt_pred_df()) %in% rm_samples)
        user_txt_pred_df(user_txt_pred_df()[, keep_samples, drop = FALSE])
      } 
      if (any(rm_rows$file_source == "user_bam_upload")) {
        rm_samples <- rm_rows[rm_rows$file_source == "user_bam_upload", "sample"]
        keep_samples <- ! (colnames(user_bam_pred_df()) %in% rm_samples)
        user_bam_pred_df(user_bam_pred_df()[, keep_samples, drop = FALSE])
      }
    }
  })
  
  # Clear selected samples on button click pop-up
  observeEvent(input$clear_sel_samples, {
    showModal(modalDialog(
      p("Clear all selected samples?"), 
      actionButton("clear_sel_samples_confirm", "Yes", 
                   class = "regular-btn")
    ))
  })
  
  # Clear selected samples on button click
  observeEvent(input$clear_sel_samples_confirm, {
    selected_samples(setNames(data.frame(matrix(ncol = 4, nrow = 0)), 
                              c("file_source", "project", "sample", "read_from")))
    # user_txt_gr_list(list())
    # user_txt_pred_df(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
    # user_bam_pred_df(data.frame(matrix(nrow = length(bird_ranges), ncol = 0)))
    removeModal()
  })
  
  # Select example BLOOD data set 
  observeEvent(input$sel_example_dat, {
    selected_samples(data.frame(file_source="gtex", 
                                project="BLOOD", 
                                sample=blood_example_samples(), 
                                read_from="database"))
    showModal(
      modalDialog(
        p("144 GTEx BLOOD samples have been selected. 
          Please note that all other previously selected samples were removed from selection."), 
        p("You may use this dataset to replicate the blood pseudo-temporal analysis case study. "), 
        p("If you encounter issues related to insufficient RAM, please try to run the 
          ChromBIRD app on your local computer instead of using the remote server."),
        checkboxInput(
          "show_example_dat_details", 
          "Show example dataset details", 
          value = FALSE
        ),
        uiOutput("example_dat_details"),
        easyClose = TRUE
      )
    )
  })
  
  output$example_dat_details <- renderUI({
    if (input$show_example_dat_details) {
      p("The demo dataset includes 144 age-stratified whole blood samples from GTEx BLOOD dataset, 
        with 24 samples from each age group randomly selected from whole blood samples in BLOOD dataset. ")
    }
  })
  
  output$download_bird_range_bed <- downloadHandler(
    filename = "BIRD_range.bed", 
    content = function(file) {
      write.table(genomic_ranges(), file, quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
    }
  )
  
  # Toggle select all box for all samples ranges in Sample Range Selection Tab
  observe({
    req(input$all_sel_all_chr)
    updateCheckboxGroupInput(
      session,
      "all_sel_chr", 
      selected = if (input$all_sel_all_chr) chromosomes
    )
  })
  
  # Update slider range based on numeric input
  lapply(c(1:22, "X"), function(i) {
    observeEvent(input[[paste0("gr", i, "min")]] | input[[paste0("gr", i, "max")]], {
      updateSliderInput(inputId = paste0("all_genomic_range", i), 
                        value = c(input[[paste0("gr", i, "min")]], input[[paste0("gr", i, "max")]]))
    })
  })
  
  # BED range selection message
  output$all_bed_text <- renderText({all_bed_msg()})
  all_bed_msg <- reactiveVal()
  
  # Custom input ranges from range selection tab
  custom_gr <- reactive({
    req(input$all_sel_method)
    if (input$all_sel_method == 'Use default range') {
      # # Default ranges is chr1
      # return(GRanges(seqnames = "chr1", 
      #                ranges = IRanges(start = chr_max_ranges()["chr1", "start"], 
      #                                 end = chr_max_ranges()["chr1", "end"])))
      # Default is random 100,000 bins from entire genome
      set.seed(12345)
      return(bird_ranges()[sample(1:length(bird_ranges()), 1e5)])
    } 
    if (input$all_sel_method == 'Use entire BIRD range') {
      # All BIRD output ranges
      return(bird_ranges())
    } 
    if (input$all_sel_method == 'Manual') {
      gr <- GRanges()
      for (chr in input$all_sel_chr) {
        # Get user queried chromosome range from slider input
        range <- input[[paste0("all_genomic_range", sub("chr", "", chr))]]
        chr_gr <- GRanges(seqnames = chr, 
                          ranges = IRanges(start = range[1], end = range[2]))
        gr <- suppressWarnings(c(gr, chr_gr))
      }
      return(gr)
    } 
    # Get custom ranges from BED input
    if (is.null(input$all_bed)) {
      return(GRanges())
    }
    bed_path <- input$all_bed$datapath
    
    # Check BED file contents
    err <- tryCatch(
      {
        bed_df <- read.table(bed_path)
        validate(
          need(ncol(bed_df) >= 3, 
               paste("BED file must contain at least 3 space- or tab-separated columns. ")), 
          need(nrow(bed_df) > 0, 
               paste("BED file must contain at least 1 row. ")),
          need(all(bed_df[, 1] %in% chromosomes), 
               paste("BED file first column must be chromosomes. Valid values are:", 
                     paste(chromosomes, collapse = ", "))), 
          need(all(bed_df[, 2:3] %% 1 == 0), 
               "BED file second and third columns must be integers")
        )
        bed_df <- bed_df[, 1:3]
        NULL
      }, 
      error = function(e) {
        e$message
      }
    )
    all_bed_msg(err)
    if (is.null(err)) {
      return(GRanges(seqnames = bed_df[, 1], 
                     ranges = IRanges(start = bed_df[, 2], 
                                      end = bed_df[, 3])))
    } else {
      return(GRanges())
    }
  })
  
  # Parse genomic bin character vector of format "chr<n> (start-end)" to data.frame
  parse_gbin <- function(gbin_char) {
    range <- sub('chr.*\\(', '', gbin_char)
    range <- sub('\\)', '', range)
    range_list <- strsplit(range, '-')
    start <- unlist(lapply(range_list, function (x) {x[1]}))
    end <- unlist(lapply(range_list, function (x) {x[2]}))
    chromosome <- sub('\\s\\(.*', '', gbin_char)
    data.frame(chromosome = as.factor(chromosome), start = as.integer(start), end = as.integer(end))
  }
  
  sel_bins_i <- reactiveVal()
  
  n_bins_selected <- reactiveVal(0)
  
  observe({
    req(custom_gr())
    hits <- unique(findOverlaps(bird_ranges(), custom_gr())@from)
    if ((length(hits) > 120000) && (Sys.getenv('SHINY_PORT') != "")) hits <- hits[1:120000]
    sel_bins_i(hits)
    n_bins_selected(length(hits))
  })
  
  # Message showing number of selected bins
  output$n_bins_msg <- renderUI({
    msg <- paste("<p>The selected genomic positions contain", strong(n_bins_selected()), "BIRD prediction bins. </p>")
    len_sel <- length(unique(findOverlaps(bird_ranges(), custom_gr())@from))
    if ((len_sel > 120000) && (Sys.getenv('SHINY_PORT') != "")) {
      msg <- paste0(msg, "<p style=\"color:red;\">You selected ", len_sel, 
                    " bins in your last attempt. As you can select up to 120,000 
                    bins on server, only the first 120,000 bins in your selection 
                    have been selected. Running this app from local R session allows 
                    more bins to be selected. </p>")
    }
    HTML(msg)
  })
  
  output$sel_bins_table <- renderDataTable({
    df <- genomic_ranges()[sel_bins_i(), ]
    df$Chromosome <- as.factor(df$Chromosome)
    df
  }, rownames = FALSE, 
  filter = list(position = 'top', clear = FALSE))
  
  # Show selected bins table modal
  observeEvent(input$show_sel_bins_table, {
    showModal(
      modalDialog(
        title = "Selected bins table", 
        downloadButton("sel_bins_table_download", "Download BED of selected bins", 
                       class = "regular-btn"),
        dataTableOutput("sel_bins_table"), 
        size = "l",
        easyClose = TRUE
      )
    )
  })
  
  output$sel_bins_table_download <- downloadHandler(
    filename = "BIRD_selected_bins.bed", 
    content = function(file) {
      write.table(genomic_ranges()[sel_bins_i(), ], file = file, 
                  row.names = F, col.names = F, sep = "\t", quote = F)
    }
  )
  
  # Get all predictions for selected database samples in data.frame
  get_database_pred_mat <- function(custom_range) {
    database_studies <- unique(selected_samples()$project[selected_samples()$read_from == "database"])
    # Subset selected samples and range for each study
    hits <- findOverlaps(bird_ranges(), custom_range)
    bird_i <- sort(unique(hits@from))
    pred_mat <- matrix(nrow=length(bird_i), ncol=0)
    gbins <- genomic_ranges()[bird_i, , drop=F]
    rownames(pred_mat) <- paste0(gbins$Chromosome, " (", gbins$Start, "-", gbins$End, ")")
    if (length(database_studies) == 0) {
      return(pred_mat)
    }
    showModal(modalDialog("Retrieving predictions...", footer = NULL, easyClose = TRUE, size = "s"))
    studies <- unique(selected_samples()$project[selected_samples()$read_from == "database"])
    for (i in match(studies, studies_batch()$study)) {
      study <- studies_batch()$study[i]
      sel_samples <- selected_samples()$sample[(selected_samples()$project == study) & 
                                                 (selected_samples()$read_from == "database")]
      rds_url <- paste0("http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b", 
                        studies_batch()$batch[i], 
                        "/", study, ".rds")
      if ((study == "BLOOD") && (all(sel_samples %in% blood_example_samples()))) {
        # User selected both only blood samples from example study
        rds_url <- "http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b18/BLOOD_example_dataset.rds"
      }
      study_mat <- readRDS(url(rds_url))
      # if ((study == "BLOOD") && (all(sel_samples %in% blood_example_samples()))) {
      #   # User selected both only blood samples from example study
      #   study_mat <- readRDS("../app files/BLOOD_example_dataset.rds")
      # } else {
      #   study_mat <- readRDS(url(rds_url))
      # }
      pred_mat <- cbind(pred_mat, study_mat[bird_i, sel_samples, drop=F])
    }
    removeModal()
    return(pred_mat)
  }
  
  # Get all predictions for selected local samples in matrix
  get_local_pred_mat <- function(custom_range) {
    local_studies <- unique(selected_samples()$project[selected_samples()$read_from == "local"])
    # Subset selected samples and range for each study
    hits <- findOverlaps(bird_ranges(), custom_range)
    bird_i <- sort(unique(hits@from))
    all_pred_li <- lapply(as.character(local_studies), function(study) {
      sel_samples <- selected_samples()$sample[(selected_samples()$project == study) & 
                                                 (selected_samples()$read_from == "local")]
      study_mat <- loc_studies_li()[[study]]
      study_mat[bird_i, sel_samples, drop=F]
    })
    pred_mat <- do.call(cbind, all_pred_li)
    gbins <- genomic_ranges()[bird_i, , drop=F]
    rownames(pred_mat) <- paste0(gbins$Chromosome, " (", gbins$Start, "-", gbins$End, ")")
    return(pred_mat)
  }
  
  # UI for download buttons
  output$download_zip_txt_ui <- renderUI({
    if (sum(selected_samples()$read_from == "database") == 0) {
      textOutput("download_msg_zip_txt")
    } else if (length(n_bins_selected()) == 0) {
      p("Please select at least 1 genomic bin. ")
    } else {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h2("txt Download")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "txt_download_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "txt_download_page_info",
          title = "<h3>BIRD prediction txt/zip formats</h3>",
          content = do.call(paste0, 
                            popover_contents()$txt_download_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        textOutput("download_msg_zip_txt"),
        downloadButton("txt_download", "Download txt file", 
                       class = "important-btn"),
        downloadButton("zip_download", "Download zip file", 
                       class = "important-btn"), 
        br(), 
        div(
          HTML("RDS, BigWig, and UCSC Genome Browser session files download are 
          integrated into Input Selection. See the "), 
          actionLink("tut_input_sel_tut_link", "Input Selection Tutorial"), 
          HTML(" for more details. ")
        ),
      )
    }
  })
  
  # Txt download
  output$txt_download <- downloadHandler(
    filename = "BIRD_prediction.txt", 
    content = function(file) {
      # Make single txt file
      pred_mat <- get_database_pred_mat(bird_ranges()[sel_bins_i()])
      pred_df <- cbind(parse_gbin(rownames(pred_mat)), pred_mat)
      showModal(modalDialog(p("Preparing for download..."), 
                            p("This may take a few minutes depending on the size of the files to be downloaded. 
                              Download will begin automatically when this is done. Thank you for your patience. "), 
                            footer = NULL, easyClose = TRUE, size = "s"))
      write.table(pred_df, file, row.names = FALSE, quote = FALSE, sep = "\t")
      removeModal()
    }
  )
  
  # Zip download
  output$zip_download <- downloadHandler(
    filename = "BIRD_prediction.zip",
    content = function(file) {
      # Make zip file
      # Create temp folder to hold prediction files
      tmp <- tempfile(pattern = "zip", tmpdir = tmp_dir)
      dir.create(tmp)
      tmp_fpaths <- c()
      # Write the appropriate prediction to table
      pred_mat <- get_database_pred_mat(bird_ranges()[sel_bins_i()])
      gbins <- parse_gbin(rownames(pred_mat))
      showModal(modalDialog(p("Preparing for download..."), 
                            p("This may take a few minutes depending on the size of the files to be downloaded. 
                              Download will begin automatically when this is done. Thank you for your patience. "), 
                            footer = NULL, easyClose = TRUE, size = "s"))
      for (i in 1:ncol(pred_mat)) {
        sample_id <- colnames(pred_mat)[i]
        fname <- paste0(sample_id, "_BIRD_prediction", ".txt")
        pred_file <- write.table(cbind(gbins, pred_mat[, sample_id, drop=F]), 
                                 file.path(tmp, fname), row.names = FALSE, quote = FALSE, sep = "\t")
        tmp_fpaths <- append(tmp_fpaths, file.path(tmp, fname))
      }
      zip(zipfile = file, files = tmp_fpaths, extras = '-j')
      unlink(tmp, recursive = TRUE)
      removeModal()
    }
  )
  
  # BigWig download
  output$bw_download <- downloadHandler(
    filename = "BIRD_prediction_bw.zip",
    content = function(file) {
      # Make zip file
      showModal(modalDialog(p("Preparing for download..."), 
                            p("This may take a few minutes depending on the size of the files to be downloaded. 
                              Download will begin automatically when this is done. Thank you for your patience. "), 
                            footer = NULL, easyClose = TRUE, size = "s"))
      # Create temp folder to hold bigwig files (1 file for each sample)
      tmp <- tempfile(pattern = "bigwig", tmpdir = tmp_dir)
      dir.create(tmp)
      tmp_fpaths <- c()
      for (i in input$sample_table_rows_selected) {
        study <- as.character(samples_df()$project[i])
        sample <- samples_df()$sample[i]
        batch <- studies_batch()$batch[studies_batch()$study == study]
        fname <- paste0(sample, ".bw")
        download.file(paste0("http://jilab.biostat.jhsph.edu/software/PDDB/bigwig/b", batch, "/", sample, ".bw"), 
                      file.path(tmp, fname))
        tmp_fpaths <- append(tmp_fpaths, file.path(tmp, fname))
      }
      zip(zipfile = file, files = tmp_fpaths, extras = '-j')
      unlink(tmp, recursive = TRUE)
      removeModal()
    }
  )
  
  ucsc_session_show_modal <- reactiveVal()
  
  # UCSC session file download
  output$ucsc_session_download <- downloadHandler(
    filename = "BIRD_hub_session.txt",
    content = function(file) {
      chr <- "chr1"
      region_start <- start(bird_ranges()[1])
      region_end <- region_start + 100000 - 1
      hub_id <- "4835692"
      args <- c("c", "clade", "db", "dinkL", "dinkR", "dirty", "g", 
                paste0("hgHubConnect.hub.", hub_id), 
                "hgt_doJsCommand", 
                "hgtgroup_compGeno_close",
                "hgtgroup_denisova_close",
                "hgtgroup_expression_close",
                "hgtgroup_genes_close",
                "hgtgroup_hub_51309_close",
                "hgtgroup_map_close",
                "hgtgroup_neandertal_close",
                "hgtgroup_phenDis_close",
                "hgtgroup_regulation_close",
                "hgtgroup_rep_close",
                "hgtgroup_rna_close",
                "hgtgroup_varRep_close",
                paste0("hub_", hub_id, "_BIRD_predictions.displaySubtracks"),
                "knownGene.label.gene",
                "org",
                "pix",
                "position",
                "trackHubs")
      vals <- c(chr, "mammal", "hg38", "2.0", "2.0", "false", 
                paste0("hub_", hub_id, "_BIRD_predictions"), 
                "1", "", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0", "0", "0", 
                "selected", "1", "Human", "1000", 
                paste0(chr, ":", region_start, "-", region_end), 
                hub_id)
      track_ids <- gsub("\\.", "_", make.names(all_samples_df()$sample_id))
      sel_tracks <- paste0("hub_", hub_id, "_", track_ids, "_sel ", as.integer(all_samples_df()$sample_id %in% samples_df()$sample[input$sample_table_rows_selected]))
      writeLines(c(paste(args, vals), sel_tracks), file)
      ucsc_session_show_modal(TRUE)
    }
  )
  
  observeEvent(ucsc_session_show_modal(), {
    showModal(
      modalDialog(
        HTML("<p>To show the tracks of selected predictions on our UCSC Genome Browser Hub, 
             you need to upload a session file to <a href=\"https://genome.ucsc.edu/\" target=\"_blank\">
             UCSC Genome browser</a>. Go to <a href=\"https://genome.ucsc.edu/\" target=\"_blank\">
             UCSC Genome browser</a> &rarr; My Data &rarr; My Sessions &rarr; 
             Restore Settings &rarr; Use settings from a local file &rarr; submit. </p>"), 
        HTML("<p>Please note that you can view all predictions on all genomic positions 
             on UCSC Genome Browser by toggling <b>display region</b> and <b>subtracks visibility</b>.</p>"),
        easyClose = TRUE
      )
    )
    ucsc_session_show_modal(NULL)
  })
  
  # RDS file download
  observeEvent(input$proj_table_rows_selected, {
    output$rds_download <- downloadHandler(
      filename = {
        proj <- proj_table()$project[input$proj_table_rows_selected]
        if (length(proj) == 1) {
          paste0(proj, ".rds")
        } else {
          "studies_rds.zip"
        }
      }, 
      content = function(file) {
        proj <- proj_table()$project[input$proj_table_rows_selected]
        batch <- studies_batch()$batch[match(proj, studies_batch()$study)]
        if (length(proj) == 1) {
          download.file(paste0("http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b", 
                               batch, "/", proj, ".rds"), file)
        } else {
          # Make zip file
          showModal(modalDialog(p("Preparing for download..."), 
                                p("This may take a few minutes depending on the size of the files to be downloaded. 
                              Download will begin automatically when this is done. Thank you for your patience. "), 
                                footer = NULL, easyClose = TRUE, size = "s"))
          # Create temp folder to hold prediction files
          tmp <- tempfile(pattern = "rds", tmpdir = tmp_dir)
          dir.create(tmp)
          tmp_fpaths <- c()
          for (i in 1:length(proj)) {
            fname <- paste0(proj[i], ".rds")
            proj_file <- file.path(tmp, fname)
            download.file(paste0("http://jilab.biostat.jhsph.edu/software/PDDB/pred_rds/b", 
                                 batch[i], "/", proj[i], ".rds"), proj_file)
            tmp_fpaths <- append(tmp_fpaths, proj_file)
          }
          zip(zipfile = file, files = tmp_fpaths, extras = '-j')
          unlink(tmp, recursive = TRUE)
          removeModal()
        }
      }
    )
  })
  
  output$download_msg_zip_txt <- renderText({ 
    if (sum(selected_samples()$read_from == "database")) {
      paste0("Download selected genomic ranges of predictions for samples: ", 
             paste(selected_samples()$sample[selected_samples()$read_from == "database"], collapse = ", ")) 
    } else {
      paste("No sample selected from database. Please select more input samples from Input Selection Tab with \"Select from prediction database\" option. ")
    }
  })
  
  output$pca_page_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to perform PCA. ")
    } else if (n_bins_selected() < 2) {
      p("You must select at least 2 genomic bins to perform PCA. ")
    } else {
      max_hypervar <- 10000
      if (Sys.getenv('SHINY_PORT') != "") {
        max_hypervar <- 3000
      }
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h2("PCA and pseudo-time analysis")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "pca_pt_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "pca_pt_page_info",
          title = "<h3>PCA and pseudo-time analysis</h3>",
          content = do.call(paste0, 
                            popover_contents()$pca_pt_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        sliderInput(
          "pca_top_var", 
          label = tags$span("Number of top variance rows to use in PCA computation", 
                            bsButton("pca_top_var_info", 
                                     label = "", 
                                     icon = icon("info"),
                                     style = "info", 
                                     size = "extra-small")), 
          min = 1000, 
          max = max_hypervar, 
          value = 2000, 
          step = 100
        ),
        bsPopover(
          id = "pca_top_var_info",
          title = "<h4>PCA top variance genomic bins</h4>",
          content = do.call(paste0, 
                            popover_contents()$pca_top_var_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        tabsetPanel(
          tabPanel(
            "PCA Results", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px",
              uiOutput("pca_ui")
            )
          ), 
          tabPanel(
            "Pseudo-time Analysis", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px",
              uiOutput("pt_options_ui")
            )
          ), 
          tabPanel(
            "Pseudo-time Differential Test", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px",
              uiOutput("pt_diff_ui")
            )
          )
        )
      )
    }
  })
  
  # Predictions as numeric matrix with rows being genomic bins and columns being samples
  pred_mat <- reactive({
    req(nrow(selected_samples()) > 0)
    database_pred_mat <- get_database_pred_mat(bird_ranges()[sel_bins_i()])
    if (sum(selected_samples()$read_from == "local") > 0) {
      local_pred_mat <- get_local_pred_mat(bird_ranges()[sel_bins_i()])
      if (ncol(database_pred_mat) > 0) {
        # Have both local and database samples
        pred_mat <- cbind(database_pred_mat, local_pred_mat)
      } else {
        # Only have local samples
        pred_mat <- local_pred_mat
      }
    } else {
      # Only have database samples
      pred_mat <- database_pred_mat
    }
    return(pred_mat)
  })
  
  # Get hyper variance of each row in data
  hypervar_bulk <- function(data){
    
    data <- as.matrix(data)
    
    gene_mean_all <- rowMeans(data)
    gene_var_all <- rowVars(data)
    
    data_filter <- data[gene_mean_all > 0 & gene_var_all > 0,]
    
    gene_mean <- rowMeans(data_filter)
    gene_var <- rowVars(data_filter)
    
    data_fit <- data.frame(X=gene_mean,Y=gene_var)
    
    fit_model <- tryCatch(
      {gam(formula = log2(x=Y) ~ s(log2(x=X)), data = data_fit)}, 
      error = function(e) {
        k <- min(50, min(apply(data_fit, 2, function(x){length(unique(x))})))
        gam(formula = log2(x=Y) ~ s(log2(x=X), k=k), data = data_fit)
      }
    )
    
    gene_var_expect <- 2^(fit_model$fitted.values)
    gene_sd_expect <- sqrt(gene_var_expect)
    
    gene_var_norm <- (data_filter - gene_mean)/gene_sd_expect
    gene_hyper_var <- rowSums(gene_var_norm^2)/(ncol(data_filter) - 1)
    
    result <- data.frame(feature=row.names(data_filter), mean=gene_mean, var=gene_var,
                         var_expect=gene_var_expect,hypervar=gene_hyper_var)
    
    return(result)
  }
  
  # Hyper variance of each row (genomic bin) of prediction
  pred_hypervar <- reactive({
    pred_matrix <- pred_mat()
    showModal(modalDialog("Calculating hyper variance for each row...", footer = NULL, easyClose = TRUE, size = "s"))
    hypervar <- hypervar_bulk(pred_matrix)
    removeModal()
    return(hypervar)
  })
  
  # PCA top variance filtered prediction matrix
  pca_top_var_pred_mat <- reactive({
    # Calculate hyper variance for each bin
    n_top_var <- min(input$pca_top_var, nrow(pred_hypervar()))
    top_var_idx <- base::sort(pred_hypervar()$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    top_var_idx <- base::sort(top_var_idx)
    
    # Filter prediction matrix by top variance rows
    return(pred_mat()[pred_hypervar()$feature[top_var_idx], ])
  })
  
  # Get PCA result
  pca_res_full <- reactive({
    if (! all(is.na(pred_hypervar()))) {
      pred_mat_sorted <- t(pca_top_var_pred_mat())
      
      # Remove near zero variance columns
      zerovar_bins <- nearZeroVar(pred_mat_sorted)
      if (length(zerovar_bins) > 0) {
        pred_mat_sorted <- pred_mat_sorted[, - zerovar_bins]
      }
      
      if (any(dim(pred_mat_sorted) == 0)) {
        return(NA)
      }
      
      showModal(modalDialog("Performing PCA...", footer = NULL, easyClose = TRUE, size = "s"))
      pca_result <- prcomp(pred_mat_sorted, 
                           scale = TRUE)
      
      removeModal()
      
      return(pca_result)
    } 
    return(NA)
  })
  
  # Get transformed vectors from PCA result
  pca_res <- reactive({
    if (! all(is.na(pca_res_full()))) {
      res <- data.frame(pca_res_full()$x)
      # Sort result columns by PC
      return(res[, paste0("PC", 1:ncol(res))])
    }
    return(NA)
  })
  
  # Get optimal number of PCs
  opt_n_pc <- reactive({
    sdev <- pca_res_full()$sdev
    # Only consider first 30 PCs
    sdev <- sdev[1:min(30,length(sdev))]
    x <- 1:length(sdev)
    pcadim <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(sdev~x+x2)$residuals^2)
    }))
    pcadim
  })
  
  # Render panel with PCA results or message if no results can be generated
  output$pca_plot_ui <- renderUI({
    if (all(is.na(pca_res())) || ncol(pca_res()) < 2) {
      p("Too few genomic bins with significant variance.")
    } else {
      tagList(
        h4("PCA plot"),
        plotOutput("pca_plot", brush = "pca_plot_brush", width = 600, height = 500), 
        bsTooltip("pca_plot", 
                  title = "In this PCA plot, each point is a sample you selected. You can brush on this plot to see specific samples information in a table", 
                  placement = "top"),
        actionButton("pca_plot_download", "Download plot", 
                     class = "regular-btn"), 
        hr(),
        # Display table with brushed samples
        h4("PCA plot brushed points table"),
        uiOutput("pca_brush_msg"), 
        DT::dataTableOutput('pca_brushed')
      )
    }
  })
  
  # Instructions on how to brush points
  output$pca_brush_msg <- renderUI({
    if (is.null(input$pca_plot_brush)) {
      p("You can brush on PCA plot (click and drag to select points) to see 
        specific samples information in a table. ")
    }
  })
  
  # PCA plot
  pca_plot <- reactive({
    if (!all(is.na(pca_res())) && ncol(pca_res()) >= 2) {
      top_pcs <- pca_res()[, 1:2]
      proj <- selected_samples()$project
      g <- ggplot(data = top_pcs, 
                  mapping = aes(PC1, PC2, colour = factor(proj))) + geom_point()
      g$labels$colour <- "Project"
      explained_var <- data.frame(t(summary(pca_res_full())$importance))
      explained_var <- explained_var[paste0('PC', 1:2), 'Proportion.of.Variance']
      g <- g + xlab(paste0("PC1 (", explained_var[1]*100, "%)")) + ylab(paste0("PC2 (", explained_var[2]*100, "%)"))
      g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
        theme(panel.border = element_blank(), axis.line = element_line()) + 
        theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
        theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
        theme(panel.background = element_rect(fill = "white"))
      g
    }
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pca_plot_download, {
    download_plot(pca_plot())
  })
  
  # Render PCA plot
  output$pca_plot <- renderPlot({
    pca_plot()
  })
  
  # Render PCA brushed points table
  observeEvent(input$pca_plot_brush, {
    top_pcs <- pca_res()[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$pca_plot_brush, xvar = "PC1", yvar = "PC2"))
    output$pca_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                              rownames = FALSE,
                                              filter = list(position = 'top', clear = FALSE), 
                                              selection = "none")
  })
  
  pca_var_plot <- reactive({
    explained_var <- data.frame(t(summary(pca_res_full())$importance))
    explained_var <- explained_var[paste0('PC', 1:min(10, nrow(explained_var))), ]
    var_plot <- ggplot(data = explained_var, 
                       mapping = aes(factor(rownames(explained_var), levels = rownames(explained_var)), 
                                     explained_var$Proportion.of.Variance, group=1))
    var_plot <- var_plot + geom_line() + geom_point()
    var_plot <- var_plot + xlab("Principal Components") + ylab("Proportion of Variance Explained")
    var_plot <- var_plot + geom_text(aes(label=explained_var$Proportion.of.Variance), vjust=-0.25)
    var_plot <- var_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    var_plot
  })
  
  # Render PCA variance plot
  output$pca_var_plot <- renderPlot({
    pca_var_plot()
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pca_var_plot_download, {
    download_plot(pca_var_plot())
  })
  
  pca_cumvar_plot <- reactive({
    cumvar <- data.frame(t(summary(pca_res_full())$importance))
    cumvar <- cumvar[paste0('PC', 1:min(10, nrow(cumvar))), ]
    cumvar_plot <- ggplot(data = cumvar, 
                          mapping = aes(factor(rownames(cumvar), levels = rownames(cumvar)), 
                                        cumvar$Cumulative.Proportion, group=1))
    cumvar_plot <- cumvar_plot + geom_line() + geom_point()
    cumvar_plot <- cumvar_plot + geom_vline(xintercept = paste0('PC', opt_n_pc()), linetype = "dashed")
    cumvar_plot <- cumvar_plot + xlab("Principal Components") + ylab("Cumulative Proportion of Variance Explained")
    cumvar_plot <- cumvar_plot + geom_text(aes(label=cumvar$Cumulative.Proportion), vjust=-0.25)
    cumvar_plot <- cumvar_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    cumvar_plot
  })
  
  # Render PCA cumulative variance plot
  output$pca_cumvar_plot <- renderPlot({
    pca_cumvar_plot()
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pca_cumvar_plot_download, {
    download_plot(pca_cumvar_plot())
  })
  
  # Render PCA results UI panel
  output$pca_ui <- renderUI({
    tagList(selectizeInput(
      "pca_show_graph", 
      label = "Choose graph to display: ", 
      choices = c("PCA Plot", "Explained Variance", "Cumulative Explained Variance"), 
      options = list(placeholder = "", 
                     onInitialize = I('function() { this.setValue(""); }'))
    ),
    uiOutput("pca_graph_ui"))
  })
  
  # PCA graphs
  output$pca_graph_ui <- renderUI({
    req(input$pca_show_graph)
    if (input$pca_show_graph == "PCA Plot") {
      # Output PCA plot
      uiOutput("pca_plot_ui")
    } else if (input$pca_show_graph == "Explained Variance") {
      # Output explained variance plot
      tagList(
        h4("PCA explained variance plot"),
        plotOutput("pca_var_plot"), 
        actionButton("pca_var_plot_download", "Download plot",
                     class = "regular-btn")
      )
    } else {
      # Output cumulative variance plot
      tagList(
        h4("PCA cumulative explained variance plot"), 
        plotOutput("pca_cumvar_plot"), 
        bsTooltip("pca_cumvar_plot", 
                  title = "The dashed line indicates the optimal number of PCs calculated by elbow method", 
                  placement = "top"), 
        actionButton("pca_cumvar_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Update chosen number of PCs on optimal choice check box
  observeEvent(input$use_opt_n_pc, {
    if (input$use_opt_n_pc) {
      updateSliderInput(
        session, 
        "pt_n_pc", 
        value = max(2, opt_n_pc())
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of PCs
  observeEvent(input$pt_n_pc, {
    if (input$pt_n_pc != max(2, opt_n_pc())) {
      updateCheckboxInput(
        session, 
        "use_opt_n_pc", 
        value = FALSE
      )
    }
  })
  
  # Message stating the optimal number of clusters
  output$opt_n_pc_msg <- renderUI({
    HTML(paste("Optimal number of PCs:", strong(opt_n_pc())))
  })
  
  # Render options for pseudo time computation
  output$pt_options_ui <- renderUI({
    if (!all(is.na(pca_res())) && ncol(pca_res()) >= 2) {
      sidebarLayout(
        sidebarPanel(
          tags$div(style = "display:inline-block; vertical-align:middle;", h4("Pseudo-time trajectory computation parameters")), 
          tags$div(style = "display:inline-block; vertical-align:middle;", 
                   bsButton("pt_param_info", 
                            label = "", 
                            icon = icon("info"), 
                            info = "info", 
                            size = "extra-small")), 
          bsPopover("pt_param_info", 
                    title = "<h4>Pseudo-time trajectory computation</h4>", 
                    content = do.call(paste0, popover_contents()$pt_param_info), 
                    placement = "right", 
                    trigger = "focus", 
                    options = list(container = "body", 
                                   html = TRUE)),
          wellPanel(
            sliderInput(
              "pt_n_pc", 
              label = "Number of PCs to use for pseudo-time computation: ", 
              min = 2, 
              max = min(30, ncol(pca_res())), 
              value = max(opt_n_pc(), 2), 
              step = 1
            ), 
            bsTooltip("pt_n_pc", 
                      title = "The pseudo-time computation is based on a reduced PCA matrix. ", 
                      placement = "right", 
                      options = list(container = "body")), 
            checkboxInput(
              "use_opt_n_pc", 
              label = "Use optimal number of PCs", 
              value = TRUE
            ),
            htmlOutput('opt_n_pc_msg'), 
            bsTooltip("opt_n_pc_msg", 
                      title = "The number of optimal PCs is computed by elbow method on cumulative explained variance. ", 
                      placement = "right", 
                      options = list(container = "body"))
          ),
          wellPanel(
            sliderInput(
              "pt_range", 
              label = "Number of anchoring clusters for pseudo time: ", 
              min = 2, 
              max = min(15, nrow(pca_res())), 
              value = c(2, min(15, nrow(pca_res()))),
              step = 1
            ), 
            bsTooltip("pt_range", 
                      title = "The anchoring clusters are computed using k-means. ", 
                      placement = "right", 
                      options = list(container = "body")), 
            htmlOutput('opt_n_pt_msg'), 
            bsTooltip("opt_n_pt_msg", 
                      title = "The optimal number of anchoring clusters is selected from the set range of cluster numbers using elbow method. ", 
                      placement = "right", 
                      options = list(container = "body"))
          ),
          wellPanel(uiOutput('pt_sel_traj_ui'))
        ),
        mainPanel(
          fluidRow(
            column(
              width = 4, 
              tags$div(
                style = "background:#ffd7c8;border:none;border-radius:10px;padding:10px;",
                selectInput(
                  "pt_show_panel", 
                  label = "Choose pseudo-time analysis result panel to display: ", 
                  choices = c("Pseudo-time Trajectory", 
                              "Accessibility along pseudotime", 
                              "Nearest gene expression along pseudotime"), 
                  selected = "Pseudo-time Trajectory"
                )
              )
            ), 
            column(
              width = 8, 
              uiOutput("pt_dat_along_pt_ui")
            )
          ),
          uiOutput("pt_ui")
        )
      )
    } else {
      p("You must have valid PCA result before computing pseudo-time sample clusters.")
    }
  })
  
  # Render UI for selecting data type plot along pseudotime
  output$pt_dat_along_pt_ui <- renderUI({
    req(input$pt_show_panel)
    if (input$pt_show_panel == "Accessibility along pseudotime") {
      tagList(
        fluidRow(
          column(
            width = 6, 
            selectInput(
              "pt_chracc_dat_type", 
              "Which accessibility to visualize along pseudotime: ", 
              choices = c("Genomic bin clusters", 
                          "Individual genomic bin", 
                          "Gene average")
            )
          ), 
        )
      )
    } else if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
      tagList(
        fluidRow(
          column(
            width = 6, 
            selectInput(
              "pt_expr_dat_type", 
              "Which expression to visualize along pseudotime: ", 
              choices = c("Genomic bin clusters", 
                          "Individual genomic bin", 
                          "Gene average")
            )
          ), 
        )
      )
    }
  })
  
  # Render pseudo time output UI
  output$pt_ui <- renderUI({
    req(input$pt_show_panel)
    if (input$pt_show_panel == "Pseudo-time Trajectory") {
      # Make plot for pseudo-time trajectory over sample clusters
      tagList(
        h3("Pseudotime trajectory"), 
        downloadButton('pt_traj_samples_order_download', "Download sample ids ordered by pseudo-time", 
                       class = "regular-btn"),
        checkboxInput(
          "pt_traj_show_clustering_table", 
          label = "Show clustering table"
        ),
        uiOutput('pt_traj_clustering_table_ui'),
        checkboxInput(
          "pt_traj_show_sample_names", 
          label = "Show sample names in plot"
        ),
        uiOutput('pt_traj_sample_name_size_ui'),
        radioButtons(
          'pt_traj_color', 
          label = "Color by:",
          choices = c("Anchoring clusters", 
                      "Pseudotime")
        ),
        uiOutput('pt_traj_show_side_branch_ui'),
        h4("Pseudotime trajectory plot"),
        plotOutput('pt_traj', brush = 'pt_traj_brush'), 
        actionButton("plot_traj_plot_download", "Download plot", 
                     class = "regular-btn"), 
        bsTooltip("pt_traj", 
                  title = "The selected trajectory is shown connecting anchoring clusters. Each data point is a sample. You can brush the points to view their specifics in a table. ", 
                  placement = "top"),
        hr(), 
        h4("Pseudotime trajectory plot brushed points"), 
        uiOutput("pt_traj_brush_msg"),
        DT::dataTableOutput('pt_traj_brushed')
      )
    } else if (input$pt_show_panel == "Accessibility along pseudotime") {
      uiOutput("pt_chracc_ui")
    } else if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
      uiOutput("pt_expr_ui")
    }  
  })
  
  # Instructions on how to brush points
  output$pt_traj_brush_msg <- renderUI({
    if (is.null(input$pt_traj_brush)) {
      p("You can brush on trajectory plot (click and drag to select points) to see 
        specific samples information in a table. ")
    }
  })
  
  # Render UI for accessibility along pt plots
  output$pt_chracc_ui <- renderUI({
    if (input$pt_chracc_dat_type == "Genomic bin clusters") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Genomic bin clusters accessibility along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_clust_chracc_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_clust_chracc_info", 
                  title = "<h4>Genomic bin clusters chromatin accessibility</h4>", 
                  content = do.call(paste0, popover_contents()$gbin_clust_chracc_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          checkboxInput(
            "pt_gbin_clust_use_filter", 
            "Filter genomic bins used in clustering", 
            value = FALSE
          ),
          uiOutput("pt_gbin_clust_filter_ui"),
          uiOutput("pt_gbin_clust_ui"), 
          htmlOutput('opt_n_gbin_clust_msg'),
          bsTooltip("opt_n_gbin_clust_msg", 
                    title = "The optimal number of genomic bin clusters is determined by elbow method. ",
                    placement = "top"),
          checkboxInput(
            "pt_show_gbin_clust_wss_plot", 
            label = "Show Total Within Cluster Sum of Squares Plot", 
            value = FALSE
          ),
          uiOutput("pt_gbin_clust_wss_plot_ui"),
          checkboxInput(
            "pt_show_gbin_clust_res", 
            label = "Show genomic bin k-means clustering result", 
            value = FALSE
          ), 
          uiOutput("pt_gbin_clust_res_ui")
        ), 
        selectInput(
          'pt_gbin_clust_chracc_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput("pt_gbin_clust_chracc_ui")
      )
    } else if (input$pt_chracc_dat_type == "Individual genomic bin") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Individual genomic bin accessibility along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_chracc_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_chracc_info", 
                  title = "<h4>Individual genomic bin chromatin accessibility</h4>", 
                  content = do.call(paste0, popover_contents()$gbin_chracc_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        selectInput(
          'pt_gbin_chracc_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gbin_chracc_ui')
      )
    } else if (input$pt_chracc_dat_type == "Gene average") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Gene accessibility along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gene_chracc_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gene_chracc_info", 
                  title = "<h4>Average gene chromatin accessibility</h4>", 
                  content = do.call(paste0, popover_contents()$gene_chracc_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          # Select distance limit for mapping bins to nearest genes
          fluidRow(
            column(
              8, 
              shinyWidgets::sliderTextInput(
                "pt_gene_chracc_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS", 
                choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
                post = "bp",
                selected = 500
              ),
              # sliderInput("pt_gene_chracc_gene_maxdist", 
              #             "Maximum distance limit of bins to nearest gene TSS",
              #             min = 0, 
              #             max = 1e6, 
              #             value = 500, 
              #             post = "bp",
              #             step = 100), 
            ), 
            column(
              4, 
              checkboxInput(
                "pt_show_gene_dist_plot", 
                "Show distribution of bins distance to genes", 
                value = FALSE
              )
            )
          ),
          uiOutput("pt_gene_chracc_gene_dist_plot_ui"),
        ),
        selectInput(
          'pt_gene_chracc_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gene_chracc_ui')
      )
    }
  })
  
  output$pt_gene_chracc_gene_dist_plot_ui <- renderUI({
    if (input$pt_show_gene_dist_plot) {
      tagList(
        plotlyOutput("pt_gene_chracc_gene_dist_plot"), 
        #actionButton("pt_gene_chracc_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  # Render UI for expression along pt plots
  output$pt_expr_ui <- renderUI({
    if (input$pt_expr_dat_type == "Genomic bin clusters") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Genomic bin clusters expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_clust_expr_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_clust_expr_info", 
                  title = "<h4>Genomic bin clusters expression</h4>", 
                  content = do.call(paste0, popover_contents()$gbin_clust_expr_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          checkboxInput(
            "pt_gbin_clust_use_filter", 
            "Filter genomic bins used in clustering", 
            value = FALSE
          ),
          uiOutput("pt_gbin_clust_filter_ui"),
          uiOutput("pt_gbin_clust_ui"),
          htmlOutput('opt_n_gbin_clust_msg'),
          bsTooltip("opt_n_gbin_clust_msg", 
                    title = "The optimal number of genomic bin clusters is determined by elbow method. ",
                    placement = "top"),
          checkboxInput(
            "pt_show_gbin_clust_wss_plot", 
            label = "Show Total Within Cluster Sum of Squares Plot", 
            value = FALSE
          ),
          uiOutput("pt_gbin_clust_wss_plot_ui"),
          checkboxInput(
            "pt_show_gbin_clust_res", 
            label = "Show genomic bin k-means clustering result", 
            value = FALSE
          ), 
          uiOutput("pt_gbin_clust_res_ui")
        ), 
        fluidRow(
          column(
            width = 4, 
            selectInput(
              'pt_gbin_clust_expr_choose_plot', 
              label = "Choose visualization method: ", 
              choices = c("Scatterplot", 
                          "Heatmap")
            )
          ), 
          column(
            width = 4, 
            selectInput(
              "pt_avg_expr_across", 
              "Use average expression across: ",
              c("Bins", "Nearest genes")
            )
          )
        ),
        uiOutput("pt_gbin_clust_expr_ui")
      )
    } else if (input$pt_expr_dat_type == "Individual genomic bin") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Individual genomic bin expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gbin_expr_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gbin_expr_info", 
                  title = "<h4>Individual genomic bin expression</h4>", 
                  content = do.call(paste0, popover_contents()$gbin_expr_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          fluidRow(
            column(
              width = 8,
              shinyWidgets::sliderTextInput(
                "pt_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS", 
                choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
                post = "bp",
                selected = 500
              ),
              # sliderInput(
              #   "pt_gene_maxdist", 
              #   "Maximum distance limit of bins to nearest gene TSS",
              #   min = 0, 
              #   max = 1e6, 
              #   value = 500, 
              #   post = "bp",
              #   step = 100, 
              #   width = "100%"
              # )
            ), 
            column(
              width = 4, 
              checkboxInput(
                "pt_show_gene_dist_plot", 
                "Show distribution of bins distance to genes", 
                value = FALSE
              )
            )
          ),
          uiOutput("pt_gbin_ngene_msg"),
          uiOutput("pt_gbin_expr_gene_dist_plot_ui")
        ),
        selectInput(
          'pt_gbin_expr_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gbin_expr_ui')
      )
    } else if (input$pt_expr_dat_type == "Gene average") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h3("Gene expression along pseudo-time")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("gene_expr_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("gene_expr_info", 
                  title = "<h4>Average gene expression</h4>", 
                  content = do.call(paste0, popover_contents()$gene_expr_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        wellPanel(
          fluidRow(
            column(
              width = 8,
              # Select distance limit for mapping bins to nearest genes
              shinyWidgets::sliderTextInput(
                "pt_gene_expr_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS", 
                choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
                post = "bp",
                selected = 500
              ),
              # sliderInput("pt_gene_expr_gene_maxdist",
              #             "Maximum distance limit of bins to nearest gene TSS",
              #             min = 0,
              #             max = 1e6,
              #             value = 500,
              #             post = "bp",
              #             step = 100)
            ), 
            column(
              width = 4, 
              checkboxInput(
                "pt_show_gene_expr_gene_dist_plot", 
                "Show distribution of bins distance to genes", 
                value = FALSE
              )
            )
          ),
          uiOutput("pt_gene_expr_gene_dist_plot_ui")
        ),
        selectInput(
          'pt_gene_expr_choose_plot', 
          label = "Choose visualization method: ", 
          choices = c("Scatterplot", 
                      "Heatmap")
        ),
        uiOutput('pt_gene_expr_ui')
      )
    }
    
  })
  
  all_samples_clust <- reactive({
    set.seed(12345)
    pcareduceres <- pca_res()[, 1:input$pt_n_pc]
    clusternum <- 2:min(15, nrow(pca_res()))
    clusternum <- clusternum[clusternum > 1]
    # Find optimal clustering using kmeans and evaluate with total within sum of squares using elbow method
    showModal(modalDialog("Finding sample clusters...", footer = NULL, easyClose = TRUE, size = "s"))
    # Perform kmeans for all cluster numbers
    kmeans_res_list <- lapply(if (nrow(pcareduceres) == max(clusternum)) {clusternum[-c(length(clusternum))]}
                              else {clusternum}, 
                              function(x) {kmeans(pcareduceres, centers = x, nstart=25)})
    if (nrow(pcareduceres) == max(clusternum)) {
      # Each row is its own cluster
      kmeans_res <- list()
      cluster <- 1:nrow(pcareduceres)
      names(cluster) <- row.names(pcareduceres)
      kmeans_res[['cluster']] <- cluster
      centers <- pcareduceres
      row.names(centers) <- as.character(c(1:nrow(pcareduceres)))
      kmeans_res[['centers']] <- centers
      kmeans_res[['tot.withinss']] <- 0
      kmeans_res_list[[length(kmeans_res_list) + 1]] <- kmeans_res
    }
    names(kmeans_res_list) <- clusternum
    kmeans_res_list
  })
  
  # Function adapted from TSCAN for sample clustering based on PCA result
  samples_clust <- reactive({
    pcareduceres <- pca_res()[, 1:input$pt_n_pc]
    clusternum <- input$pt_range[1]:input$pt_range[2]
    clust_in_range <- all_samples_clust()[as.character(clusternum)]
    # Use elbow method to find optimal number of clusters
    wss <- sapply(clust_in_range, function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust_i <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    }))
    opt_nclust <- clusternum[opt_nclust_i]
    kmeans_res <- clust_in_range[[opt_nclust_i]]
    # Assign id to clusters
    clusterid <- kmeans_res$cluster
    clucenter <- matrix(0, ncol = ncol(pcareduceres), nrow = opt_nclust)
    for (cid in 1:opt_nclust) {
      clucenter[cid, ] <- colMeans(pcareduceres[names(clusterid[clusterid == cid]), , drop = F])
    }
    dp <- as.matrix(dist(clucenter))
    gp <- graph.adjacency(dp, mode = "undirected", weighted = TRUE)
    dp_mst <- minimum.spanning.tree(gp)
    removeModal()
    return(list(pcareduceres = as.matrix(pcareduceres), MSTtree = dp_mst, clusterid = clusterid, clucenter = clucenter))
  })
  
  # Message stating the optimal number of clusters
  output$opt_n_pt_msg <- renderUI({
    HTML(paste("Number of anchoring clusters:", strong(nrow(samples_clust()$clucenter))))
  })
  
  # All possible pseudo-time trajectory starts and ends
  pt_traj_combs <- reactive({
    mclustobj <- samples_clust()
    # Get all combinations of starts and ends of pseudo time paths
    alldeg <- igraph::degree(mclustobj$MSTtree)
    allcomb <- expand.grid(as.numeric(names(alldeg)[alldeg == 1]), as.numeric(names(alldeg)[alldeg == 1]))
    allcomb <- allcomb[allcomb[, 1] != allcomb[, 2], ]
    allcomb
  })
  
  # Optimal pseudo-time trajectory
  main_traj_comb <- reactive({
    mclustobj <- samples_clust()
    clutable <- table(mclustobj$clusterid)
    allcomb <- pt_traj_combs()
    # First column of numres is lengths of paths, 2nd column is total number of cells in clusters covered by paths
    numres <- t(apply(allcomb, 1, function(i) {
      tmp <- as.vector(get.shortest.paths(mclustobj$MSTtree, 
                                          i[1], i[2])$vpath[[1]])
      c(length(tmp), sum(clutable[tmp]))
    }))
    # Get the start and end of optimal path which is longest and covers most cells
    optcomb <- allcomb[order(numres[, 1], numres[, 2], decreasing = T)[1], ]
    optcomb
  })
  
  # Update chosen trajectory on optimal choice check box
  observeEvent(input$use_main_traj, {
    if (input$use_main_traj) {
      updateSelectInput(
        session, 
        "pt_traj_comb", 
        selected = paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to ')
      )
    }
  })
  
  # Update optimal choice check box when user selects a different trajectory
  observeEvent(input$pt_traj_comb, {
    optcombs <- c(paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to '), 
                  paste(main_traj_comb()[, 2], main_traj_comb()[, 1], sep = ' to '))
    if (!(input$pt_traj_comb %in% optcombs)) {
      updateCheckboxInput(
        session, 
        "use_main_traj", 
        value = FALSE
      )
    }
  })
  
  # Message stating the optimal trajectories
  output$main_traj_msg <- renderUI({
    HTML(
      paste("Main trajectories:", 
            strong(paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to ')), 
            "and", 
            strong(paste(main_traj_comb()[, 2], main_traj_comb()[, 1], sep = ' to '))
      )
    )
  })
  
  # Render UI for pseudo-time trajectory selection
  output$pt_sel_traj_ui <- renderUI({
    if (! is.null(samples_clust())) {
      tagList(
        selectInput(
          "pt_traj_comb", 
          label = "Select pseudo-time trajectory: ", 
          choices = paste(pt_traj_combs()[, 1], pt_traj_combs()[, 2], sep = ' to '), 
          selected = paste(main_traj_comb()[, 1], main_traj_comb()[, 2], sep = ' to ')
        ),
        bsTooltip("pt_traj_comb", 
                  title = "The pseudo-time trajectories are all paths that connect all combinations of leaf pairs in the minimum spanning tree of anchors. ", 
                  placement = "right", 
                  options = list(container = "body")), 
        checkboxInput(
          "use_main_traj", 
          label = "Use main trajectory", 
          value = TRUE
        ),
        htmlOutput('main_traj_msg'),
        bsTooltip("main_traj_msg", 
                  title = "The main trajectories are the ones with longest path length and cover most samples. ", 
                  placement = "right", 
                  options = list(container = "body")), 
      )
    }
  })
  
  # Render anchoring clusters table
  output$pt_traj_clustering_table <- DT::renderDataTable(data.frame(cluster = as.factor(samples_clust()$clusterid), 
                                                                    sample = names(samples_clust()$clusterid)), 
                                                         rownames = FALSE,
                                                         filter = list(position = 'top', clear = FALSE), 
                                                         selection = "none")
  
  # Download clustering table
  output$pt_traj_clustering_table_download <- downloadHandler(
    filename = function() { "Pseudotime_anchoring_clusters_table.txt" },
    content = function(file) {
      write.table(data.frame(cluster = as.factor(samples_clust()$clusterid), 
                             sample = names(samples_clust()$clusterid)),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Render anchoring clusters table UI
  output$pt_traj_clustering_table_ui <- renderUI({
    if (input$pt_traj_show_clustering_table) {
      tagList(
        h4("Anchoring clusters table"),
        downloadButton('pt_traj_clustering_table_download', 'Download clustering table', 
                       class = "regular-btn"), 
        DT::dataTableOutput('pt_traj_clustering_table')
      )
    }
  })
  
  # Pseudo time order based on sample clustering result (adapted from TSCANorder)
  pred_order <- reactive({
    mclustobj <- samples_clust()
    set.seed(12345)
    clucenter <- mclustobj$clucenter
    row.names(clucenter) <- paste0("clu", 1:nrow(clucenter))
    clusterid <- mclustobj$clusterid
    pcareduceres <- mclustobj$pcareduceres
    adjmat <- as_adjacency_matrix(mclustobj$MSTtree, sparse = FALSE)
    
    orderinMST <- 1
    clutable <- table(mclustobj$clusterid)
    # Get user selected path
    sel_traj <- as.integer(unlist(strsplit(input$pt_traj_comb, ' to ')))
    MSTorder <- get.shortest.paths(mclustobj$MSTtree, sel_traj[1], sel_traj[2])$vpath[[1]]
    
    TSCAN_order <- NULL
    for (i in 1:(length(MSTorder) - 1)) {
      currentcluid <- MSTorder[i]
      nextcluid <- MSTorder[i + 1]
      currentclucenter <- clucenter[currentcluid, ]
      nextclucenter <- clucenter[nextcluid, ]
      currentreduceres <- pcareduceres[clusterid == currentcluid, ]
      # Avoid vector output
      currentreduceres <- matrix(currentreduceres, nrow = sum(clusterid == currentcluid))
      rownames(currentreduceres) <- rownames(pcareduceres)[clusterid == currentcluid]
      # Get all clusters adjacent to current cluster
      connectcluid <- as.numeric(names(which(adjmat[currentcluid, ] == 1)))
      # Each row is distances from current cluster instance to adjacent cluster centers
      cludist <- sapply(connectcluid, function(x) {
        rowSums(sweep(currentreduceres, 2, clucenter[x, 
        ], "-")^2)
      })
      # Avoid vector output 
      cludist <- matrix(cludist, nrow = nrow(currentreduceres))
      rownames(cludist) <- rownames(currentreduceres)
      # Find closest adjacent cluster for each instance in current cluster
      mindistid <- apply(cludist, 1, which.min)
      # Find current cluster instances closer to next cluster center than to other adjacent clusters (edge cells)
      edgecell <- names(which(mindistid == which(connectcluid == 
                                                   nextcluid)))
      # Sort edge cells by how closely they align with the vector pointing from current cluster to next cluster
      difvec <- nextclucenter - currentclucenter
      tmppos <- pcareduceres[edgecell, ] %*% difvec
      pos <- as.vector(tmppos)
      names(pos) <- edgecell # Changed to get names directly from edgecell instead of tmppos
      # Add sorted edge cells to order
      TSCAN_order <- c(TSCAN_order, names(sort(pos)))
      nextreduceres <- pcareduceres[clusterid == nextcluid, ]
      # Avoid vector output
      nextreduceres <- matrix(nextreduceres, nrow = sum(clusterid == nextcluid))
      rownames(nextreduceres) <- rownames(pcareduceres)[clusterid == nextcluid]
      # Get all clusters adjacent to next cluster
      connectcluid <- as.numeric(names(which(adjmat[nextcluid, ] == 1)))
      # Each row is distances from next cluster instance to adjacent cluster centers
      cludist <- sapply(connectcluid, function(x) {
        rowSums(sweep(nextreduceres, 2, clucenter[x, 
        ], "-")^2)
      })
      # Avoid vector output 
      cludist <- matrix(cludist, nrow = nrow(nextreduceres))
      rownames(cludist) <- rownames(nextreduceres)
      # Find closest adjacent cluster for each instance in next cluster
      mindistid <- apply(cludist, 1, which.min)
      # Find next cluster instances closer to current cluster center than to other adjacent clusters (edge cells)
      edgecell <- names(which(mindistid == which(connectcluid == 
                                                   currentcluid)))
      # Sort edge cells by how closely they align with the vector pointing from current cluster to next cluster
      difvec <- nextclucenter - currentclucenter
      tmppos <- pcareduceres[edgecell, ] %*% difvec
      pos <- as.vector(tmppos)
      names(pos) <- edgecell # Changed to get names directly from edgecell instead of tmppos
      # Add sorted edge cells to order
      TSCAN_order <- c(TSCAN_order, names(sort(pos)))
    }
    data.frame(sample_name = TSCAN_order, State = clusterid[TSCAN_order], 
               Pseudotime = 1:length(TSCAN_order), stringsAsFactors = F)
  })
  
  # Function adapted from TSCAN for plotting pseudo-time trajectory
  plot_traj_clusts <- function (mclustobj, main_traj, show_side_branches = T, show_cell_names = T, cell_name_size = 3) {
    # Create dataframe with each row being a sample containing both PC1 PC2 and cluster
    lib_info_with_pseudo <- data.frame(State = mclustobj$clusterid,
                                       sample_name = names(mclustobj$clusterid))
    lib_info_with_pseudo$State <- factor(lib_info_with_pseudo$State)
    S_matrix <- mclustobj$pcareduceres
    pca_space_df <- data.frame(S_matrix[, 1:2])
    colnames(pca_space_df) <- c("PC1", "PC2")
    pca_space_df$sample_name <- row.names(pca_space_df)
    edge_df <- merge(pca_space_df, lib_info_with_pseudo, by.x = "sample_name",
                     by.y = "sample_name")
    # Plot clusters
    g <- ggplot(data = edge_df, aes(x = PC1, y = PC2))
    g <- g + geom_point(aes(color = State), na.rm = TRUE,
                        size = 5)
    # Plot sample names
    if (show_cell_names) {
      g <- g + geom_text(aes(label = sample_name), size = cell_name_size)
    }
    traj_start <- main_traj[1]
    traj_end <- main_traj[2]
    if (show_side_branches) {
      clucenter <- mclustobj$clucenter[, 1:2]
      mst_lines <- NULL
      mst_edges <- as_edgelist(mclustobj$MSTtree)
      mst_edges <- t(apply(mst_edges, 1, sort))
      for (i in 1:nrow(mst_edges)) {
        mst_lines <- rbind(mst_lines, c(clucenter[as.integer(mst_edges[i, 1]),], clucenter[as.integer(mst_edges[i, 2]), ]))
      }
      mst_lines <- data.frame(x = mst_lines[, 1], xend = mst_lines[, 3], y = mst_lines[, 2], yend = mst_lines[, 4], trajectory = "dashed")
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        edge_line <- sort(c(MSTorder[i], MSTorder[i+1]))
        mst_lines$trajectory[apply(mst_edges, 1, function(x) {all(x == edge_line)})] <- "solid"
      }
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL, linetype = trajectory), 
                            data = mst_lines, size = 1) + scale_linetype_identity()
    } else {
      # Get edges between cluster centers on trajectory
      clucenter <- mclustobj$clucenter[, 1:2]
      clulines <- NULL
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        clulines <- rbind(clulines, c(clucenter[MSTorder[i],], clucenter[MSTorder[i + 1], ]))
      }
      clulines <- data.frame(x = clulines[, 1], xend = clulines[, 3], y = clulines[, 2], yend = clulines[, 4])
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL), data = clulines, size = 1)
    }
    clucenter <- data.frame(x = clucenter[, 1], y = clucenter[,2], id = 1:nrow(clucenter))
    g <- g + geom_text(aes(label = id, x = x, y = y, size = NULL), data = clucenter, size = 10)
    g <- g + guides(colour = guide_legend(override.aes = list(size = 5))) +
      theme(panel.border = element_blank(), axis.line = element_line()) +
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) +
      theme(legend.position = "right", legend.key.size = unit(0.3, "in"), legend.text = element_text(size = 20), legend.title = element_text(size = 20)) +
      theme(legend.key = element_blank()) + theme(panel.background = element_rect(fill = "white")) +
      theme(axis.text.x = element_text(size = 17, color = "darkred"),
            axis.text.y = element_text(size = 17, color = "black"),
            axis.title.x = element_text(size = 20, vjust = -1),
            axis.title.y = element_text(size = 20, vjust = 1),
            plot.margin = unit(c(1, 1, 1, 1), "cm"))
    g
  }
  
  # Function for plotting pseudo-time trajectory colored by pseudo-time
  plot_traj <- function (mclustobj, main_traj, pt, show_side_branches = T, show_cell_names = T, cell_name_size = 3) {
    # Create dataframe with each row being a sample containing both PC1 PC2 and cluster
    lib_info_with_pseudo <- data.frame(State = mclustobj$clusterid, 
                                       sample_name = names(mclustobj$clusterid))
    lib_info_with_pseudo$State <- factor(lib_info_with_pseudo$State)
    pt <- data.frame(pt = 1:length(pt), 
                     sample_name = pt)
    lib_info_with_pseudo <- merge(lib_info_with_pseudo, pt, by="sample_name", all.x=T)
    S_matrix <- mclustobj$pcareduceres
    pca_space_df <- data.frame(S_matrix[, 1:2])
    colnames(pca_space_df) <- c("PC1", "PC2")
    pca_space_df$sample_name <- row.names(pca_space_df)
    edge_df <- merge(pca_space_df, lib_info_with_pseudo, by.x = "sample_name", 
                     by.y = "sample_name")
    # Plot sample points
    g <- ggplot(data = edge_df, aes(x = PC1, y = PC2))
    g <- g + geom_point(aes(color = pt), na.rm = TRUE, size = 5) + 
      scale_colour_gradientn(colours=rainbow(2)) + labs(color = "Pseudotime")
    # Plot sample names
    if (show_cell_names) {
      g <- g + geom_text(aes(label = sample_name), size = cell_name_size)
    }
    traj_start <- main_traj[1]
    traj_end <- main_traj[2]
    if (show_side_branches) {
      clucenter <- mclustobj$clucenter[, 1:2]
      mst_lines <- NULL
      mst_edges <- as_edgelist(mclustobj$MSTtree)
      mst_edges <- t(apply(mst_edges, 1, sort))
      for (i in 1:nrow(mst_edges)) {
        mst_lines <- rbind(mst_lines, c(clucenter[as.integer(mst_edges[i, 1]),], clucenter[as.integer(mst_edges[i, 2]), ]))
      }
      mst_lines <- data.frame(x = mst_lines[, 1], xend = mst_lines[, 3], y = mst_lines[, 2], yend = mst_lines[, 4], trajectory = "dashed")
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        edge_line <- sort(c(MSTorder[i], MSTorder[i+1]))
        mst_lines$trajectory[apply(mst_edges, 1, function(x) {all(x == edge_line)})] <- "solid"
      }
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL, linetype = trajectory), 
                            data = mst_lines, size = 1) + scale_linetype_identity()
    } else {
      # Get edges between cluster centers on trajectory
      clucenter <- mclustobj$clucenter[, 1:2]
      clulines <- NULL
      MSTorder <- get.shortest.paths(mclustobj$MSTtree, traj_start, traj_end)$vpath[[1]]
      for (i in 1:(length(MSTorder) - 1)) {
        clulines <- rbind(clulines, c(clucenter[MSTorder[i],], clucenter[MSTorder[i + 1], ]))
      }
      clulines <- data.frame(x = clulines[, 1], xend = clulines[, 3], y = clulines[, 2], yend = clulines[, 4])
      g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = NULL), data = clulines, size = 1)
    }
    g <- g + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(legend.position = "right", legend.key.size = unit(0.3, "in"), legend.text = element_text(size = 20), legend.title = element_text(size = 20)) + 
      theme(legend.key = element_blank()) + theme(panel.background = element_rect(fill = "white")) + 
      theme(axis.text.x = element_text(size = 17, color = "darkred"), 
            axis.text.y = element_text(size = 17, color = "black"), 
            axis.title.x = element_text(size = 20, vjust = -1), 
            axis.title.y = element_text(size = 20, vjust = 1), 
            plot.margin = unit(c(1, 1, 1, 1), "cm"))
    g
  }
  
  pt_traj_plot <- reactive({
    sel_traj <- as.integer(unlist(strsplit(input$pt_traj_comb, ' to ')))
    if (input$pt_traj_color == "Anchoring clusters") {
      plot_traj_clusts(samples_clust(), 
                       main_traj = sel_traj, 
                       show_side_branches = (! is.null(input$pt_traj_show_side_branch)) && (input$pt_traj_show_side_branch),
                       show_cell_names = input$pt_traj_show_sample_names, 
                       cell_name_size = input$pt_traj_sample_name_size)
    } else if (input$pt_traj_color == "Pseudotime") {
      plot_traj(samples_clust(), 
                main_traj = sel_traj, 
                pt = pred_order()$sample_name,
                show_side_branches = (! is.null(input$pt_traj_show_side_branch)) && (input$pt_traj_show_side_branch),
                show_cell_names = input$pt_traj_show_sample_names, 
                cell_name_size = input$pt_traj_sample_name_size)
    }
  })
  
  # Render plot for pseudo-time trajectory over sample clusters
  output$pt_traj <- renderPlot({
    pt_traj_plot()
  })
  
  observeEvent(input$plot_traj_plot_download, {
    download_plot(pt_traj_plot())
  })
  
  # Render pseudo-time trajectory brushed points table
  observeEvent(input$pt_traj_brush, {
    top_pcs <- pca_res()[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$pt_traj_brush, xvar = "PC1", yvar = "PC2"))
    output$pt_traj_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                                  rownames = FALSE,
                                                  filter = list(position = 'top', clear = FALSE), 
                                                  selection = "none")
  })
  
  # Render UI for pseudo time trajectory plot sample name size selection
  output$pt_traj_sample_name_size_ui <- renderUI({
    if (input$pt_traj_show_sample_names) {
      sliderInput(
        "pt_traj_sample_name_size", 
        label = "Adjust sample name sizes: ",
        min = 1, 
        max = 10,
        value = 3
      )
    }
  })
  
  # Render UI for pseudo time trajectory plot show side branches option
  output$pt_traj_show_side_branch_ui <- renderUI({
    if (nrow(pt_traj_combs()) > 2) {
      checkboxInput("pt_traj_show_side_branch", "Show side branches")
    }
  })
  
  # Download pseudo time ordered sample ids
  output$pt_traj_samples_order_download <- downloadHandler(
    filename = function() { "Pseudotime_samples.txt" },
    content = function(filename) {
      file.create(filename)
      f <- file(filename)
      writeLines(pred_order()$sample_name, f)
      close(f)
    }
  )
  
  # Scaled top variance bins matrix for samples in selected trajectory
  scaled_pt_mat <- reactive({
    scaled_mat <- t(scale(t(pca_top_var_pred_mat()[, pred_order()$sample_name])))
    scaled_mat[is.na(scaled_mat)] <- 0
    scaled_mat
  })
  
  # Filtered genomic bins BED message
  output$pt_gbin_clust_filter_bed_text <- renderText({
    bird_hits <- findOverlaps(pt_filtered_gr(), bird_ranges())
    nbird_hits <- length(unique(bird_hits@to))
    nbin_msg <- "No BIRD bins are covered by current selection. "
    if (nbird_hits > 0) {
      sel_hits <- findOverlaps(intersect(pt_filtered_gr(), custom_gr()), bird_ranges())
      nbin_msg <- paste(nbird_hits, "BIRD bins are covered by current selection. 
                        In these regions,", length(unique(sel_hits@to)), 
                        "bins are in your selected genomic range, and", 
                        nrow(pt_filtered_bins()), "are top variance bins. ")
    }
    if (is.null(pt_gbin_clust_filter_bed_msg())) {
      return(nbin_msg)
    }
    paste0(pt_gbin_clust_filter_bed_msg(), "\n", nbin_msg)
  })
  
  pt_gbin_clust_filter_bed_msg <- reactiveVal()
  
  # Filter genomic range
  pt_filtered_gr <- reactive({
    req(input$pt_show_panel)
    if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
      bed_input <- input$pt_expr_gbin_clust_filter_bed
    } else if (input$pt_show_panel == "Accessibility along pseudotime") {
      bed_input <- input$pt_acc_gbin_clust_filter_bed
    }
    if (is.null(bed_input)) {
      return(GRanges())
    }
    bed_path <- bed_input$datapath
    
    # Check BED file contents
    err <- tryCatch(
      {
        bed_df <- read.table(bed_path)
        validate(
          need(ncol(bed_df) >= 3, 
               paste("BED file must contain at least 3 space- or tab-separated columns. ")), 
          need(nrow(bed_df) > 0, 
               paste("BED file must contain at least 1 row. ")),
          need(all(bed_df[, 1] %in% chromosomes), 
               paste("BED file first column must be chromosomes. Valid values are:", 
                     paste(chromosomes, collapse = ", "))), 
          need(all(bed_df[, 2:3] %% 1 == 0), 
               "BED file second and third columns must be integers")
        )
        bed_df <- bed_df[, 1:3]
        NULL
      }, 
      error = function(e) {
        e$message
      }
    )
    pt_gbin_clust_filter_bed_msg(err)
    if (is.null(err)) {
      return(GRanges(seqnames = bed_df[, 1], 
                     ranges = IRanges(start = bed_df[, 2], 
                                      end = bed_df[, 3])))
    } else {
      return(GRanges())
    }
  })
  
  # Filter genomic bins
  pt_filtered_bins <- reactive({
    topvar_gbins <- parse_gbin(rownames(pca_top_var_pred_mat()))
    topvar_gr <- GRanges(seqnames = topvar_gbins$chromosome, 
                         ranges = IRanges(start = topvar_gbins$start,
                                          end = topvar_gbins$end))
    hits <- findOverlaps(pt_filtered_gr(), topvar_gr)
    topvar_gbins[hits@to, ]
  })
  
  # All genomic bin clustering results
  all_gbin_clust_res <- reactive({
    showModal(modalDialog("Clustering genomic bins...", footer = NULL, easyClose = TRUE, size = "s"))
    set.seed(12345)
    # Do k-means clustering with all possible number of clusters
    all_res <- list()
    for (i in 1:min(max_n_gbin, nrow(pca_top_var_pred_mat()) - 1)) {
      suppressWarnings(kmeans_res <- kmeans(scaled_pt_mat(), centers = i, nstart = 25, iter.max = 100))
      all_res[[as.character(i)]] <- kmeans_res
    }
    if (min(max_n_gbin, nrow(pca_top_var_pred_mat())) == nrow(pca_top_var_pred_mat())) {
      # Each row is its own cluster
      kmeans_res <- list()
      cluster <- 1:nrow(pca_top_var_pred_mat())
      names(cluster) <- row.names(pca_top_var_pred_mat())
      kmeans_res[['cluster']] <- cluster
      centers <- pca_top_var_pred_mat()
      row.names(centers) <- as.character(c(1:nrow(pca_top_var_pred_mat())))
      kmeans_res[['centers']] <- centers
      kmeans_res[['tot.withinss']] <- 0
      all_res[[as.character(nrow(pca_top_var_pred_mat()))]] <- kmeans_res
    }
    removeModal()
    return(all_res)
  })
  
  # All filtered genomic bin clustering results
  filtered_gbin_clust_res <- reactive({
    req(pt_filtered_bins())
    bins_df <- pt_filtered_bins()
    if (nrow(bins_df) < 2) {
      # Must select at least 2 bins
      return(all_gbin_clust_res())
    } else if (nrow(bins_df) == nrow(pca_top_var_pred_mat())) {
      # Selected all top variance bins
      return(all_gbin_clust_res())
    }
    filtered_bins <- paste0(bins_df[,1], " (", 
                            bins_df[,2], "-", 
                            bins_df[,3], ")")
    filtered_mat <- pca_top_var_pred_mat()[filtered_bins, ]
    showModal(modalDialog("Clustering genomic bins...", footer = NULL, easyClose = TRUE, size = "s"))
    set.seed(12345)
    # Do k-means clustering with all possible number of clusters
    all_res <- list()
    for (i in 1:min(max_n_gbin, nrow(filtered_mat) - 1)) {
      suppressWarnings(kmeans_res <- kmeans(scaled_pt_mat()[filtered_bins, ], centers = i, nstart = 25, iter.max = 100))
      all_res[[as.character(i)]] <- kmeans_res
    }
    if (min(max_n_gbin, nrow(filtered_mat)) == nrow(filtered_mat)) {
      # Each row is its own cluster
      kmeans_res <- list()
      cluster <- 1:nrow(filtered_mat)
      names(cluster) <- row.names(filtered_mat)
      kmeans_res[['cluster']] <- cluster
      centers <- filtered_mat
      row.names(centers) <- as.character(c(1:nrow(filtered_mat)))
      kmeans_res[['centers']] <- centers
      kmeans_res[['tot.withinss']] <- 0
      all_res[[as.character(nrow(filtered_mat))]] <- kmeans_res
    }
    removeModal()
    return(all_res)
  })
  
  # Optimal number of genomic bin clusters
  opt_n_gbin_clust <- reactive({
    # Use elbow method to find optimal number of clusters
    clust_res <- all_gbin_clust_res()
    if (input$pt_gbin_clust_use_filter) {
      clust_res <- filtered_gbin_clust_res()
    }
    wss <- sapply(clust_res, function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    }))
    return(opt_nclust)
  })
  
  # Filter genomic bins used in clustering 
  output$pt_gbin_clust_filter_ui <- renderUI({
    if (input$pt_gbin_clust_use_filter) {
      req(input$pt_show_panel)
      if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
        bed_input_id <- "pt_expr_gbin_clust_filter_bed"
      } else if (input$pt_show_panel == "Accessibility along pseudotime") {
        bed_input_id <- "pt_acc_gbin_clust_filter_bed"
      }
      tagList(
        p("Please be aware that you may only use the top variance genomic bins. "), 
        fileInput(
          bed_input_id, 
          "Choose BED file", width = "50%"
        ), 
        textOutput("pt_gbin_clust_filter_bed_text"), 
        br()
      )
    }
  })
  
  # Genomic bins clustering UI
  output$pt_gbin_clust_ui <- renderUI({
    clust_res <- all_gbin_clust_res()
    if (input$pt_gbin_clust_use_filter) {
      clust_res <- filtered_gbin_clust_res()
    }
    fluidRow(
      column(
        6, 
        sliderInput(
          "pt_n_gbin_clust", 
          label = "Number of genomic bin clusters: ", 
          min = 1, 
          max = length(clust_res), 
          value = opt_n_gbin_clust(), 
          step = 1
        ), 
        bsTooltip("pt_n_gbin_clust", 
                  title = "How many clusters do you want to group the top variance bins into? ",
                  placement = "top")
      ), 
      column(
        6, 
        checkboxInput(
          "use_opt_n_gbin_clust", 
          label = "Use optimal number of genomic bin clusters", 
          value = TRUE
        )
      )
    )
  })
  
  # Selected genomic bin clustering results
  gbin_clust_res <- reactive({
    clust_res <- all_gbin_clust_res()
    if (input$pt_gbin_clust_use_filter) {
      clust_res <- filtered_gbin_clust_res()
    }
    kmeans_res <- clust_res[[as.character(input$pt_n_gbin_clust)]]
    return(kmeans_res)
  })
  
  # Adjust clustering to account for filtered bins
  gbin_clust <- reactive({
    clust <- gbin_clust_res()$cluster
    if (input$pt_gbin_clust_use_filter) {
      clu <- rep(0, nrow(pca_top_var_pred_mat()))
      names(clu) <- rownames(pca_top_var_pred_mat())
      clu[names(clust)] <- clust
      return(clu)
    } else {
      return(clust)
    }
  })
  
  # Message stating the optimal number of clusters
  output$opt_n_gbin_clust_msg <- renderUI({
    HTML(paste("Optimal number of clusters:", strong(opt_n_gbin_clust())))
  })
  
  pt_gbin_clust_wss_plot <- reactive({
    clust_res <- all_gbin_clust_res()
    if (input$pt_gbin_clust_use_filter) {
      clust_res <- filtered_gbin_clust_res()
    }
    tot_wss <- unlist(lapply(clust_res, function(x) {x$tot.withinss}))
    wss_df <- data.frame(n_clust = c(1:length(clust_res)), 
                         wss = tot_wss)
    wcss_plot <- ggplot(data = wss_df, 
                        mapping = aes(n_clust, wss))
    wcss_plot <- wcss_plot + geom_line() + geom_point()
    wcss_plot <- wcss_plot + xlab("Number of Clusters") + ylab("Total Within Cluster Sum of Squares")
    wcss_plot <- wcss_plot + geom_vline(xintercept = opt_n_gbin_clust(), linetype="dashed", color = "blue")
    wcss_plot <- wcss_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    wcss_plot
  })
  
  # Genomic bin clusters WSS plot
  output$pt_gbin_clust_wss_plot <- renderPlot({
    pt_gbin_clust_wss_plot()
  })
  
  observeEvent(input$pt_gbin_clust_wss_plot_download, {
    download_plot(pt_gbin_clust_wss_plot())
  })
  
  # UI for genomic bin clusters WSS plot
  output$pt_gbin_clust_wss_plot_ui <- renderUI({
    if (input$pt_show_gbin_clust_wss_plot) {
      tagList(
        h4("Genomic bin clusters WSS plot"), 
        plotOutput('pt_gbin_clust_wss_plot'), 
        bsTooltip("pt_gbin_clust_wss_plot", 
                  title = "The dashed line indicates the optimal number of clusters determined by elbow method. ", 
                  placement = "top"), 
        actionButton("pt_gbin_clust_wss_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Genomic bin PCA results
  gbin_pca_res <- reactive({
    prcomp(scaled_pt_mat(), scale = FALSE, center = TRUE)
  })
  
  pt_gbin_clust_plot_pca <- reactive({
    showModal(modalDialog("Making cluster plot...", footer = NULL, easyClose = TRUE, size = "s"))
    # Plot the top 2 PCs
    clust_plot <- ggplot(data = data.frame(gbin_pca_res()$x)[, 1:2], 
                         mapping = aes(PC1, PC2, colour = factor(gbin_clust())))
    clust_plot <- clust_plot + geom_point()
    clust_plot$labels$colour <- "Cluster"
    explained_var <- summary(gbin_pca_res())$importance[2, 1:2]
    clust_plot <- clust_plot + xlab(paste0("PC1 (", explained_var[1] * 100, "% variance)"))
    clust_plot <- clust_plot + ylab(paste0("PC2 (", explained_var[2] * 100, "% variance)"))
    clust_plot <- clust_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    removeModal()
    clust_plot
  })
  
  # Render genomic bins clusters PCA plot
  output$pt_gbin_clust_plot_pca <- renderPlot({
    pt_gbin_clust_plot_pca()
  })
  
  observeEvent(input$pt_gbin_clust_plot_pca_download, {
    download_plot(pt_gbin_clust_plot_pca())
  })
  
  pt_gbin_clust_plot_umap <- reactive({
    # Run UMAP
    showModal(modalDialog("Running UMAP...", footer = NULL, easyClose = TRUE, size = "s"))
    set.seed(12345)
    pred_umap <- umap(scaled_pt_mat(), 
                      random_state = 1, 
                      n_neighbors = min(15, nrow(scaled_pt_mat()) - 1))
    layout_df <- data.frame(UMAP_1 = pred_umap$layout[, 1], 
                            UMAP_2 = pred_umap$layout[, 2])
    removeModal()
    # Plot UMAP layout
    showModal(modalDialog("Making cluster plot...", footer = NULL, easyClose = TRUE, size = "s"))
    clust_plot <- ggplot(data = layout_df, 
                         mapping = aes(UMAP_1, UMAP_2, colour = factor(gbin_clust())))
    clust_plot <- clust_plot + geom_point()
    clust_plot$labels$colour <- "Cluster"
    clust_plot <- clust_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    removeModal()
    clust_plot
  })
  
  # Render genomic bins clusters UMAP plot
  output$pt_gbin_clust_plot_umap <- renderPlot({
    pt_gbin_clust_plot_umap()
  })
  
  observeEvent(input$pt_gbin_clust_plot_umap_download, {
    download_plot(pt_gbin_clust_plot_umap())
  })
  
  # Render table for genomic bin clusters means
  output$gbin_clust_means_table <- DT::renderDataTable(aggregate(pca_top_var_pred_mat(), 
                                                                 by=list(cluster=gbin_clust()), 
                                                                 mean), 
                                                       rownames = FALSE,
                                                       filter = list(position = 'top', clear = FALSE), 
                                                       selection = "none",
                                                       options = list(scrollX = TRUE))
  
  # Render table for genomic bin cluster assignment
  output$gbin_clust_table <- DT::renderDataTable(data.frame(cluster = as.factor(gbin_clust()), 
                                                            genomic_bin = names(gbin_clust())), 
                                                 rownames = FALSE,
                                                 filter = list(position = 'top', clear = FALSE), 
                                                 selection = "none")
  
  # Differential analysis samples kmeans cluster result download
  output$gbin_clust_table_download <- downloadHandler(
    filename = function() { "Genomic_bin_clusters.txt" },
    content = function(file) {
      write.table(data.frame(cluster = as.factor(gbin_clust()), 
                             genomic_bin = names(gbin_clust())),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Render PCA brushed points table
  observeEvent(input$pt_gbin_clust_plot_pca_brush, {
    top_pcs <- data.frame(gbin_pca_res()$x)[, 1:2]
    brushed_gbins <- rownames(brushedPoints(top_pcs, input$pt_gbin_clust_plot_pca_brush, xvar = "PC1", yvar = "PC2"))
    output$pt_gbin_clust_plot_pca_brushed <- DT::renderDataTable(parse_gbin(brushed_gbins),
                                                                 rownames = FALSE,
                                                                 filter = list(position = 'top', clear = FALSE), 
                                                                 selection = "none")
  })
  
  # Render UI for pseudo time genomic bin clustering results panels
  output$pt_gbin_clust_res_panel <- renderUI({
    if (input$pt_gbin_clust_res_show_panel == "Cluster Plot (PCA)") {
      tagList(
        h4("PCA plot of genomic bin clusters"), 
        plotOutput('pt_gbin_clust_plot_pca', brush = 'pt_gbin_clust_plot_pca_brush'), 
        bsTooltip("pt_gbin_clust_plot_pca", 
                  title = "Each data point represents a genomic bin. Brush on points to see details in table. ", 
                  placement = "top"),
        actionButton("pt_gbin_clust_plot_pca_download", "Download plot", 
                     class = "regular-btn"), 
        hr(),
        h4("PCA plot brushed points table"),
        uiOutput("pt_gbin_clust_plot_pca_brush_msg"),
        DT::dataTableOutput('pt_gbin_clust_plot_pca_brushed')
      )
    } else if (input$pt_gbin_clust_res_show_panel == "Cluster Means") {
      tagList(
        h4("Genomic bins cluster means table"),
        DT::dataTableOutput('gbin_clust_means_table')
      )
    } else if (input$pt_gbin_clust_res_show_panel == "Clustering") {
      tagList(
        h4("Genomic bins clustering table"),
        downloadButton('gbin_clust_table_download', 'Download clustering table', 
                       class = "regular-btn"), 
        DT::dataTableOutput('gbin_clust_table')
      )
    } else if (input$pt_gbin_clust_res_show_panel == "Cluster Plot (UMAP)") {
      tagList(
        h4("UMAP plot of genomic bin clusters"), 
        plotOutput('pt_gbin_clust_plot_umap'), 
        actionButton("pt_gbin_clust_plot_umap_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Instructions on how to brush points
  output$pt_gbin_clust_plot_pca_brush_msg <- renderUI({
    if (is.null(input$pt_gbin_clust_plot_pca_brush)) {
      p("You can brush on PCA plot (click and drag to select points) to see 
        specific samples information in a table. ")
    }
  })
  
  # Render UI for selecting pseudo time genomic bin clustering results panels
  output$pt_gbin_clust_res_ui <- renderUI({
    if (input$pt_show_gbin_clust_res) {
      tagList(
        selectInput(
          "pt_gbin_clust_res_show_panel", 
          label = "Choose genomic bin clustering result panel to display: ", 
          choices = c("Cluster Plot (PCA)", 
                      "Cluster Plot (UMAP)", 
                      "Cluster Means", 
                      "Clustering")
        ), 
        uiOutput('pt_gbin_clust_res_panel')
      )
    }
  })
  
  # Function adapted from TSCAN singlegeneplot
  chracc_along_pt_plot <- function(geneexpr, TSCANorder) {
    Pseudotime <- NULL
    geneexpr <- geneexpr[TSCANorder[, 1]]
    exprdata <- cbind(TSCANorder, geneexpr)
    exprdata$State <- factor(exprdata$State)
    exprdata$predict <- fitted.values(mgcv::gam(geneexpr ~ s(Pseudotime, 
                                                             k = 3), data = exprdata))
    q <- ggplot(aes(Pseudotime, geneexpr), data = exprdata)
    q <- q + geom_point(aes_string(color = "State"))
    q <- q + geom_line(aes(Pseudotime, predict), data = exprdata)
    q <- q + ylab("Predicted log2 chromatin accessibility") + xlab("Pseudotime")
    q <- q + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    q
  }
  
  # Function adapted from TSCAN singlegeneplot
  expr_along_pt_plot <- function(geneexpr, TSCANorder) {
    Pseudotime <- NULL
    geneexpr <- geneexpr[TSCANorder[, 1]]
    exprdata <- cbind(TSCANorder, geneexpr)
    exprdata$State <- factor(exprdata$State)
    exprdata$predict <- fitted.values(mgcv::gam(geneexpr ~ s(Pseudotime, 
                                                             k = 3), data = exprdata))
    q <- ggplot(aes(Pseudotime, geneexpr), data = exprdata)
    q <- q + geom_point(aes_string(color = "State"))
    q <- q + geom_line(aes(Pseudotime, predict), data = exprdata)
    q <- q + ylab("Scaled log2 expression") + xlab("Pseudotime")
    q <- q + theme(strip.background = element_rect(colour = "white", 
                                                   fill = "white")) + theme(panel.border = element_blank(), 
                                                                            axis.line = element_line()) + theme(panel.grid.minor.x = element_blank(), 
                                                                                                                panel.grid.minor.y = element_blank()) + theme(panel.grid.major.x = element_blank(), 
                                                                                                                                                              panel.grid.major.y = element_blank()) + theme(panel.background = element_rect(fill = "white"))
    q
  }
  
  # Function modified from countToFPKM::fpkm
  # Solved problem of dealing with single column counts matrix
  count_to_fpkm <- function (counts, featureLength, meanFragmentLength) {
    stopifnot(length(featureLength) == nrow(counts))
    stopifnot(length(meanFragmentLength) == ncol(counts))
    effLen <- do.call(cbind, lapply(1:ncol(counts), function(i) {
      featureLength - meanFragmentLength[i] + 1
    }))
    idx <- apply(effLen, 1, function(x) min(x) > 1)
    counts <- counts[idx, , drop=FALSE]
    effLen <- effLen[idx, , drop=FALSE]
    featureLength <- featureLength[idx]
    fpkm <- do.call(cbind, lapply(1:ncol(counts), function(i) {
      N <- sum(counts[, i])
      exp(log(counts[, i]) + log(1e+09) - log(effLen[, i]) -
            log(N))
    }))
    colnames(fpkm) <- colnames(counts)
    rownames(fpkm) <- rownames(counts)
    return(fpkm)
  }
  
  # Reactive that stores selected samples expression
  expr_mat <- reactive({
    showModal(modalDialog("Retrieving expression data...", footer = NULL, easyClose = TRUE, size = "s"))
    suppressMessages(library(recount3))
    suppressMessages(library(DESeq2))
    proj <- as.character(unique(selected_samples()$project))
    sel_proj <- data.frame(project=proj, 
                           project_home=paste0("data_sources/", selected_samples()$file_source[match(proj, selected_samples()$project)]),
                           organism="human")
    mat_li <- lapply(1:nrow(sel_proj), function(i) {
      rse <- create_rse(sel_proj[i, ], recount3_url = recount3_url)
      if ((max(assay(rse)) > .Machine$integer.max) | (all(rowMins(assay(rse)) == 0))) {
        # Use a different method to get fpkm if DESeq cannot be used
        fpkm_matrix <- count_to_fpkm(assay(rse),
                                     featureLength = rse@rowRanges@elementMetadata@listData[['bp_length']],
                                     meanFragmentLength = rse$recount_seq_qc.avg_len)
      } else {
        # Get FPKM from raw counts
        deseq_obj <- DESeqDataSet(rse, design = ~ as.factor(c("study", "external_id")))
        fpkm_matrix <- DESeq2::fpkm(deseq_obj)
      }
      fpkm_matrix
    })
    fpkm_matrix <- do.call(cbind, mat_li)
    # QN
    fpkm_names <- dimnames(fpkm_matrix)
    suppressMessages(library(preprocessCore))
    fpkm_matrix <- normalize.quantiles(fpkm_matrix)
    dimnames(fpkm_matrix) <- fpkm_names
    # Log
    fpkm_matrix <- fpkm_matrix
    log_fpkm <- log2(fpkm_matrix + 1)
    # Remove version numbers from ENSEMBL ids
    rownames(log_fpkm) <- gsub("\\.\\d+$", "", rownames(log_fpkm))
    removeModal()
    log_fpkm
  })
  
  # Scaled expression matrix along pt
  scaled_expr_pt_mat <- reactive({
    scaled_mat <- t(scale(t(expr_mat()[, pred_order()$sample_name])))
    na.omit(scaled_mat)
  })
  
  pt_gbin_clust_chracc_plot <- reactive({
    mean_pt_df <- aggregate(scaled_pt_mat(), 
                            by=list(cluster=gbin_clust()), 
                            mean)
    chosen_clust_scaled <- as.numeric(mean_pt_df[mean_pt_df$cluster == input$pt_choose_gbin_clust, 2:ncol(mean_pt_df)])
    names(chosen_clust_scaled) <- pred_order()$sample_name
    chracc_along_pt_plot(chosen_clust_scaled, pred_order())
  })
  
  # Render chromatin accessibility along pseudo time plot for chosen genomic bin cluster
  output$pt_gbin_clust_chracc_plot <- renderPlot({
    pt_gbin_clust_chracc_plot()
  })
  
  observeEvent(input$pt_gbin_clust_chracc_plot_download, {
    download_plot(pt_gbin_clust_chracc_plot())
  })
  
  # Reactive value indicating whether chosen cluster bins map to at least 1 ensembl gene
  pt_gbin_clust_exist_ensembl <- reactiveVal(TRUE)
  
  # Message that indicates no expression values are associated with selected cluster
  output$pt_gbin_clust_no_ensembl_msg <- renderUI({
    if (! pt_gbin_clust_exist_ensembl()) {
      p("The selected genomic bin cluster's nearest genes do not map to any ENSEMBL genes in expression matrix. Please select a different cluster. ")
    }
  })
  
  # Scaled average expression for all clusters
  pt_all_clust_expr <- reactive({
    clu_avg_expr <- t(sapply(unique(gbin_clust_res()$cluster), function(clu) {
      pt_gbin_clust_exist_ensembl(TRUE)
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() == clu]
      # Find nearest genes
      clu_gbin_tss <- gbin_tss()[gbin_names, ]
      clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
      clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
      clu_annots <- annots()[annots()$SYMBOL %in% clu_gbin_tss$gene, ]
      # Remove 0-var genes
      clu_annots <- clu_annots[clu_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
      clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$gene %in% clu_annots$SYMBOL, ]
      if (nrow(clu_annots) == 0) {
        # No ensembl genes match gene symbol
        pt_gbin_clust_exist_ensembl(FALSE)
        return(rep(NA, ncol(scaled_expr_pt_mat())))
      }
      # Find the expr vector for each gene symbol
      gene_expr <- aggregate(scaled_expr_pt_mat()[clu_annots$ENSEMBL, , drop=F], 
                             list(gene=clu_annots$SYMBOL), mean)
      gene_expr_mat <- as.matrix.data.frame(gene_expr[, -1])
      rownames(gene_expr_mat) <- gene_expr$gene
      if (input$pt_avg_expr_across == "Bins") {
        chosen_clust_scaled <- colMeans(gene_expr_mat[clu_gbin_tss$gene, , drop=F])
        return(chosen_clust_scaled)
      } else if (input$pt_avg_expr_across == "Nearest genes") {
        chosen_clust_scaled <- colMeans(gene_expr_mat)
        return(chosen_clust_scaled)
      }
    }))
    colnames(clu_avg_expr) <- pred_order()$sample_name
    rownames(clu_avg_expr) <- unique(gbin_clust_res()$cluster)
    clu_avg_expr
  })
  
  # Scaled average expression for chosen cluster
  pt_chosen_clust_expr <- reactive({
    pt_gbin_clust_exist_ensembl(TRUE)
    chosen_clust_scaled <- pt_all_clust_expr()[as.character(input$pt_choose_gbin_clust), ]
    if (anyNA(chosen_clust_scaled)) {
      pt_gbin_clust_exist_ensembl(FALSE)
      return(NULL)
    }
    names(chosen_clust_scaled) <- pred_order()$sample_name
    chosen_clust_scaled
  })
  
  pt_gbin_clust_expr_plot <- reactive({
    if (! is.null(pt_chosen_clust_expr())) {
      expr_along_pt_plot(pt_chosen_clust_expr(), pred_order())
    }
  })
  
  # Render expression along pseudo time plot for chosen genomic bin cluster
  output$pt_gbin_clust_expr_plot <- renderPlot({
    pt_gbin_clust_expr_plot()
  })
  
  observeEvent(input$pt_gbin_clust_expr_plot_download, {
    download_plot(pt_gbin_clust_expr_plot())
  })
  
  # Make genomic bin clusters chromatin accessibility along pseudo time heat map
  pt_gbin_clust_chracc_heatmap <- reactive({
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    mean_pt_df <- aggregate(scaled_pt_mat(), 
                            by=list(cluster=gbin_clust()), 
                            mean)
    mean_pt_df <- mean_pt_df[mean_pt_df[, 1] != 0, ]
    chosen_clust_scaled <- as.matrix.data.frame(mean_pt_df[, -1])
    rownames(chosen_clust_scaled) <- mean_pt_df$cluster
    ht <- Heatmap(chosen_clust_scaled, 
                  heatmap_legend_param = list(title = "average predicted \nlog2 chromatin \naccessibility"), 
                  cluster_columns = FALSE)
    removeModal()
    return(draw(ht))
  })
  
  # Make genomic bin clusters expression along pseudo time heat map
  pt_gbin_clust_expr_heatmap <- reactive({
    if (! all(is.na(pt_all_clust_expr()))) {
      showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
      ht <- Heatmap(pt_all_clust_expr()[apply(pt_all_clust_expr(), 1, function(x){if (all(is.na(x))) {FALSE} else {TRUE}}), , drop=F], 
                    heatmap_legend_param = list(title = "average scaled log \nexpression"), 
                    cluster_columns = FALSE)
      removeModal()
      return(draw(ht))
    }
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_clust_chracc_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_clust_chracc_heatmap())
  })
  
  # Render chromatin accessibility along pseudo time heat map for chosen genomic bin cluster
  output$pt_gbin_clust_chracc_heatmap <- renderPlot({
    pt_gbin_clust_chracc_heatmap()
  })
  
  observeEvent(input$pt_gbin_clust_chracc_heatmap_download, {
    download_plot(pt_gbin_clust_chracc_heatmap())
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_clust_expr_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_clust_expr_heatmap())
  })
  
  # Render expression along pseudo time heat map for chosen genomic bin cluster
  output$pt_gbin_clust_expr_heatmap <- renderPlot({
    pt_gbin_clust_expr_heatmap()
  })
  
  observeEvent(input$pt_gbin_clust_expr_heatmap_download, {
    download_plot(pt_gbin_clust_expr_heatmap())
  })
  
  # Render genomic bin cluster chromatin accessibility visualization UI
  output$pt_gbin_clust_chracc_ui <- renderUI({
    req(input$pt_n_gbin_clust)
    if (input$pt_gbin_clust_chracc_choose_plot == "Scatterplot") {
      tagList(
        selectInput(
          'pt_choose_gbin_clust', 
          label = "Show chromatin accessibility along pseudotime for cluster: ", 
          choices = as.character(1:input$pt_n_gbin_clust)
        ), 
        h4("Genomic bin clusters average accessibility plot"),
        plotOutput('pt_gbin_clust_chracc_plot'), 
        bsTooltip("pt_gbin_clust_chracc_plot", 
                  title = "Data points are arranged in order of pseudo time along the x-axis. Each data point represents the average predicted log accessibility of the selected genomic bin cluster. ", 
                  placement = "top"), 
        actionButton("pt_gbin_clust_chracc_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_gbin_clust_chracc_choose_plot == "Heatmap") {
      if (input$pt_n_gbin_clust > 1) {
        tagList(
          h4("Genomic bin clusters average accessibility heat map"),
          # actionButton('show_interactive_pt_gbin_clust_chracc_heatmap', 
          #              "Show interactive heatmap", 
          #              class = "regular-btn"), 
          plotOutput('pt_gbin_clust_chracc_heatmap'), 
          bsTooltip("pt_gbin_clust_chracc_heatmap", 
                    title = "Heat map columns are arranged in order of pseudo time. Each heat map cell represents the average predicted log accessibility of the selected genomic bin cluster. ", 
                    placement = "top"), 
          actionButton("pt_gbin_clust_chracc_heatmap_download", "Download plot", 
                       class = "regular-btn")
        )
      } else {
        # No need to use heat map visualization
        p("Heat map cannot be generated for single row input. Please use a larger number of genomic bin clusters for heat map visualization. ")
      }
    }
  })
  
  # Render genomic bin cluster expression visualization UI
  output$pt_gbin_clust_expr_ui <- renderUI({
    req(input$pt_n_gbin_clust)
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      tagList(
        selectInput(
          'pt_choose_gbin_clust', 
          label = "Show expression along pseudotime for cluster: ", 
          choices = as.character(1:input$pt_n_gbin_clust)
        ), 
        uiOutput("pt_gbin_clust_expr_gene_dist_ui"),
        h4("Genomic bin clusters expression plot"),
        uiOutput("pt_gbin_clust_no_ensembl_msg"), 
        plotOutput('pt_gbin_clust_expr_plot'), 
        bsTooltip("pt_gbin_clust_expr_plot", 
                  title = "Data points are arranged in order of pseudo time along the x-axis. Each data point represents the scaled average log expression of the selected genomic bin cluster. ", 
                  placement = "top"), 
        actionButton("pt_gbin_clust_expr_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      if (input$pt_n_gbin_clust > 1) {
        tagList(
          uiOutput("pt_gbin_clust_expr_gene_dist_ui"),
          h4("Genomic bin clusters average expression heat map"),
          # actionButton('show_interactive_pt_gbin_clust_expr_heatmap', 
          #              "Show interactive heatmap", 
          #              class = "regular-btn"), 
          plotOutput('pt_gbin_clust_expr_heatmap'), 
          bsTooltip("pt_gbin_clust_expr_heatmap", 
                    title = "Heat map columns are arranged in order of pseudo time. Each heat map cell represents the average expression of the selected genomic bin cluster scaled across samples. ", 
                    placement = "top"), 
          actionButton("pt_gbin_clust_expr_heatmap_download", "Download plot", 
                       class = "regular-btn")
        )
      } else {
        # No need to use heat map visualization
        p("Heat map cannot be generated for single row input. Please use a larger number of genomic bin clusters for heat map visualization. ")
      }
    }
  })
  
  output$pt_gbin_clust_expr_gene_dist_ui <- renderUI({
    wellPanel(
      fluidRow(
        column(
          width = 8,
          shinyWidgets::sliderTextInput(
            "pt_gene_maxdist", 
            "Maximum distance limit of bins to nearest gene TSS", 
            choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
            post = "bp",
            width = "100%",
            selected = 500
          ),
          # sliderInput(
          #   "pt_gene_maxdist", 
          #   "Maximum distance limit of bins to nearest gene TSS",
          #   min = 0, 
          #   max = 1e6, 
          #   value = 500, 
          #   post = "bp",
          #   step = 100, 
          #   width = "100%"
          # )
        ), 
        column(
          width = 4, 
          checkboxInput(
            "pt_show_gene_dist_plot", 
            "Show distribution of cluster bins distance to genes", 
            value = FALSE
          )
        )
      ),
      uiOutput("pt_gbin_clu_ngene_msg"),
      uiOutput("pt_gbin_clust_expr_gene_dist_plot_ui")
    )
  })
  
  output$pt_gbin_clust_expr_gene_dist_plot_ui <- renderUI({
    if (input$pt_show_gene_dist_plot) {
      tagList(
        plotlyOutput("pt_gbin_clust_expr_gene_dist_plot"), 
        #actionButton("pt_gbin_clust_expr_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  pt_gbin_clust_expr_gene_dist_plot <- reactive({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() == input$pt_choose_gbin_clust]
    } else {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() != 0]
    }
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$pt_gbin_clust_expr_gene_dist_plot <- renderPlotly({pt_gbin_clust_expr_gene_dist_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_gbin_clust_expr_gene_dist_plot_download, {
    download_plotly(pt_gbin_clust_expr_gene_dist_plot())
  })
  
  output$pt_gbin_expr_gene_dist_plot_ui <- renderUI({
    if (input$pt_show_gene_dist_plot) {
      tagList(
        plotlyOutput("pt_gbin_expr_gene_dist_plot"), 
        #actionButton("pt_gbin_expr_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  pt_gbin_expr_gene_dist_plot <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$pt_gbin_expr_gene_dist_plot <- renderPlotly({pt_gbin_expr_gene_dist_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_gbin_expr_gene_dist_plot_download, {
    download_plotly(pt_gbin_expr_gene_dist_plot())
  })
  
  pt_gbin_clu_nearest_genes <- reactive({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() == input$pt_choose_gbin_clust]
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() != 0]
    }
    # Find nearest genes
    clu_gbin_tss <- gbin_tss()[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    clu_annots <- annots()[annots()$SYMBOL %in% clu_gbin_tss$gene, ]
    clu_annots <- clu_annots[clu_annots$ENSEMBL %in% rownames(expr_mat()), ]
    # Remove 0-var genes
    clu_annots <- clu_annots[clu_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
    unique(clu_annots$SYMBOL)
  })
  
  output$pt_gbin_clu_ngene_msg <- renderUI({
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() == input$pt_choose_gbin_clust]
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      gbin_names <- rownames(pca_top_var_pred_mat())[gbin_clust() != 0]
    }
    # Find nearest genes
    clu_gbin_tss <- gbin_tss()[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    if (input$pt_gbin_clust_expr_choose_plot == "Scatterplot") {
      HTML(paste("<p>There are", strong(sum(gbin_clust() == input$pt_choose_gbin_clust)), 
                 "bins in this cluster, mapping to", strong(length(unique(clu_gbin_tss$gene))), 
                 "genes inside the selected maximum mapping distance of selected bins. Of these genes,", 
                 strong(length(pt_gbin_clu_nearest_genes())), "have non-zero-variance expression values</p>"))
    } else if (input$pt_gbin_clust_expr_choose_plot == "Heatmap") {
      HTML(paste("<p>There are", strong(length(unique(clu_gbin_tss$gene))), 
                 "genes inside the selected maximum mapping distance of selected bins. Of these genes,", 
                 strong(length(pt_gbin_clu_nearest_genes())), "have non-zero-variance expression values</p>"))
    }
  })
  
  output$pt_gbin_ngene_msg <- renderUI({
    gbin_names <- rownames(pca_top_var_pred_mat())
    # Find nearest genes
    clu_gbin_tss <- gbin_tss()[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    gbin_annots <- annots()[annots()$SYMBOL %in% clu_gbin_tss$gene, ]
    gbin_annots <- gbin_annots[gbin_annots$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
    HTML(paste("<p>There are", strong(length(unique(clu_gbin_tss$gene))), 
               "genes inside the selected maximum mapping distance. Of these genes,", 
               strong(length(unique(gbin_annots$SYMBOL))), "have non-zero-variance expression values</p>"))
  })
  
  # Update chosen number of genomic bin clusters on optimal choice check box
  observeEvent(input$use_opt_n_gbin_clust, {
    if (input$use_opt_n_gbin_clust) {
      updateSliderInput(
        session, 
        "pt_n_gbin_clust", 
        value = opt_n_gbin_clust()
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of genomic clusters
  observeEvent(input$pt_n_gbin_clust, {
    if (input$pt_n_gbin_clust != opt_n_gbin_clust()) {
      updateCheckboxInput(
        session, 
        "use_opt_n_gbin_clust", 
        value = FALSE
      )
    }
  })
  
  pt_gbin_chracc_plot <- reactive({
    if (length(input$top_var_gbin_table_rows_selected == 1)) {
      chracc_along_pt_plot(pca_top_var_pred_mat()[input$top_var_gbin_table_rows_selected, ], pred_order())
    }
  })
  
  # Render chromatin accessibility along pseudo time plot for chosen genomic bin
  output$pt_gbin_chracc_plot <- renderPlot({
    pt_gbin_chracc_plot()
  })
  
  observeEvent(input$pt_gbin_chracc_plot, {
    download_plot(pt_gbin_chracc_plot())
  })
  
  # Reactive value indicating whether chosen bin maps to at least 1 ensembl gene
  pt_gbin_exist_ensembl <- reactiveVal(TRUE)
  
  # Message that indicates no expression values are associated with selected bin
  output$pt_gbin_no_ensembl_msg <- renderUI({
    if (! pt_gbin_exist_ensembl()) {
      p("The selected genomic bin's nearest gene does not map to any non-zero-variance ENSEMBL genes in expression matrix. Please select a different bin. ")
    }
  })
  
  pt_gbin_expr_plot <- reactive({
    pt_gbin_exist_ensembl(TRUE)
    if (length(input$top_var_gbin_table_rows_selected == 1)) {
      if (! top_var_gbin_table()$match_nonzero_ensembl[input$top_var_gbin_table_rows_selected]) {
        # No matching non-zero expression value found
        pt_gbin_exist_ensembl(FALSE)
        return(NULL)
      }
      gene <- as.character(top_var_gbin_table()$nearest_gene[input$top_var_gbin_table_rows_selected])
      ensembl <- annots()[annots()$SYMBOL %in% gene, "ENSEMBL"]
      gbin_expr <- colMeans(scaled_expr_pt_mat()[ensembl, , drop=F])
      names(gbin_expr) <- colnames(scaled_expr_pt_mat())
      expr_along_pt_plot(gbin_expr, pred_order())
    }
  })
  
  # Render expression along pseudo time plot for chosen genomic bin
  output$pt_gbin_expr_plot <- renderPlot({
    pt_gbin_expr_plot()
  })
  
  observeEvent(input$pt_gbin_expr_plot_download, {
    download_plot(pt_gbin_expr_plot())
  })
  
  # Make genomic bin chromatin accessibility along pseudo time heat map
  pt_gbin_chracc_heatmap <- reactive({
    if (input$pt_gbin_chracc_heatmap_show_rowlab) {
      if (is.null(input$pt_gbin_chracc_heatmap_show_nearest_genes)) {
        return(NULL)
      }
    }
    topvar_pred_mat_gbins <- rownames(pca_top_var_pred_mat())
    topvar_pred_mat <- pca_top_var_pred_mat()
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$pt_gbin_chracc_heatmap_show_rowlab && input$pt_gbin_chracc_heatmap_show_nearest_genes) {
      nearest_genes <- gbin_tss()[rownames(pca_top_var_pred_mat()), ]$gene
      nearest_genes[is.na(nearest_genes)] <- "None"
      rownames(topvar_pred_mat) <- nearest_genes
    }
    if (input$pt_gbin_chracc_heatmap_sort_by == "Decreasing variance") {
      hypervar <- pred_hypervar()$hypervar[pred_hypervar()$feature %in% topvar_pred_mat_gbins]
      sort_idx <- base::sort(hypervar, 
                             decreasing=TRUE, 
                             index.return=TRUE)$ix
      row.order <- order(sort_idx)
      cluster.rows <- FALSE
    } else if (input$pt_gbin_chracc_heatmap_sort_by == "Genomic position") {
      row.order <- order(1:nrow(topvar_pred_mat))
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    heat_mat <- topvar_pred_mat[, pred_order()[, 1]]
    if (input$pt_gbin_chracc_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat[is.na(heat_mat)] <- 0
    }
    if (! input$pt_gbin_chracc_heatmap_show_rowlab) {
      rownames(heat_mat) <- NULL
    }
    if (! input$pt_gbin_chracc_heatmap_show_collab) {
      colnames(heat_mat) <- NULL
    }
    ht <- Heatmap(heat_mat, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "predicted \nchromatin \naccessibility"), 
                  cluster_columns = FALSE)
    if (input$pt_gbin_chracc_heatmap_show_rowlab && input$pt_gbin_chracc_heatmap_show_nearest_genes) {
      ht <- ht + rowAnnotation(gbins = anno_text(topvar_pred_mat_gbins), 
                               nearest_genes = anno_text(nearest_genes))
    }
    removeModal()
    return(draw(ht))
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_chracc_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_chracc_heatmap())
  })
  
  # Render chromatin accessibility along pseudo time heat map for chosen genomic bin 
  output$pt_gbin_chracc_heatmap <- renderPlot({
    pt_gbin_chracc_heatmap()
  })
  
  observeEvent(input$pt_gbin_chracc_heatmap_download, {
    download_plot(pt_gbin_chracc_heatmap())
  })
  
  # Make genomic bin expression along pseudo time heat map
  pt_gbin_expr_heatmap <- reactive({
    if (input$pt_gbin_expr_heatmap_show_rowlab && is.null(input$pt_gbin_expr_heatmap_show_nearest_genes)) {
      return(NULL)
    }
    gbin_names <- rownames(pca_top_var_pred_mat())
    # Find nearest genes
    clu_gbin_tss <- gbin_tss()[gbin_names, ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$distance <= input$pt_gene_maxdist, ]
    clu_gbin_tss <- clu_gbin_tss[! is.na(clu_gbin_tss$gene), ]
    # Only keep genes with matching ensembl in expression matrix
    clu_annots <- annots()[annots()$SYMBOL %in% clu_gbin_tss$gene, ]
    clu_annots <- clu_annots[clu_annots$ENSEMBL %in% rownames(expr_mat()), ]
    clu_gbin_tss <- clu_gbin_tss[clu_gbin_tss$gene %in% clu_annots$SYMBOL, ]
    # Find the expr vector for each gene symbol
    gene_expr <- aggregate(expr_mat()[clu_annots$ENSEMBL, , drop=F], 
                           list(gene=clu_annots$SYMBOL), mean)
    # Genes with non-zero expression variance
    gene_expr_mat <- as.matrix.data.frame(gene_expr[, -1])
    var_genes <- gene_expr$gene[rowVars(gene_expr_mat) > 0]
    gene_expr_mat <- gene_expr_mat[gene_expr$gene %in% var_genes, , drop=F]
    rownames(gene_expr_mat) <- var_genes
    bin_genes <- clu_gbin_tss$gene[clu_gbin_tss$gene %in% var_genes]
    bin_expr_mat <- gene_expr_mat[bin_genes, colnames(scaled_expr_pt_mat()), drop=F]
    bins <- rownames(clu_gbin_tss)[clu_gbin_tss$gene %in% var_genes]
    rownames(bin_expr_mat) <- bins
    
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$pt_gbin_expr_heatmap_show_rowlab && input$pt_gbin_expr_heatmap_show_nearest_genes) {
      rownames(bin_expr_mat) <- bin_genes
    }
    if (input$pt_gbin_expr_heatmap_sort_by == "Decreasing variance") {
      max_k <- min(apply(bin_expr_mat, 2, function(x){length(unique(x))}))
      if (ncol(bin_expr_mat) >= max_k) {
        # Cannot use hypervar
        row.order <- order(rowVars(bin_expr_mat), decreasing = T)
      } else {
        hypervar <- hypervar_bulk(bin_expr_mat)
        row.order <- order(hypervar$hypervar, decreasing = T)
      }
      cluster.rows <- FALSE
    } else if (input$pt_gbin_expr_heatmap_sort_by == "Genomic position") {
      row.order <- order(1:nrow(bin_expr_mat))
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    heat_mat <- bin_expr_mat
    if (input$pt_gbin_expr_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat[is.na(heat_mat)] <- 0
    }
    if (! input$pt_gbin_expr_heatmap_show_rowlab) {
      rownames(heat_mat) <- NULL
    }
    if (! input$pt_gbin_expr_heatmap_show_collab) {
      colnames(heat_mat) <- NULL
    }
    ht <- Heatmap(heat_mat, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "log2 expression"), 
                  cluster_columns = FALSE)
    if (input$pt_gbin_expr_heatmap_show_rowlab && input$pt_gbin_expr_heatmap_show_nearest_genes) {
      ht <- ht + rowAnnotation(gbins = anno_text(bins), 
                               nearest_genes = anno_text(bin_genes))
    }
    removeModal()
    return(draw(ht))
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gbin_expr_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gbin_expr_heatmap())
  })
  
  # Render expression along pseudo time heat map for chosen genomic bin 
  output$pt_gbin_expr_heatmap <- renderPlot({
    pt_gbin_expr_heatmap()
  })
  
  observeEvent(input$pt_gbin_expr_heatmap_download, {
    download_plot(pt_gbin_expr_heatmap())
  })
  
  # Render genomic bin chromatin accessibility visualization UI
  output$pt_gbin_chracc_ui <- renderUI({
    if (input$pt_gbin_chracc_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Top variance genomic bins table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gbin_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("top_var_gbin_table_info", 
                  title = "<h4>Top variance genomic bins table</h4>", 
                  content = do.call(paste0, popover_contents()$top_var_gbin_table_info), 
                  placement = "right",
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gbin_table'), 
        hr(), 
        h4("Genomic bin chromatin accessibility along pseudo-time plot"), 
        plotOutput('pt_gbin_chracc_plot'), 
        bsTooltip("pt_gbin_chracc_plot", 
                  title = "Each point in this plot represents a sample. The samples are sorted by assigned pseudo-time point along x-axis. The y-axis values are predicted log<sub>2</sub> accessibility for each sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_chracc_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_gbin_chracc_choose_plot == "Heatmap") {
      tagList(
        h4("Genomic bin accessibility along pseudo-time heat map"), 
        fluidRow(
          column(
            4, 
            radioButtons(
              "pt_gbin_chracc_heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            )
          ),
          column(
            4, 
            checkboxInput(
              "pt_gbin_chracc_heatmap_show_rowlab", 
              label = "Show row labels (bins)", 
              value = FALSE
            ), 
            uiOutput("pt_gbin_chracc_heatmap_show_nearest_genes_ui"),
            checkboxInput(
              "pt_gbin_chracc_heatmap_show_collab", 
              label = "Show column labels (samples)", 
              value = FALSE
            )
          ),  
          column(
            4, 
            checkboxInput(
              "pt_gbin_chracc_heatmap_scale", 
              "Scale heatmap rows", 
              value = TRUE
            )
          )
        ),
        # actionButton('show_interactive_pt_gbin_chracc_heatmap', 
        #              "Show interactive heatmap", 
        #              class = "regular-btn"), 
        plotOutput('pt_gbin_chracc_heatmap'), 
        bsTooltip("pt_gbin_chracc_heatmap", 
                  title = "Columns in this heat map are samples, and they are sorted by the assigned pseudo-time point. Rows in this heat map are genomic bins. Each cell in this heat map is the predicted log<sub>2</sub> accessibility of a genomic position in a sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_chracc_heatmap_download", "Download plot",
                     class = "regular-btn")
      )
    }
  })
  
  # Render UI for showing nearest genes in row labels
  output$pt_gbin_chracc_heatmap_show_nearest_genes_ui <- renderUI({
    if (input$pt_gbin_chracc_heatmap_show_rowlab) {
      checkboxInput(
        "pt_gbin_chracc_heatmap_show_nearest_genes", 
        label = "Show nearest genes",
        value = FALSE
      )
    }
  })
  
  # Render genomic bin expression visualization UI
  output$pt_gbin_expr_ui <- renderUI({
    if (input$pt_gbin_expr_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Top variance genomic bins table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gbin_table_info_expr", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")),
        bsPopover("top_var_gbin_table_info_expr", 
                  title = "<h4>Top variance genomic bins table</h4>", 
                  content = do.call(paste0, popover_contents()$top_var_gbin_table_info_expr), 
                  placement = "right",
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gbin_table'), 
        hr(), 
        h4("Genomic bin expression along pseudo-time plot"), 
        uiOutput("pt_gbin_no_ensembl_msg"),
        plotOutput('pt_gbin_expr_plot'), 
        bsTooltip("pt_gbin_expr_plot", 
                  title = "Each point in this plot represents a sample. The samples are sorted by assigned pseudo-time point along x-axis. The y-axis values are average scaled log<sub>2</sub> expression for each sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_expr_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_gbin_expr_choose_plot == "Heatmap") {
      tagList(
        h4("Genomic bin expression along pseudo-time heat map"), 
        fluidRow(
          column(
            4, 
            radioButtons(
              "pt_gbin_expr_heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            )
          ), 
          column(
            4, 
            checkboxInput(
              "pt_gbin_expr_heatmap_show_rowlab", 
              label = "Show row labels (bins)", 
              value = FALSE
            ), 
            uiOutput("pt_gbin_expr_heatmap_show_nearest_genes_ui"),
            checkboxInput(
              "pt_gbin_expr_heatmap_show_collab", 
              label = "Show column labels (samples)", 
              value = FALSE
            )
          ),  
          column(
            4, 
            checkboxInput(
              "pt_gbin_expr_heatmap_scale", 
              "Scale heatmap rows", 
              value = TRUE
            )
          )
        ),
        # actionButton('show_interactive_pt_gbin_expr_heatmap', 
        #              "Show interactive heatmap", 
        #              class = "regular-btn"), 
        plotOutput('pt_gbin_expr_heatmap'), 
        bsTooltip("pt_gbin_expr_heatmap", 
                  title = "Columns in this heat map are samples, and they are sorted by the assigned pseudo-time point. Rows in this heat map are genomic bins. Each cell in this heat map is the average scaled log<sub>2</sub> expression of a genomic position in a sample. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gbin_expr_heatmap_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Render UI for showing nearest genes in row labels
  output$pt_gbin_expr_heatmap_show_nearest_genes_ui <- renderUI({
    if (input$pt_gbin_expr_heatmap_show_rowlab) {
      checkboxInput(
        "pt_gbin_expr_heatmap_show_nearest_genes", 
        label = "Show nearest genes",
        value = FALSE
      )
    }
  })
  
  top_var_gbin_table <- reactive({
    showModal(modalDialog("Rendering top variance genomic bins information table...", footer = NULL, easyClose = TRUE, size = "s"))
    gbin_names <- rownames(pca_top_var_pred_mat())
    df <- parse_gbin(rownames(pca_top_var_pred_mat()))
    topvar_gbin_tss <- gbin_tss()[gbin_names, ]
    topvar_gbin_snp <- gbin_snp()[gbin_names, ]
    df$nearest_gene <- as.factor(topvar_gbin_tss$gene)
    if ((! is.null(input$pt_show_panel)) && 
        (input$pt_show_panel == "Nearest gene expression along pseudotime")) {
      # Only include match_nonzero_ensembl for expr along pt to avoid loading 
      # expr data for chracc along pt
      valid_annots <- annots()[annots()$ENSEMBL %in% rownames(scaled_expr_pt_mat()), ]
      df$match_nonzero_ensembl <- topvar_gbin_tss$gene %in% valid_annots$SYMBOL
    }
    df$distance_to_gene <- topvar_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(topvar_gbin_tss$relative_position_to_tss)
    df$nearest_snp <- topvar_gbin_snp$snp_id
    df$snp_position <- topvar_gbin_snp$position
    df$snp_associated_trait <- topvar_gbin_snp[, 3]
    df$distance_to_snp <- topvar_gbin_snp$distance
    if ((! is.null(input$pt_show_panel)) && 
        (input$pt_show_panel == "Nearest gene expression along pseudotime")) {
      df <- df[! is.na(df$distance_to_gene), ]
      df <- df[df$distance_to_gene <= input$pt_gene_maxdist, ]
    }
    removeModal()
    df
  })
  
  # Top variance genomic bins data table
  output$top_var_gbin_table <- DT::renderDataTable({
    DT::datatable(top_var_gbin_table(), 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'single', 
                  options = list(scrollX = TRUE))
  })
  
  pt_gene_chracc_gene_dist_plot <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_chracc_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_chracc_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$pt_gene_chracc_gene_dist_plot <- renderPlotly({
    pt_gene_chracc_gene_dist_plot()
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_gene_chracc_gene_dist_plot_download, {
    download_plotly(pt_gene_chracc_gene_dist_plot())
  })
  
  output$pt_gene_expr_gene_dist_plot_ui <- renderUI({
    if (input$pt_show_gene_expr_gene_dist_plot) {
      tagList(
        plotlyOutput("pt_gene_expr_gene_dist_plot"), 
        #actionButton("pt_gene_expr_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  pt_gene_expr_gene_dist_plot <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_gene_expr_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_gene_expr_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$pt_gene_expr_gene_dist_plot <- renderPlotly({pt_gene_expr_gene_dist_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_gene_expr_gene_dist_plot_download, {
    download_plotly(pt_gene_expr_gene_dist_plot())
  })
  
  pca_top_var_nearest_genes <- reactive({
    req(input$pt_show_panel)
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    maxdist <- NULL
    if (input$pt_show_panel == "Nearest gene expression along pseudotime") {
      req(input$pt_expr_dat_type)
      req(input$pt_gene_expr_gene_maxdist)
      if (input$pt_expr_dat_type == "Gene average") {
        maxdist <- input$pt_gene_expr_gene_maxdist
        nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= maxdist, ]$gene)
        nearest_genes <- nearest_genes[nearest_genes %in% annots()$SYMBOL]
      }
    } else if (input$pt_show_panel == "Accessibility along pseudotime") {
      req(input$pt_chracc_dat_type)
      req(input$pt_gene_chracc_gene_maxdist)
      if (input$pt_chracc_dat_type == "Gene average") {
        maxdist <- input$pt_gene_chracc_gene_maxdist
        nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= maxdist, ]$gene)
      }
    }
    if (is.null(maxdist)) {return(data.frame(genes=c()))}
    data.frame(genes = nearest_genes[! is.na(nearest_genes)])
  })
  
  # Top variance genes data table
  output$top_var_gene_table <- DT::renderDataTable({
    DT::datatable(pca_top_var_nearest_genes(), 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'single')
  })
  
  # Render pseudo time analysis selected gene TSS table
  output$pt_gene_tss_table <- DT::renderDataTable({
    selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
    selected_gene_tss <- gene_tss()[which(gene_tss()$Gene == selected_gene), -3]
    DT::datatable(selected_gene_tss, 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'none')
  })
  
  # Render pseudo time analysis selected gene TSS table UI
  output$pt_gene_tss_table_ui <- renderUI({
    if (input$pt_gene_show_tss_table) {
      tagList(
        h4("Selected gene's transcriptional start sites table"), 
        DT::dataTableOutput('pt_gene_tss_table')
      )
    }
  })
  
  # Vector of associated genomic bins for selected gene in pseudo time analysis
  pt_selected_gene_gbins <- reactive({
    selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
    all_gene_gbins <- rownames(gbin_tss())[which(gbin_tss()$gene == selected_gene)]
    all_gene_gbins[which(all_gene_gbins %in% rownames(pca_top_var_pred_mat()))]
  })
  
  # Render pseudo time analysis selected gene gbins table
  output$pt_gene_gbins_table <- DT::renderDataTable({
    DT::datatable(parse_gbin(pt_selected_gene_gbins()), 
                  rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = 'none')
  })
  
  # Render pseudo time analysis selected gene gbins table UI
  output$pt_gene_gbins_table_ui <- renderUI({
    if (input$pt_gene_show_gbins_table) {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Gene's nearest genomic bins table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("pt_gene_gbins_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")), 
        bsPopover("pt_gene_gbins_table_info", 
                  title = "<h4>Nearest genomic bins table</h4>", 
                  content = do.call(paste0, popover_contents()$pt_gene_gbins_table_info), 
                  placement = "right",
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)), 
        DT::dataTableOutput('pt_gene_gbins_table')
      )
    }
  })
  
  pt_gene_chracc_plot <- reactive({
    if (length(input$top_var_gene_table_rows_selected == 1)) {
      # Get predicted chromatin accessibility for associated bins
      near_gbins_chracc <- pca_top_var_pred_mat()[pt_selected_gene_gbins(), ]
      # Get mean accessibility
      if (length(pt_selected_gene_gbins()) > 1) {
        near_gbins_chracc <- colMeans(near_gbins_chracc)
      }
      chracc_along_pt_plot(near_gbins_chracc, pred_order())
    }
  })
  
  # Render chromatin accessibility along pseudo time plot for chosen gene
  output$pt_gene_chracc_plot <- renderPlot({
    pt_gene_chracc_plot()
  })
  
  observeEvent(input$pt_gene_chracc_plot_download, {
    download_plot(pt_gene_chracc_plot())
  })
  
  pt_gene_expr_plot <- reactive({
    if (length(input$top_var_gene_table_rows_selected == 1)) {
      # Get expression for gene
      selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
      ensembls <- annots()$ENSEMBL[annots()$SYMBOL == selected_gene]
      ensembls <- ensembls[ensembls %in% rownames(scaled_expr_pt_mat())]
      if (length(ensembls) == 0) {
        return(NULL)
      }
      gene_expr <- colMeans(scaled_expr_pt_mat()[ensembls, , drop=F])
      names(gene_expr) <- colnames(scaled_expr_pt_mat())
      expr_along_pt_plot(gene_expr, pred_order())
    }
  })
  
  # Render expression along pseudo time plot for chosen gene
  output$pt_gene_expr_plot <- renderPlot({
    pt_gene_expr_plot()
  })
  
  observeEvent(input$pt_gene_expr_plot_download, {
    download_plot(pt_gene_expr_plot())
  })
  
  # Render text message indicating ENSEMBL genes that selected gene maps to
  output$pt_gene_expr_ensembl_msg <- renderText({
    selected_gene <- pca_top_var_nearest_genes()$genes[input$top_var_gene_table_rows_selected]
    ensembls <- annots()$ENSEMBL[annots()$SYMBOL == selected_gene]
    var_ensembls <- ensembls[ensembls %in% rownames(scaled_expr_pt_mat())]
    paste0("The selected gene maps to the following ENSEMBL genes: ", 
           paste(ensembls, collapse = ", "), 
           ", of which ", length(var_ensembls), 
           " (", paste(var_ensembls, collapse = ", "), ") are of non-zero expression variance.")
  })
  
  # Make gene chromatin accessibility along pseudo time heat map
  pt_gene_chracc_heatmap <- reactive({
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    # Get average chromatin accessibility for each gene
    avg_chracc <- lapply(pca_top_var_nearest_genes()$genes, function(x) {
      gbins <- rownames(gbin_tss())[which(gbin_tss()$gene == x)]
      # Get predicted chromatin accessibility for associated bins
      near_gbins_chracc <- pca_top_var_pred_mat()[which(rownames(pca_top_var_pred_mat()) %in% gbins), ]
      # Get mean accessibility
      if (length(which(rownames(pca_top_var_pred_mat()) %in% gbins)) > 1) {
        colMeans(near_gbins_chracc)
      } else {
        near_gbins_chracc
      }
    })
    avg_chracc <- as.data.frame(do.call(rbind, avg_chracc))
    rownames(avg_chracc) <- pca_top_var_nearest_genes()$genes
    heat_mat <- as.matrix(avg_chracc[, pred_order()[, 1]])
    if (input$pt_gene_chracc_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat[is.na(heat_mat)] <- 0
    }
    ht <- Heatmap(heat_mat, 
                  heatmap_legend_param = list(title = "predicted \nchromatin \naccessibility"), 
                  cluster_columns = FALSE)
    removeModal()
    return(draw(ht))
  })
  
  # Make gene expression along pseudo time heat map
  pt_gene_expr_heatmap <- reactive({
    req(input$pt_gene_expr_choose_plot == "Heatmap")
    req(any(annots()$SYMBOL %in% pca_top_var_nearest_genes()$genes))
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    # Get expression for each gene
    ensembl_annots <- annots()[annots()$SYMBOL %in% pca_top_var_nearest_genes()$genes, ]
    heat_mat <- aggregate(expr_mat()[ensembl_annots$ENSEMBL, pred_order()$sample_name, drop=F], 
                          by = list(gene=ensembl_annots$SYMBOL), 
                          mean)
    colnames(heat_mat) <- pred_order()$sample_name
    rownames(heat_mat) <- heat_mat$gene
    heat_mat <- as.matrix(heat_mat[, -1])
    if (input$pt_gene_expr_heatmap_scale) {
      heat_mat <- t(scale(t(heat_mat)))
      heat_mat <- na.omit(heat_mat)
    }
    ht <- Heatmap(heat_mat, 
                  heatmap_legend_param = list(title = "expression"), 
                  cluster_columns = FALSE)
    removeModal()
    return(draw(ht))
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_pt_gene_chracc_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, pt_gene_chracc_heatmap())
  })
  
  # Render chromatin accessibility along pseudo time heat map for chosen gene
  output$pt_gene_chracc_heatmap <- renderPlot({
    pt_gene_chracc_heatmap()
  })
  
  observeEvent(input$pt_gene_chracc_heatmap_download, {
    download_plot(pt_gene_chracc_heatmap())
  })
  
  # Render expression along pseudo time heat map
  output$pt_gene_expr_heatmap <- renderPlot({
    pt_gene_expr_heatmap()
  })
  
  observeEvent(input$pt_gene_expr_heatmap_download, {
    download_plot(pt_gene_expr_heatmap())
  })
  
  # Render gene chromatin accessibility visualization UI
  output$pt_gene_chracc_ui <- renderUI({
    if (input$pt_gene_chracc_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Genes table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gene_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")), 
        bsPopover("top_var_gene_table_info", 
                  title = "<h4>Table for genes near top variance genomic bins</h4>", 
                  content = do.call(paste0, popover_contents()$top_var_gene_table_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gene_table'), 
        checkboxInput(
          'pt_gene_show_tss_table', 
          label = "Show selected gene's transcription start sites", 
          value = FALSE
        ), 
        uiOutput('pt_gene_tss_table_ui'),
        checkboxInput(
          'pt_gene_show_gbins_table', 
          label = "Show selected gene's associated genomic bins", 
          value = FALSE
        ), 
        uiOutput('pt_gene_gbins_table_ui'),
        h4("Gene average accessibility along pseudo-time plot"), 
        plotOutput('pt_gene_chracc_plot'), 
        bsTooltip("pt_gene_chracc_plot", 
                  title = "Along the x-axis of this plot are the samples sorted in assigned pseudo-time. The data point y-values are the average predicted log<sub>2</sub> chromatin accessibility for genomic bins nearest the selected gene. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gene_chracc_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_gene_chracc_choose_plot == "Heatmap") {
      if (nrow(pca_top_var_nearest_genes()) >= 2) {
        tagList(
          h4("Gene average accessibility along pseudo-time heat map"), 
          # actionButton('show_interactive_pt_gene_chracc_heatmap', 
          #              "Show interactive heatmap", 
          #              class = "regular-btn"), 
          checkboxInput("pt_gene_chracc_heatmap_scale", "Scale heatmap rows", value = TRUE),
          plotOutput('pt_gene_chracc_heatmap'),
          bsTooltip("pt_gene_chracc_heatmap", 
                    title = "The heat map columns are samples sorted in assigned pseudo-time. The rows are the genes near top variance genomic bins. Each heat map cell shows the average predicted log<sub>2</sub> chromatin accessibility for genomic bins nearest the gene. ", 
                    placement = "top", 
                    options = list(html = TRUE)), 
          actionButton("pt_gene_chracc_heatmap_download", "Download plot", 
                       class = "regular-btn")
        )
      } else {
        # No need to use heat map visualization
        p("Not enough genes to generate heat map. At least 2 genes are required for heat map visualization. ")
      }
    }
  })
  
  # Render gene expression visualization UI
  output$pt_gene_expr_ui <- renderUI({
    if (input$pt_gene_expr_choose_plot == "Scatterplot") {
      tagList(
        tags$div(style = "display:inline-block; vertical-align:middle;", h4("Genes table")), 
        tags$div(style = "display:inline-block; vertical-align:middle;", 
                 bsButton("top_var_gene_table_info", 
                          label = "", 
                          icon = icon("info"), 
                          info = "info", 
                          size = "extra-small")), 
        bsPopover("top_var_gene_table_info", 
                  title = "<h4>Table for genes near top variance genomic bins</h4>", 
                  content = do.call(paste0, popover_contents()$top_var_gene_table_info), 
                  placement = "right", 
                  trigger = "focus", 
                  options = list(container = "body", 
                                 html = TRUE)),
        DT::dataTableOutput('top_var_gene_table'), 
        checkboxInput(
          'pt_gene_show_tss_table', 
          label = "Show selected gene's transcription start sites", 
          value = FALSE
        ), 
        uiOutput('pt_gene_tss_table_ui'),
        checkboxInput(
          'pt_gene_show_gbins_table', 
          label = "Show selected gene's associated genomic bins", 
          value = FALSE
        ), 
        uiOutput('pt_gene_gbins_table_ui'),
        h4("Gene expression along pseudo-time plot"), 
        plotOutput('pt_gene_expr_plot'), 
        textOutput("pt_gene_expr_ensembl_msg"), 
        bsTooltip("pt_gene_expr_plot", 
                  title = "Along the x-axis of this plot are the samples sorted in assigned pseudo-time. The data point y-values are the scaled log<sub>2</sub> expression for the selected gene. ", 
                  placement = "top", 
                  options = list(html = TRUE)), 
        actionButton("pt_gene_expr_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_gene_expr_choose_plot == "Heatmap") {
      if ((! is.null(pca_top_var_nearest_genes())) && (nrow(pca_top_var_nearest_genes()) >= 2)) {
        tagList(
          h4("Gene expression along pseudo-time heat map"), 
          # actionButton('show_interactive_pt_gene_expr_heatmap', 
          #              "Show interactive heatmap", 
          #              class = "regular-btn"), 
          checkboxInput("pt_gene_expr_heatmap_scale", "Scale heatmap rows", value = TRUE),
          plotOutput('pt_gene_expr_heatmap'),
          bsTooltip("pt_gene_expr_heatmap", 
                    title = "The heat map columns are samples sorted in assigned pseudo-time. The rows are the genes near top variance genomic bins. Each heat map cell shows the log<sub>2</sub> expression of a gene. ", 
                    placement = "top", 
                    options = list(html = TRUE)), 
          actionButton("pt_gene_expr_heatmap_download", "Download plot", 
                       class = "regular-btn")
        )
      } else {
        # No need to use heat map visualization
        p("Not enough genes to generate heat map. At least 2 genes are required for heat map visualization. ")
      }
    }
  })
  
  # Render differential test following pseudo-time UI
  output$pt_diff_ui <- renderUI({
    if (is.null(input$pt_n_pc)) {
      p("Please go to Pseudo-time analysis tab to compute and select a pseudo-time trajectory first. ")
    } else {
      sidebarLayout(
        sidebarPanel(
          selectInput(
            "pt_diff_show_panel", 
            "Show differential test results for:", 
            choices = c("Individual genomic bins", 
                        "Genomic bin clusters", 
                        "Gene average accessibility")
          ),
          uiOutput("pt_diff_opts_ui"), 
          actionButton("run_pt_diff_test", "Perform Test", 
                       class = "important-btn")
        ), 
        mainPanel(
          uiOutput("pt_diff_res_panels")
        )
      )
    }
  })
  
  # Render UI for differential test along pseudo time options
  output$pt_diff_opts_ui <- renderUI({
    if (input$pt_diff_show_panel == "Genomic bin clusters") {
      tagList(
        checkboxInput(
          "pt_diff_gbin_clust_use_filter", 
          "Filter genomic bins used in clustering", 
          value = FALSE
        ),
        uiOutput("pt_diff_gbin_clust_filter_ui"),
        uiOutput("pt_diff_gbin_clust_ui"),
        # sliderInput(
        #   "pt_diff_n_gbin_clust", 
        #   label = "Number of genomic bin clusters: ", 
        #   min = 1, 
        #   max = min(max_n_gbin, nrow(pred_mat())), 
        #   value = opt_n_gbin_clust(), 
        #   step = 1
        # ), 
        # bsTooltip("pt_diff_n_gbin_clust", 
        #           title = "How many clusters do you want to group the top variance bins into? Detailed clustering results are shown in Pseudo-time analysis tab. ",
        #           placement = "right", 
        #           options = list(container = "body", 
        #                          html = TRUE)), 
        # checkboxInput(
        #   "pt_diff_use_opt_n_gbin_clust", 
        #   label = "Use optimal number of genomic bin clusters", 
        #   value = TRUE
        # ), 
        htmlOutput('pt_diff_opt_n_gbin_clust_msg'),
        bsTooltip("pt_diff_opt_n_gbin_clust_msg", 
                  title = "The optimal number of genomic bin clusters is determined by elbow method. ",
                  placement = "right", 
                  options = list(container = "body", 
                                 html = TRUE))
      )
    } else if (input$pt_diff_show_panel == "Gene average accessibility") {
      tagList(
        wellPanel(
          fluidRow(
            column(
              width = 8,
              # Select distance limit for mapping bins to nearest genes
              shinyWidgets::sliderTextInput(
                "pt_diff_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS", 
                choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
                post = "bp",
                selected = 500
              ),
            ), 
            column(
              width = 4, 
              checkboxInput(
                "pt_diff_show_gene_dist_plot", 
                "Show distribution of cluster bins distance to genes", 
                value = FALSE
              )
            )
          ), 
          uiOutput("pt_diff_ngene_msg"), 
          uiOutput("pt_diff_gene_dist_plot_ui")
        )
      )
    }
  })
  
  # Genomic bins clustering UI
  output$pt_diff_gbin_clust_ui <- renderUI({
    clust_res <- all_gbin_clust_res()
    if (input$pt_diff_gbin_clust_use_filter) {
      clust_res <- pt_diff_filtered_gbin_clust_res()
    }
    tagList(
      sliderInput(
        "pt_diff_n_gbin_clust", 
        label = "Number of genomic bin clusters: ", 
        min = 1, 
        max = length(clust_res), 
        value = pt_diff_opt_n_gbin_clust(), 
        step = 1
      ), 
      bsTooltip("pt_diff_n_gbin_clust", 
                title = "How many clusters do you want to group the top variance bins into? Detailed clustering results are shown in Pseudo-time analysis tab. ",
                placement = "right", 
                options = list(container = "body", 
                               html = TRUE)), 
      checkboxInput(
        "pt_diff_use_opt_n_gbin_clust", 
        label = "Use optimal number of genomic bin clusters", 
        value = TRUE
      )
    )
  })
  
  # Filter genomic bins used in clustering 
  output$pt_diff_gbin_clust_filter_ui <- renderUI({
    if (input$pt_diff_gbin_clust_use_filter) {
      tagList(
        p("Please be aware that you may only use the top variance genomic bins. "), 
        fileInput(
          "pt_diff_gbin_clust_filter_bed", 
          "Choose BED file", width = "50%"
        ), 
        textOutput("pt_diff_gbin_clust_filter_bed_text"), 
        br()
      )
    }
  })
  
  output$pt_diff_gene_dist_plot_ui <- renderUI({
    if (input$pt_diff_show_gene_dist_plot) {
      tagList(
        plotlyOutput("pt_diff_gene_dist_plot"), 
        #actionButton("pt_diff_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  # Update chosen number of genomic bin clusters on optimal choice check box
  observeEvent(input$pt_diff_use_opt_n_gbin_clust, {
    if (input$pt_diff_use_opt_n_gbin_clust) {
      updateSliderInput(
        session, 
        "pt_diff_n_gbin_clust", 
        value = pt_diff_opt_n_gbin_clust()
      )
    }
  })
  
  pt_diff_gene_dist_plot <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_diff_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Selected genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$pt_diff_gene_dist_plot <- renderPlotly({pt_diff_gene_dist_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_gene_dist_plot_download, {
    download_plotly(pt_diff_gene_dist_plot())
  })
  
  pt_diff_nearest_genes <- reactive({
    gbin_names <- rownames(pca_top_var_pred_mat())
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_gene_maxdist, ]$gene)
    nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    nearest_genes
  })
  
  output$pt_diff_ngene_msg <- renderUI({
    HTML(paste("<p>", strong(length(pt_diff_nearest_genes())), "genes are inside the selected maximum mapping distance of selected bins. </p>"))
  })
  
  pt_diff_gbin_clust_filter_bed_msg <- reactiveVal()
  
  # Filter genomic range
  pt_diff_filtered_gr <- reactive({
    bed_input <- input$pt_diff_gbin_clust_filter_bed
    if (is.null(bed_input)) {
      return(GRanges())
    }
    bed_path <- bed_input$datapath
    
    # Check BED file contents
    err <- tryCatch(
      {
        bed_df <- read.table(bed_path)
        validate(
          need(ncol(bed_df) >= 3, 
               paste("BED file must contain at least 3 space- or tab-separated columns. ")), 
          need(nrow(bed_df) > 0, 
               paste("BED file must contain at least 1 row. ")),
          need(all(bed_df[, 1] %in% chromosomes), 
               paste("BED file first column must be chromosomes. Valid values are:", 
                     paste(chromosomes, collapse = ", "))), 
          need(all(bed_df[, 2:3] %% 1 == 0), 
               "BED file second and third columns must be integers")
        )
        bed_df <- bed_df[, 1:3]
        NULL
      }, 
      error = function(e) {
        e$message
      }
    )
    pt_diff_gbin_clust_filter_bed_msg(err)
    if (is.null(err)) {
      return(GRanges(seqnames = bed_df[, 1], 
                     ranges = IRanges(start = bed_df[, 2], 
                                      end = bed_df[, 3])))
    } else {
      return(GRanges())
    }
  })
  
  # Filter genomic bins
  pt_diff_filtered_bins <- reactive({
    topvar_gbins <- parse_gbin(rownames(pca_top_var_pred_mat()))
    topvar_gr <- GRanges(seqnames = topvar_gbins$chromosome, 
                         ranges = IRanges(start = topvar_gbins$start,
                                          end = topvar_gbins$end))
    hits <- findOverlaps(pt_diff_filtered_gr(), topvar_gr)
    topvar_gbins[hits@to, ]
  })
  
  # All filtered genomic bin clustering results
  pt_diff_filtered_gbin_clust_res <- reactive({
    req(pt_diff_filtered_bins())
    bins_df <- pt_diff_filtered_bins()
    if (nrow(bins_df) < 2) {
      # Must select at least 2 bins
      return(all_gbin_clust_res())
    } else if (nrow(bins_df) == nrow(pca_top_var_pred_mat())) {
      # Selected all top variance bins
      return(all_gbin_clust_res())
    }
    filtered_bins <- paste0(bins_df[,1], " (", 
                            bins_df[,2], "-", 
                            bins_df[,3], ")")
    filtered_mat <- pca_top_var_pred_mat()[filtered_bins, ]
    showModal(modalDialog("Clustering genomic bins...", footer = NULL, easyClose = TRUE, size = "s"))
    set.seed(12345)
    # Do k-means clustering with all possible number of clusters
    all_res <- list()
    for (i in 1:min(max_n_gbin, nrow(filtered_mat) - 1)) {
      suppressWarnings(kmeans_res <- kmeans(scaled_pt_mat()[filtered_bins, ], centers = i, nstart = 25, iter.max = 100))
      all_res[[as.character(i)]] <- kmeans_res
    }
    if (min(max_n_gbin, nrow(filtered_mat)) == nrow(filtered_mat)) {
      # Each row is its own cluster
      kmeans_res <- list()
      cluster <- 1:nrow(filtered_mat)
      names(cluster) <- row.names(filtered_mat)
      kmeans_res[['cluster']] <- cluster
      centers <- filtered_mat
      row.names(centers) <- as.character(c(1:nrow(filtered_mat)))
      kmeans_res[['centers']] <- centers
      kmeans_res[['tot.withinss']] <- 0
      all_res[[as.character(nrow(filtered_mat))]] <- kmeans_res
    }
    removeModal()
    return(all_res)
  })
  
  # Optimal number of genomic bin clusters
  pt_diff_opt_n_gbin_clust <- reactive({
    # Use elbow method to find optimal number of clusters
    clust_res <- all_gbin_clust_res()
    if (input$pt_diff_gbin_clust_use_filter) {
      clust_res <- pt_diff_filtered_gbin_clust_res()
    }
    wss <- sapply(clust_res, function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    }))
    return(opt_nclust)
  })
  
  # Selected genomic bin clustering results
  pt_diff_gbin_clust_res <- reactive({
    req(input$pt_diff_n_gbin_clust)
    clust_res <- all_gbin_clust_res()
    if (input$pt_diff_gbin_clust_use_filter) {
      clust_res <- pt_diff_filtered_gbin_clust_res()
    }
    kmeans_res <- clust_res[[as.character(input$pt_diff_n_gbin_clust)]]
    return(kmeans_res)
  })
  
  # Adjust clustering to account for filtered bins
  pt_diff_gbin_clust <- reactive({
    clust <- pt_diff_gbin_clust_res()$cluster
    if (input$pt_diff_gbin_clust_use_filter) {
      clu <- rep(0, nrow(pca_top_var_pred_mat()))
      names(clu) <- rownames(pca_top_var_pred_mat())
      clu[names(clust)] <- clust
      return(clu)
    } else {
      return(clust)
    }
  })
  
  # Filtered genomic bins BED message
  output$pt_diff_gbin_clust_filter_bed_text <- renderText({
    bird_hits <- findOverlaps(pt_diff_filtered_gr(), bird_ranges())
    nbird_hits <- length(unique(bird_hits@to))
    nbin_msg <- "No BIRD bins are covered by current selection. "
    if (nbird_hits > 0) {
      sel_hits <- findOverlaps(intersect(pt_diff_filtered_gr(), custom_gr()), bird_ranges())
      nbin_msg <- paste(nbird_hits, "BIRD bins are covered by current selection. 
                        In these regions,", length(unique(sel_hits@to)), 
                        "bins are in your selected genomic range, and", 
                        nrow(pt_diff_filtered_bins()), "are top variance bins. ")
    }
    if (is.null(pt_diff_gbin_clust_filter_bed_msg())) {
      return(nbin_msg)
    }
    paste0(pt_diff_gbin_clust_filter_bed_msg(), "\n", nbin_msg)
  })
  
  # Message stating the optimal number of clusters
  output$pt_diff_opt_n_gbin_clust_msg <- renderUI({
    HTML(paste("Optimal number of clusters:", strong(pt_diff_opt_n_gbin_clust())))
  })
  
  # Differential test along pseudo time
  pt_difftest <- function(data, order, df = 3) {   
    ptime <- 1:length(order)
    pval <- apply(data[,order,drop=F], 1, function(x) {
      if (sum(x) == 0) {
        1
      } else {
        model <- mgcv::gam(x~s(ptime,k=df))
        pchisq(model$null.deviance - model$deviance, model$df.null - model$df.residual,lower.tail = F)
      }
    })      
    fdr <- p.adjust(pval, method = "fdr")
    res <- data.frame(pvalue = pval,FDR = fdr)
  }
  
  # Perform differential tests along pt (adapted from TSCAN)
  pt_diff_test_res <- reactive({
    if (input$run_pt_diff_test > 0) {
      isolate({
        pt_diff_test_param_change(FALSE)
        showModal(modalDialog("Running differential test...", size = "s", easyClose = TRUE, footer = NULL))
        if (input$pt_diff_show_panel == "Individual genomic bins") {
          res <- data.frame(genomic_bin = row.names(pca_top_var_pred_mat()), 
                            pt_difftest(data = pca_top_var_pred_mat(), order = pred_order()$sample_name), 
                            stringsAsFactors = F)
          removeModal()
          return(res)
        } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
          if (! is.null(pt_diff_gbin_clust())) {
            clust_means <- aggregate(pca_top_var_pred_mat(), 
                                     by=list(cluster=pt_diff_gbin_clust()), 
                                     mean)
            # Remove filtered bins clust
            clust_means <- clust_means[clust_means$cluster != 0, ]
            rownames(clust_means) <- clust_means$cluster
            clust_means <- clust_means[, 2:ncol(clust_means)]
            res <- data.frame(cluster = row.names(clust_means), 
                              pt_difftest(data = clust_means, order = pred_order()$sample_name), 
                              stringsAsFactors = F)
            removeModal()
            return(res)
          }
        } else if (input$pt_diff_show_panel == "Gene average accessibility") {
          topvar_gbin_tss <- gbin_tss()[rownames(pca_top_var_pred_mat()), ]
          topvar_gbin_tss <- topvar_gbin_tss[! is.na(topvar_gbin_tss$distance), ]
          topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
          topvar_gbin_tss <- topvar_gbin_tss[! is.na(rownames(topvar_gbin_tss)), ]
          gene_avg <- aggregate(pca_top_var_pred_mat()[rownames(topvar_gbin_tss), ], 
                                by=list(gene=topvar_gbin_tss$gene), 
                                mean)
          rownames(gene_avg) <- gene_avg$gene
          gene_avg <- gene_avg[, 2:ncol(gene_avg)]
          res <- data.frame(gene = row.names(gene_avg), 
                            pt_difftest(data = gene_avg, order = pred_order()$sample_name), 
                            stringsAsFactors = F)
          removeModal()
          return(res)
        }
      })
    }
  })
  
  # Keep track of whether pt diff test parameters changed since last run
  pt_diff_test_param_change <- reactiveVal(FALSE)
  
  # Parameter change
  observe({
    req(input$pt_diff_show_panel)
    if (input$pt_diff_show_panel == "Genomic bin clusters") {
      req(input$pt_diff_n_gbin_clust)
    } else if (input$pt_diff_show_panel == "Gene average accessibility") {
      req(input$pt_diff_gene_maxdist)
    }
    pt_diff_test_param_change(TRUE)
  })
  
  # Render differential analysis results panels
  output$pt_diff_res_panels <- renderUI({
    if ((! is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0)) {
      if (! pt_diff_test_param_change()) {
        isolate({
          tabsetPanel(
            tabPanel("Results",
                     tags$div(
                       style = "margin-top:30px; margin-bottom:30px;", 
                       h4("Differential test results table"),
                       downloadButton("pt_diff_res_download", "Download results table", 
                                      class = "regular-btn"),
                       DT::dataTableOutput("pt_diff_res_table")
                     )),
            tabPanel("Summary",
                     tags$div(
                       style = "margin-top:30px; margin-bottom:30px;", 
                       wellPanel(
                         h4("Significant bins summary"),
                         fluidRow(
                           column(6, sliderInput("pt_diff_alpha", 
                                                 "Level of significance (FDR): ", 
                                                 min = 0.0001, 
                                                 max = 0.5, 
                                                 value = 0.05)), 
                           column(6, uiOutput("pt_diff_res_sig_bed_download_ui"))
                         ),
                         textOutput("pt_diff_sum_text")
                       ),
                       wellPanel(
                         radioButtons("pt_diff_res_hist_val",
                                      "Histogram of: ",
                                      c("p-value", "FDR")),
                         h4("Histogram summary"),
                         plotOutput("pt_diff_sum_hist"), 
                         bsTooltip("pt_diff_sum_hist", 
                                   title = "Histogram of selected value", 
                                   placement = "top", 
                                   options = list(container = "body")),
                         actionButton("pt_diff_sum_hist_download", "Download plot", 
                                      class = "regular-btn")
                       ), 
                       wellPanel(
                         h4("p-value adjustment line plot"),
                         plotOutput("pt_diff_sum_lineplot"), 
                         bsTooltip("pt_diff_sum_lineplot", 
                                   title = "Line plot of sorted p-values for all bins before and after FDR adjustment. Dashed line indicates the selected significance level. ", 
                                   placement = "top", 
                                   options = list(container = "body")), 
                         actionButton("pt_diff_sum_lineplot_download", "Download plot", 
                                      class = "regular-btn")
                       )
                     )), 
            tabPanel("Gene ontology", 
                     tags$div(
                       style = "margin-top:30px; margin-bottom:30px;", 
                       wellPanel(
                         wellPanel(
                           # GO options
                           fluidRow(
                             column(
                               6,
                               radioButtons(
                                 "pt_diff_go_alpha_var", 
                                 "Apply significance level cut-off to: ", 
                                 c("FDR", 
                                   "p-value")
                               )
                             ),
                             column(
                               6, 
                               sliderInput(
                                 "pt_diff_go_alpha", 
                                 "Level of significance: ", 
                                 min = 0.0001, 
                                 max = 1, 
                                 value = 0.05
                               )
                             )
                           ),
                           uiOutput("pt_diff_go_sel_gbin_clusts_ui"), 
                           uiOutput("pt_diff_go_gene_maxdist_ui"), 
                           textOutput("pt_diff_go_sig_genes_msg"), 
                           uiOutput("pt_diff_go_external_tool_ui"),
                           bsTooltip("pt_diff_go_external_tool_ui", 
                                     title = "Use and external tool to analyze significant regions/genes in greater detail. ", 
                                     placement = "left", 
                                     options = list(container = "body")),
                           checkboxInput("pt_diff_go_show_sig_bins_table", 
                                         "Show table mapping significant bins to nearest genes"), 
                           uiOutput('pt_diff_go_sig_bins_table_ui')
                         ),
                         radioButtons("pt_diff_go_ctrl", 
                                      "Control gene list: ", 
                                      c("All genes near selected genomic range",
                                        "All genes near BIRD default prediction range")), 
                         bsTooltip("pt_diff_go_ctrl", 
                                   title = "Using only genes near the selected genomic range as control genes is recommended as using all genes will greatly slow down the runtime. ", 
                                   placement = "left", 
                                   options = list(container = "body")),
                         radioButtons("pt_diff_go_ontology", 
                                      "GO ontology: ", 
                                      c("Biological process" = "BP", 
                                        "Molecular function" = "MF", 
                                        "Cellular component" = "CC")), 
                         sliderInput("pt_diff_go_top_n", 
                                     "Number of top GO terms to return: ", 
                                     min = 10, 
                                     max = 500, 
                                     value = 20, 
                                     step = 10), 
                         actionButton("run_pt_diff_go", "Find top GO terms", 
                                      class = "important-btn")
                       ), 
                       textOutput('pt_no_feasible_go_terms_warning'), 
                       uiOutput('pt_diff_go_sel_res_ui')
                     ))
          )
        })
      }
    } else {
      p("Please click on Perform Test to perform differential test on selected groups. ")
    }
  })
  
  # Differential test result table
  output$pt_diff_res_table <- DT::renderDataTable({
    if (! is.null(pt_diff_test_res())) {
      pt_diff_test_res() %>% 
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = "none") %>% 
        formatRound(columns=c('pvalue', "FDR"), digits=4)
    }
  })
  
  # Differential test result download
  output$pt_diff_res_download <- downloadHandler(
    filename = function() { "Differential_accessibility_along_pseudotime.txt" },
    content = function(file) {
      write.table(pt_diff_test_res(),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Significant bins from pseudo time differential test results summary
  pt_diff_sig_bins <- reactive({
    if ((! is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0)) {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        significant_bins <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        sig_clusts <- pt_diff_test_res()$cluster[pt_diff_test_res()$FDR < input$pt_diff_alpha]
        gbin_clusts <- data.frame(cluster = as.factor(pt_diff_gbin_clust_res()$cluster), 
                                  genomic_bin = names(pt_diff_gbin_clust_res()$cluster))
        significant_bins <- gbin_clusts$genomic_bin[gbin_clusts$cluster %in% sig_clusts]
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        significant_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
        topvar_gbin_tss <- gbin_tss()[rownames(pca_top_var_pred_mat()), ]
        topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
        significant_bins <- rownames(topvar_gbin_tss)[topvar_gbin_tss$gene %in% significant_genes]
      }
      significant_bins
    }
  })
  
  # Render diff test significant bins bed download button UI
  output$pt_diff_res_sig_bed_download_ui <- renderUI({
    if (length(pt_diff_sig_bins()) > 0) {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        tagList(
          downloadButton("pt_diff_res_sig_bed_download", "Download significant bins BED file", 
                         class = "regular-btn"), 
          bsTooltip("pt_diff_res_sig_bed_download", 
                    title = "BED file for bins that have significant differential accessibility along pseudo-time. ",
                    placement = "top")
        )
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        tagList(
          downloadButton("pt_diff_res_sig_bed_download", "Download significant clusters BED files", 
                         class = "regular-btn"), 
          bsTooltip("pt_diff_res_sig_bed_download", 
                    title = "zip file of BED files. One BED file for each cluster. All bins in significantly differential clusters are included in the BED file for that cluster. ",
                    placement = "top")
        )
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        tagList(
          downloadButton("pt_diff_res_sig_bed_download", "Download significant bins BED file", 
                         class = "regular-btn"), 
          bsTooltip("pt_diff_res_sig_bed_download", 
                    title = "BED file for all bins with nearest genes that have significant differential accessibility along pseudo-time. ",
                    placement = "top")
        )
      }
    }
  })
  
  # Differential test significant bins BED file download
  output$pt_diff_res_sig_bed_download <- downloadHandler(
    filename = function() {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        return("Pseudotime_significant_bins.bed")
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        return("Pseudotime_significant_clusters.zip")
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        return("Pseudotime_significant_genes.bed")
      }
    }, 
    content = function(file) {
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        significant_bins <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
        write.table(parse_gbin(significant_bins), 
                    file, 
                    col.names = FALSE, 
                    row.names = FALSE, 
                    quote = FALSE, 
                    sep = "\t")
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        # Make zip file
        # Create temp folder to hold prediction files
        tmp <- tempdir()
        tmp_fpaths <- c()
        # Write the appropriate prediction to table
        gbin_clusts <- data.frame(cluster = as.factor(pt_diff_gbin_clust_res()$cluster), 
                                  genomic_bin = names(pt_diff_gbin_clust_res()$cluster))
        for (i in pt_diff_test_res()$cluster[pt_diff_test_res()$FDR < input$pt_diff_alpha]) {
          gbins <- gbin_clusts$genomic_bin[gbin_clusts$cluster == i]
          fname <- paste0("cluster_", i, ".bed")
          write.table(parse_gbin(gbins), 
                      file.path(tmp, fname), 
                      col.names = FALSE, 
                      row.names = FALSE, 
                      quote = FALSE, 
                      sep = "\t")
          tmp_fpaths <- append(tmp_fpaths, file.path(tmp, fname))
        }
        zip(zipfile = file, files = tmp_fpaths, extras = '-j')
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        significant_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
        topvar_gbin_tss <- gbin_tss()[rownames(pca_top_var_pred_mat()), ]
        topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
        write.table(parse_gbin(rownames(topvar_gbin_tss)[topvar_gbin_tss$gene %in% significant_genes]), 
                    file, 
                    col.names = FALSE, 
                    row.names = FALSE, 
                    quote = FALSE, 
                    sep = "\t")
      }
    }
  )
  
  # Render text message for number of significant bins
  output$pt_diff_sum_text <- renderText({
    if (!is.null(pt_diff_test_res())) {
      n_sigbins <- sum(pt_diff_test_res()$FDR < input$pt_diff_alpha)
      pct <- round(mean(pt_diff_test_res()$FDR < input$pt_diff_alpha),digits=4) * 100
      if (input$pt_diff_show_panel == "Individual genomic bins") {
        paste("There are ", n_sigbins, "significant bins, which is", pct, "percent of all selected genomic bins")
      } else if (input$pt_diff_show_panel == "Genomic bin clusters") {
        paste("There are ", n_sigbins, "significant clusters, which is", pct, "percent of all genomic bins clusters")
      } else if (input$pt_diff_show_panel == "Gene average accessibility") {
        paste("There are ", n_sigbins, "significant genes, which is", pct, "percent of all genes near selected genomic bins")
      }
    }
  })
  
  pt_diff_sum_hist <- reactive({
    if (!is.null(pt_diff_test_res())) {
      if (input$pt_diff_res_hist_val == "statistics") {
        g <- ggplot(pt_diff_test_res(), aes(statistics)) + geom_histogram(bins = 30) 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="Statistics", y="Frequency")
        g
      } else if (input$pt_diff_res_hist_val == "FDR") {
        g <- ggplot(pt_diff_test_res(), aes(FDR)) + geom_histogram(bins = 30) 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="FDR", y="Frequency")
        g <- g + geom_vline(xintercept = input$diff_alpha, linetype = "dotted", colour = "blue")
        g
      } else if (input$pt_diff_res_hist_val == "p-value") {
        g <- ggplot(pt_diff_test_res(), aes(pvalue)) + geom_histogram(bins = 30) 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="p-value", y="Frequency")
        g
      }
    }
  })
  
  # Render summary histogram for differential test result
  output$pt_diff_sum_hist <- renderPlot({
    pt_diff_sum_hist()
  })
  
  observeEvent(input$pt_diff_sum_hist_download, {
    download_plot(pt_diff_sum_hist())
  })
  
  pt_diff_sum_lineplot <- reactive({
    g <- ggplot(pt_diff_test_res()[order(pt_diff_test_res()$pvalue), ], aes(1:nrow(pt_diff_test_res())))
    g <- g + geom_line(aes(y=pvalue, color = "red")) + geom_line(aes(y=FDR, color = "blue"))
    g <- g + geom_hline(yintercept = input$pt_diff_alpha, linetype = "dotted", colour = "blue")
    g <- g + theme(panel.background = element_blank())
    g <- g + labs(x="Genomic bins sorted by p-values", y="Values")
    g <- g + scale_colour_manual(name = 'Values', 
                                 values = c('blue'='blue','red'='red'), 
                                 labels = c('FDR','p-value'))
    g
  })
  
  # Render summary line plot for differential test result
  output$pt_diff_sum_lineplot <- renderPlot({
    pt_diff_sum_lineplot()
  })
  
  observeEvent(input$pt_diff_sum_lineplot_download, {
    download_plot(pt_diff_sum_lineplot())
  })
  
  output$pt_diff_go_sel_gbin_clusts_ui <- renderUI({
    req(input$pt_diff_go_alpha)
    req(input$pt_diff_go_alpha_var)
    if ((input$run_pt_diff_test > 0) && (! is.null(pt_diff_test_res()))) {
      isolate({
        if (input$pt_diff_show_panel == "Genomic bin clusters") {
          if (input$pt_diff_go_alpha_var == "FDR") {
            sig_clusts <- pt_diff_test_res()$cluster[pt_diff_test_res()$FDR < input$pt_diff_go_alpha]
          } else if (input$pt_diff_go_alpha_var == "p-value") {
            sig_clusts <- pt_diff_test_res()$cluster[pt_diff_test_res()$pvalue < input$pt_diff_go_alpha]
          }
          selectInput(
            "pt_diff_go_sel_gbin_clusts", 
            "Significant clusters to use for GO enrichment analysis: ",
            choices = sig_clusts, 
            selected = sig_clusts, 
            multiple = TRUE
          )
        }
      })
    }
  })
  
  output$pt_diff_go_gene_maxdist_ui <- renderUI({
    if ((!is.null(pt_diff_test_res())) && (input$run_pt_diff_test > 0)) {
      isolate({
        if(input$pt_diff_show_panel != "Gene average accessibility") {
          tagList(
            fluidRow(
              column(
                width = 8,
                # Select distance limit for mapping bins to nearest genes
                shinyWidgets::sliderTextInput(
                  "pt_diff_go_gene_maxdist", 
                  "Maximum distance limit of bins to nearest gene TSS", 
                  choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
                  post = "bp",
                  selected = 500
                ),
                # sliderInput("pt_diff_go_gene_maxdist", 
                #             "Maximum distance limit of bins to nearest gene TSS",
                #             min = 0, 
                #             max = 1e6, 
                #             value = 500, 
                #             post = "bp",
                #             step = 100),
              ), 
              column(
                width = 4, 
                checkboxInput(
                  "pt_diff_go_show_gene_dist_plot", 
                  "Show distribution of cluster bins distance to genes", 
                  value = FALSE
                )
              )
            ),
            uiOutput("pt_diff_go_gene_dist_plot_ui")
          )
        }
      })
    }
  })
  
  output$pt_diff_go_gene_dist_plot_ui <- renderUI({
    if (input$pt_diff_go_show_gene_dist_plot) {
      tagList(
        plotlyOutput("pt_diff_go_gene_dist_plot"), 
        #actionButton("pt_diff_go_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  # Significant bins from pseudo time differential test results for GO analysis
  pt_diff_go_sig_bins <- reactive({
    if (isolate(input$pt_diff_show_panel) == "Genomic bin clusters") {
      sig_clusts <- input$pt_diff_go_sel_gbin_clusts
      gbin_clusts <- data.frame(cluster = as.factor(pt_diff_gbin_clust_res()$cluster), 
                                genomic_bin = names(pt_diff_gbin_clust_res()$cluster))
      significant_bins <- gbin_clusts$genomic_bin[gbin_clusts$cluster %in% sig_clusts]
    } else if (isolate(input$pt_diff_show_panel) == "Gene average accessibility") {
      pt_diff_go_alpha_var <- gsub("-", "", input$pt_diff_go_alpha_var)
      significant_genes <- pt_diff_test_res()[pt_diff_test_res()[, pt_diff_go_alpha_var] < input$pt_diff_go_alpha, 1]
      topvar_gbin_tss <- gbin_tss()[rownames(pca_top_var_pred_mat()), ]
      topvar_gbin_tss <- topvar_gbin_tss[topvar_gbin_tss$distance <= input$pt_diff_gene_maxdist, ]
      significant_bins <- rownames(topvar_gbin_tss)[topvar_gbin_tss$gene %in% significant_genes]
    } else if (isolate(input$pt_diff_show_panel) == "Individual genomic bins") {
      pt_diff_go_alpha_var <- gsub("-", "", input$pt_diff_go_alpha_var)
      significant_bins <- pt_diff_test_res()[pt_diff_test_res()[, pt_diff_go_alpha_var] < input$pt_diff_go_alpha, 1]
    }
    significant_bins[! is.na(significant_bins)]
  })
  
  pt_diff_go_nearest_genes <- reactive({
    if (isolate(input$pt_diff_show_panel) == "Gene average accessibility") {
      pt_diff_go_alpha_var <- gsub("-", "", input$pt_diff_go_alpha_var)
      nearest_genes <- pt_diff_test_res()[pt_diff_test_res()[, pt_diff_go_alpha_var] < input$pt_diff_go_alpha, 1]
      nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    } else {
      gbin_names <- pt_diff_go_sig_bins()
      sel_gbin_gene <- gbin_tss()[gbin_names, ]
      nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_go_gene_maxdist, ]$gene)
      nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    }
    nearest_genes
  })
  
  pt_diff_go_gene_dist_plot <- reactive({
    gbin_names <- pt_diff_go_sig_bins()
    sel_gbin_gene <- gbin_tss[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$pt_diff_go_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$pt_diff_go_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Significant genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$pt_diff_go_gene_dist_plot <- renderPlotly({pt_diff_go_gene_dist_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_go_gene_dist_plot_download, {
    download_plotly(pt_diff_go_gene_dist_plot())
  })
  
  # Render text message for number of significant bins and nearest genes
  output$pt_diff_go_sig_genes_msg <- renderText({
    req(pt_diff_test_res())
    req(input$pt_diff_go_alpha)
    req(input$pt_diff_go_alpha_var)
    if (input$run_pt_diff_test > 0) {
      if (isolate(input$pt_diff_show_panel) == "Individual genomic bins") {
        req(input$pt_diff_go_gene_maxdist)
        return(paste("There are", 
                     length(pt_diff_go_sig_bins()[! is.na(pt_diff_go_sig_bins())]), 
                     "significant bins, which map to", 
                     length(pt_diff_go_nearest_genes()), 
                     "nearest genes that will be used in GO term enrichment analysis. "))
      } else if (isolate(input$pt_diff_show_panel) == "Genomic bin clusters") {
        req(input$pt_diff_go_gene_maxdist)
        req(input$pt_diff_go_sel_gbin_clusts)
        sig_clusts <- input$pt_diff_go_sel_gbin_clusts
        return(paste("You selected", 
                     length(sig_clusts), 
                     "significant clusters, which contain", 
                     length(pt_diff_go_sig_bins()[! is.na(pt_diff_go_sig_bins())]), 
                     "bins and map to", 
                     length(pt_diff_go_nearest_genes()), 
                     "nearest genes that will be used in GO term enrichment analysis. "))
      } else if (isolate(input$pt_diff_show_panel) == "Gene average accessibility") {
        return(paste("There are", 
                     length(pt_diff_go_nearest_genes()), 
                     "significant genes that will be used in GO term enrichment analysis. "))
      }
    }
  })
  
  output$pt_diff_go_external_tool_ui <- renderUI({
    req(pt_diff_test_res())
    if (isolate(input$pt_diff_show_panel) == "Gene average accessibility") {
      return(fluidRow(column(6, wellPanel(uiOutput("pt_diff_go_ext_gbin_func")))))
    } else {
      return(fluidRow(
        column(6, wellPanel(uiOutput("pt_diff_go_ext_gene_func"))), 
        column(6, wellPanel(uiOutput("pt_diff_go_ext_gbin_func")))
      ))
    }
  })
  
  output$pt_diff_go_ext_gene_func <- renderUI({
    sig_genes <- pt_diff_go_nearest_genes()
    sig_genes <- sig_genes[! is.na(sig_genes)]
    sig_genes_text <- paste(sig_genes, collapse = "\n")
    if (sig_genes_text == "") {
      sig_genes_text <- " "
    }
    tagList(
      h4("Gene set analysis"), 
      actionButton(
        inputId = "pt_diff_enrichr_link", 
        label = "Go to Enrichr", 
        onclick = "window.open('https://maayanlab.cloud/Enrichr/')", 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(),
      rclipButton(
        inputId = "pt_diff_go_sig_genes_clipbtn", 
        label = "Copy significant genes", 
        clipText = sig_genes_text, 
        icon = icon("clipboard"), 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(),
      downloadButton("pt_diff_go_ext_genes_txt_download", "Download significant genes text file", 
                     style = "width: 100%; border: 1px solid white;", 
                     class = "regular-btn")
    )
  })
  
  output$pt_diff_go_ext_gbin_func <- renderUI({
    df <- parse_gbin(pt_diff_go_sig_bins())
    clip_bed <- paste(capture.output(write.table(df, 
                                                 col.names = FALSE, 
                                                 row.names = FALSE, 
                                                 quote = FALSE, 
                                                 sep = "\t")), 
                      collapse = "\n")
    if (clip_bed == "") {
      clip_bed <- " "
    }
    tagList(
      h4("Genomic regions analysis"), 
      actionButton(
        inputId = "pt_diff_great_link", 
        label = "Go to GREAT", 
        onclick = "window.open('https://great.stanford.edu/great/public/html/')", 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(),
      rclipButton(
        inputId = "pt_diff_go_sig_gbins_clipbtn", 
        label = "Copy significant bins BED", 
        clipText = clip_bed, 
        icon = icon("clipboard"),
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(),
      downloadButton("pt_diff_go_ext_bed_download", "Download significant bins BED", 
                     style = "width: 100%; border: 1px solid white;", 
                     class = "regular-btn")
    )
  })
  
  output$pt_diff_go_ext_genes_txt_download <- downloadHandler(
    filename = "Pseudotime_significant_genes.txt", 
    content = function(file) {
      if (isolate(input$pt_diff_show_panel) == "Gene average accessibility") {
        sig_genes <- pt_diff_test_res()[pt_diff_test_res()$FDR < input$pt_diff_alpha, 1]
      } else {
        sig_genes <- unique(gbin_tss()[pt_diff_go_sig_bins(), ]$gene)
      }
      sig_genes <- sig_genes[! is.na(sig_genes)]
      writeLines(sig_genes, file)
    }
  )
  
  output$pt_diff_go_ext_bed_download <- downloadHandler(
    filename = "Pseudotime_significant_bins.bed", 
    content = function(file) {
      write.table(parse_gbin(pt_diff_go_sig_bins()), 
                  file, 
                  col.names = FALSE, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # UI for significant bins table
  output$pt_diff_go_sig_bins_table_ui <- renderUI({
    if ((input$pt_diff_go_show_sig_bins_table) && (length(pt_diff_go_sig_bins()) > 0)) {
      tagList(
        h4("Significant genomic bins and their nearest genes table"),
        downloadButton('pt_diff_go_sig_bins_table_download', "Download significant bins and nearest genes table", 
                       class = "regular-btn"),
        DT::dataTableOutput('pt_diff_go_sig_bins_table')
      )
    }
  })
  
  # Reactive significant bins table
  pt_diff_go_sig_bins_table <- reactive({
    df <- parse_gbin(pt_diff_go_sig_bins())
    sig_gbin_tss <- gbin_tss()[pt_diff_go_sig_bins(), ]
    df$nearest_gene <- as.factor(sig_gbin_tss$gene)
    df$distance_to_gene <- sig_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(sig_gbin_tss$relative_position_to_tss)
    df
  })
  
  # Differential test significant bins and nearest genes file download
  output$pt_diff_go_sig_bins_table_download <- downloadHandler(
    filename = "Significant_differential_bins_genes.txt", 
    content = function(file) {
      write.table(pt_diff_go_sig_bins_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render table showing significant bins and nearest genes
  output$pt_diff_go_sig_bins_table <- DT::renderDataTable(pt_diff_go_sig_bins_table() %>%
                                                            datatable(rownames = FALSE,
                                                                      filter = list(position = 'top', clear = FALSE), 
                                                                      selection = "none", 
                                                                      options = list(scrollX = TRUE)))
  
  # Record whether there is no feasible GO terms found for current submission
  pt_no_feasible_go_terms <- reactiveVal(FALSE)
  
  # Warning message when there is no feasible GO terms found for current submission
  output$pt_no_feasible_go_terms_warning <- renderText({
    if (pt_no_feasible_go_terms()) {
      paste("No enrichment can pe performed - no genes have feasible GO mapping. \nPlease include more genes. ")
    }
  })
  
  # Conditional MLE odds ratio calculation
  cond_or <- function(x) {
    m <- sum(x[, 1L])
    n <- sum(x[, 2L])
    k <- sum(x[1L, ])
    x <- x[1L, 1L]
    lo <- max(0L, k - n)
    hi <- min(k, m)
    
    support <- lo:hi #Interval of definition of Hypergeometric Distribution
    
    logdc <- dhyper(support, m, n, k, log = TRUE) #log of Hypergeometric Probability Function
    
    dnhyper <- function(ncp) {
      d <- logdc + log(ncp) * support
      d <- exp(d - max(d))
      d/sum(d)
    }
    
    mnhyper <- function(ncp) {
      if (ncp == 0) 
        return(lo)
      if (ncp == Inf) 
        return(hi)
      sum(support * dnhyper(ncp))
    }
    
    mle <- function(x) {
      if (x == lo) 
        return(0)
      if (x == hi) 
        return(Inf)
      mu <- mnhyper(1)
      if (mu > x) 
        uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
      else if (mu < x) 
        1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 
                                                  1))$root
      else 1
    }
    
    mle(x)
  }
  
  # Unconditional MLE odds ratio calculation
  uncond_or <- function(x) {
    x[1, 1] * x[2, 2] / (x[1, 2] * x[2, 1])
  }
  
  # Function for finding top Go terms
  gene_GO <- function(target_gene, control_gene, top=20, go_ontology, ...){
    target_gene <- as.character(target_gene)
    control_gene <- as.character(control_gene)
    
    unique_gene <- unique(c(target_gene, control_gene))
    geneList <- rep(0, length(unique_gene))
    names(geneList) <- unique_gene
    geneList[which(target_gene %in% unique_gene)] <- 1
    
    #print(paste0("num target genes: ", length(target_gene), "; num all genes: ", length(unique_gene)))
    
    GOdata <- new("topGOdata",description = "pathway", ontology = go_ontology,
                  allGenes = geneList, geneSelectionFun = function(x) {x == 1},
                  nodeSize = 10, annotationFun = annFUN.org, mapping = 'org.Hs.eg.db', ID = 'symbol')
    
    gene.universe <- genes(GOdata)
    sig.genes <- sigGenes(GOdata)
    if (length(usedGO(GOdata)) == 0) {
      # No feasible GO terms
      return(NULL)
    }
    res <- sapply(usedGO(GOdata), function(goID) {
      go.genes <- genesInTerm(GOdata, goID)[[1]]
      my.group <- new("classicCount", 
                      testStatistic = GOFisherTest, 
                      name = "fisher",
                      allMembers = gene.universe, 
                      groupMembers = go.genes,
                      sigMembers = sig.genes)
      fisher_res <- fisher.test(contTable(my.group), alternative = "greater")
      c(fisher_res$p.value, fisher_res$estimate, uncond_or(contTable(my.group)), uncond_or(contTable(my.group) + 1))
    })
    if (length(usedGO(GOdata)) == 1) {
      res <- data.frame(res)
    } else {
      res <- data.frame(t(res))
    }
    colnames(res) <- c('p.value', 'cond.odds.ratio', 'uncond.odds.ratio', 'pc.uncond.odds.ratio')
    
    pval <- res$p.value
    names(pval) <- row.names(res)
    GOtest <- new("topGOresult", description = 'BP', score = pval, testName = 'fisher', algorithm = 'classic')
    resultTable <- GenTable(GOdata,
                            pvalue = GOtest,
                            topNodes = min(top, length(usedGO(GOdata))),
                            ranksOf = 'pvalue',
                            numChar = 1024)
    
    pval_adj <- p.adjust(pval, method="BH")
    resultTable$FDR <- pval_adj[resultTable$GO.ID]
    
    resultTable$odds_ratio_conditional <- res[resultTable$GO.ID, 'cond.odds.ratio']
    resultTable$odds_ratio_unconditional <- res[resultTable$GO.ID, 'uncond.odds.ratio']
    resultTable$odds_ratio_pseudo <- res[resultTable$GO.ID, 'pc.uncond.odds.ratio']
    
    GO_gene_all <- genesInTerm(GOdata, resultTable[,1])
    GO_gene_sign <- sapply(GO_gene_all, function(x){
      tmp <- x[x %in% target_gene]
      paste(tmp, collapse=",")
    })
    
    resultTable$gene <- GO_gene_sign
    resultTable$pvalue <- as.numeric(resultTable$pvalue)
    return(resultTable)
  }
  
  # Find top GO terms associated with genes near significant differential bins
  pt_diff_top_go_terms <- reactive({
    if ((! is.null(input$run_pt_diff_go)) && (input$run_pt_diff_go > 0)) {
      isolate({
        showModal(modalDialog("Finding top GO terms...", footer = NULL, easyClose = TRUE, size = "s"))
        sig_genes <- pt_diff_go_nearest_genes()
        ctrl_genes <- NULL
        if (input$pt_diff_go_ctrl == "All genes near BIRD default prediction range") {
          ctrl_genes <- unique(gbin_tss()$gene)
        } else if (input$pt_diff_go_ctrl == "All genes near selected genomic range") {
          ctrl_genes <- unique(gbin_tss()[rownames(pred_mat()), ]$gene)
        }
        ctrl_genes <- ctrl_genes[! is.na(ctrl_genes)]
        top_go_table <- gene_GO(sig_genes, ctrl_genes, 
                                top = input$pt_diff_go_top_n, 
                                go_ontology = input$pt_diff_go_ontology)
        if (is.null(top_go_table)) {
          pt_no_feasible_go_terms(TRUE)
        } else {
          pt_no_feasible_go_terms(FALSE)
        }
        removeModal()
        return(top_go_table)
      })
    }
  })
  
  # Render UI for selecting differential analysis results to display
  output$pt_diff_go_sel_res_ui <- renderUI({
    if (! is.null(pt_diff_top_go_terms())) {
      tagList(
        selectInput(
          'pt_diff_go_sel_res',
          'Select GO result to show: ',
          c('Top GO terms table',
            'GO terms p-value graph',
            'GO terms FDR graph',
            'Volcano plot',
            'GO terms bar plot', 
            'GO terms accessibility along pseudo-time')
        ),
        uiOutput('pt_diff_go_res_ui')
      )
    }
  })
  
  # Render Ui for displaying GO analysis results
  output$pt_diff_go_res_ui <- renderUI({
    if (input$pt_diff_go_sel_res == 'Top GO terms table') {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Top GO terms table")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_table_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_table_info",
          title = "<h4>Top GO terms table</h4>",
          content = do.call(paste0,
                            popover_contents()$go_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        br(),
        downloadButton('pt_diff_go_table_download', "Download top GO terms table", 
                       class = "regular-btn"),
        DT::dataTableOutput("pt_diff_go_table")
      )
    } else if (input$pt_diff_go_sel_res == 'GO terms p-value graph') {
      tagList(
        sliderInput(
          'pt_diff_go_pval_graph_alpha',
          'Significance level',
          min = 0.0001,
          max = 1,
          value = 0.05
        ),
        # bsTooltip("pt_diff_go_pval_graph_alpha",
        #           title = "Control position of p-value threshold (dashed line)",
        #           placement = "top",
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms p-value graph")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_pval_graph_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_pval_graph_info",
          title = "<h4>GO terms p-value graph</h4>",
          content = do.call(paste0,
                            popover_contents()$go_pval_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotlyOutput('pt_diff_go_pval_graph'),
        bsTooltip("pt_diff_go_pval_graph",
                  title = "Graph of -log<sub>10</sub>p-values vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ",
                  placement = "top",
                  options = list(container = "body")),
        #actionButton("pt_diff_go_pval_graph_download", "Download plot"),
        hr(),
        h4("GO terms p-value graph selected points"),
        uiOutput("pt_diff_go_pval_graph_brush_msg"),
        DT::dataTableOutput('pt_diff_go_pval_graph_brushed')
      )
    } else if (input$pt_diff_go_sel_res == 'GO terms FDR graph') {
      tagList(
        sliderInput(
          'pt_diff_go_fdr_graph_alpha',
          'Significance level',
          min = 0.0001,
          max = 1,
          value = 0.05
        ),
        # bsTooltip("pt_diff_go_fdr_graph_alpha",
        #           title = "Control position of FDR threshold (dashed line)",
        #           placement = "top",
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms FDR graph")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_fdr_graph_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_fdr_graph_info",
          title = "<h4>GO terms FDR graph</h4>",
          content = do.call(paste0,
                            popover_contents()$go_fdr_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotlyOutput('pt_diff_go_fdr_graph'),
        bsTooltip("pt_diff_go_fdr_graph",
                  title = "Graph of -log<sub>10</sub>FDR vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ",
                  placement = "top",
                  options = list(container = "body")),
        #actionButton("pt_diff_go_fdr_graph_download", "Download plot"),
        hr(),
        h4("GO terms FDR graph selected points"),
        uiOutput("pt_diff_go_fdr_graph_brush_msg"),
        DT::dataTableOutput('pt_diff_go_fdr_graph_brushed')
      )
    } else if (input$pt_diff_go_sel_res == 'Volcano plot') {
      max_odds_ratio <- max(pt_diff_top_go_terms_df()$odds_ratio_pseudo[is.finite(pt_diff_top_go_terms_df()$odds_ratio_pseudo)])
      tagList(
        tags$div(
          id = "pt_diff_go_volcano_plot_params",
          fluidRow(
            column(6,
                   sliderInput(
                     'pt_diff_go_volcano_plot_alpha',
                     'Significance level',
                     min = 0.0001,
                     max = 1,
                     value = 0.05
                   )),
            column(6,
                   sliderInput(
                     'pt_diff_go_volcano_plot_or_threshold',
                     'Odds ratio threshold',
                     min = 0,
                     max = max_odds_ratio,
                     value = min(1, max_odds_ratio)
                   ))
          )
        ),
        # bsTooltip("pt_diff_go_volcano_plot_params",
        #           title = "Adjust these cut-offs to color significant vs. non-significant GO terms differently in volcano plot. ",
        #           placement = "top",
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms volcano plot")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "go_volcano_plot_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_volcano_plot_info",
          title = "<h4>GO terms volcano plot</h4>",
          content = do.call(paste0,
                            popover_contents()$go_volcano_plot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotlyOutput('pt_diff_go_volcano_plot'),
        bsTooltip("pt_diff_go_volcano_plot",
                  title = "For each GO term, -log<sub>10</sub>p-value is plotted against odds ratio (computed with pseudo-count). ",
                  placement = "top",
                  options = list(container = "body")), 
        #actionButton("pt_diff_go_volcano_plot_download", "Download plot")
      )
    } else if (input$pt_diff_go_sel_res == 'GO terms bar plot') {
      tagList(
        radioButtons(
          "pt_diff_go_barplot_var",
          "Bar plot value: ",
          choices = c("- log10 p-value" = "p-value",
                      "- log10 FDR" = "FDR")
        ),
        fluidRow(
          column(
            width = 4,
            radioButtons(
              "pt_diff_go_barplot_sort_by",
              label = "Sort bar plot by: ",
              choices = c("Default order" = "default",
                          "Decreasing value" = "decrease",
                          "Increasing value" = "increase",
                          "Custom order" = "custom")
            )
          ),
          column(
            width = 8,
            uiOutput("pt_diff_go_barplot_sort_details_ui")
          )
        ),
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "pt_diff_go_barplot_top_cut", 
              "Number of top GO terms to show: ", 
              min = 2, 
              max = nrow(pt_diff_top_go_terms()), 
              value = min(10, nrow(pt_diff_top_go_terms())), 
              step = 1
            )
          ), 
          column(
            width = 4, 
            sliderInput(
              "pt_diff_go_barplot_bar_width", 
              "Bar width: ", 
              min = 0.1, 
              max = 1.0, 
              value = 0.5,
              step = 0.1
            )
          ),
          column(
            width = 4, 
            uiOutput("pt_diff_go_barplot_xlim_ui")
          )
        ),
        checkboxInput(
          "pt_diff_go_barplot_show_des", 
          "Show GO term descriptions", 
          value = FALSE
        ),
        uiOutput("pt_diff_go_barplot_des_details_ui"),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms bar plot")),
        div(style = "display: inline-block;vertical-align: middle;",
            bsButton(
              "pt_go_barplot_info",
              label = "",
              icon = icon("info"),
              style = "info",
              size = "extra-small"
            )),
        bsPopover(
          id = "go_barplot_info",
          title = "<h4>GO terms bar plot</h4>",
          content = do.call(paste0,
                            popover_contents()$go_barplot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        plotOutput("pt_diff_go_barplot"), 
        actionButton("pt_diff_go_barplot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$pt_diff_go_sel_res == "GO terms accessibility along pseudo-time") {
      go_list <- pt_diff_top_go_terms()$GO.ID
      names(go_list) <- paste0(pt_diff_top_go_terms()$GO.ID, ' (', pt_diff_top_go_terms()$Term, ')')
      tagList(
        wellPanel(
          fluidRow(
            column(
              6, 
              radioButtons(
                "pt_diff_go_all_chracc_color", 
                "Color trend lines by: ", 
                choices = c("FDR cut-off", 
                            "p-value cut-off", 
                            "FDR", 
                            "p-value")
                # choices = c("GO terms", 
                #             "p-value", 
                #             "FDR", 
                #             "p-value cut-off", 
                #             "FDR cut-off")
              )
            ), 
            column(
              6, 
              uiOutput("pt_diff_go_all_chracc_alpha_ui")
            )
          ),
          h4("GO terms average chromatin accessibility trends"), 
          plotlyOutput("pt_diff_go_all_chracc_plot"), 
          bsTooltip("pt_diff_go_all_chracc_plot",
                    title = "Each line is the trend of average chromatin accessibility along pseudo-time for a GO term. ",
                    placement = "top",
                    options = list(container = "body")), 
          #actionButton("pt_diff_go_all_chracc_plot_download", "Download plot")
        ),
        wellPanel(
          fluidRow(
            column(
              4, 
              selectInput(
                "pt_diff_go_chracc_term", 
                "Select a GO term to show", 
                choices = go_list
              )
            ), 
            column(
              4, 
              radioButtons(
                "pt_diff_go_chracc_plot", 
                "Show plot: ", 
                choices = c("Scatter plot with overall trend",
                            "Trend lines")
              )
            ),
            column(
              4, 
              uiOutput("pt_diff_go_chracc_plot_trends_options")
            )
          ), 
          uiOutput("pt_diff_go_chracc_overview_ui")
        )
      )
    }
  })
  
  observeEvent(input$pt_diff_go_barplot_download, {
    download_plot(pt_diff_go_barplot())
  })
  
  # Render UI for top terms accessibility along pseudo-time plot alpha slider
  output$pt_diff_go_all_chracc_alpha_ui <- renderUI({
    if (input$pt_diff_go_all_chracc_color %in% c("p-value cut-off", "FDR cut-off")) {
      tooltip_text <- paste("This is the", input$pt_diff_go_all_chracc_color, "for significance. ")
      tagList(
        sliderInput(
          "pt_diff_go_all_chracc_alpha", 
          "Significance level cut-off: ", 
          min = 0, 
          max = 1, 
          value = 0.05
        ), 
        bsTooltip("pt_diff_go_all_chracc_alpha",
                  title = tooltip_text,
                  placement = "top",
                  options = list(container = "body"))
      )
    }
  })
  
  pt_diff_go_all_chracc_plot <- reactive({
    if (input$run_pt_diff_go) {
      fit_vals <- apply(pt_diff_top_go_terms(), 1, function(x) {
        genes <- unlist(strsplit(x["gene"], ","))
        gbin_genes <- pt_diff_go_sig_bins_table()[(pt_diff_go_sig_bins_table()$nearest_gene %in% genes) & 
                                                    (pt_diff_go_sig_bins_table()$distance_to_gene <= input$pt_diff_go_gene_maxdist), , drop=F]
        gbins <- paste0(gbin_genes$chromosome, ' (', gbin_genes$start, '-', gbin_genes$end, ')')
        go_avg_chracc <- colMeans(pca_top_var_pred_mat()[gbins, pred_order()[,1], drop=F])
        data <- data.frame(pseudotime = 1:length(go_avg_chracc), 
                           chracc = go_avg_chracc)
        fitted.values(mgcv::gam(chracc ~ s(pseudotime, k = 3), data = data))
      })
      fit_df <- data.frame(pseudotime = 1:nrow(fit_vals), 
                           as.data.frame(fit_vals))
      colnames(fit_df)[-1] <- pt_diff_top_go_terms()$GO.ID
      fit_long <- melt(fit_df, id = "pseudotime")
      if (input$pt_diff_go_all_chracc_color == "GO terms") {
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = variable, text = variable)) + geom_line()
        g$labels$colour <- "GO term ID"
      } else if (input$pt_diff_go_all_chracc_color == "p-value") {
        go_pval <- pt_diff_top_go_terms()[, c("GO.ID", "pvalue")]
        fit_long <- merge(fit_long, go_pval, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = pvalue, text = paste0(variable, '\np-value: ', pvalue))) + geom_line()
        g <- g + scale_color_gradient(low = "darkred", high = "grey")
        g$labels$colour <- "p-value"
      } else if (input$pt_diff_go_all_chracc_color == "FDR") {
        go_fdr <- pt_diff_top_go_terms()[, c("GO.ID", "FDR")]
        fit_long <- merge(fit_long, go_fdr, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = FDR, text = paste0(variable, '\nFDR: ', FDR))) + geom_line()
        g <- g + scale_color_gradient(low = "darkred", high = "grey")
        g$labels$colour <- "FDR"
      } else if (input$pt_diff_go_all_chracc_color == "p-value cut-off") {
        go_pval <- pt_diff_top_go_terms()[, c("GO.ID", "pvalue")]
        significance <- rep("Non-significant", nrow(go_pval))
        significance[go_pval$pvalue < input$pt_diff_go_all_chracc_alpha] <- "Significant"
        go_pval$significance <- as.factor(significance)
        fit_long <- merge(fit_long, go_pval, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = significance, text = paste0(variable, '\np-value: ', pvalue))) + geom_line()
        g <- g + scale_color_manual(values = c('Significant' = "darkred", 'Non-significant' = "grey"))
        g$labels$colour <- "Significance"
      } else if (input$pt_diff_go_all_chracc_color == "FDR cut-off") {
        go_fdr <- pt_diff_top_go_terms()[, c("GO.ID", "FDR")]
        significance <- rep("Non-significant", nrow(go_fdr))
        significance[go_fdr$FDR < input$pt_diff_go_all_chracc_alpha] <- "Significant"
        go_fdr$significance <- significance
        fit_long <- merge(fit_long, go_fdr, by.x="variable", by.y="GO.ID", all.x=TRUE)
        g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = significance, text = paste0(variable, '\nFDR: ', FDR))) + geom_line()
        g <- g + scale_color_manual(values = c('Significant' = "darkred", 'Non-significant' = "grey"))
        g$labels$colour <- "Significance"
      } 
      g <- g + ylab("Average predicted log2 chromatin accessibility") + xlab("Pseudotime")
      g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
        theme(panel.border = element_blank(), axis.line = element_line()) + 
        theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
        theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
        theme(panel.background = element_rect(fill = "white"))
      p <- ggplotly(g, tooltip = 'text')
      p
    }
  })
  
  # Render plot of top terms accessibility along pseudo-time
  output$pt_diff_go_all_chracc_plot <- renderPlotly({pt_diff_go_all_chracc_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_go_all_chracc_plot_download, {
    download_plotly(pt_diff_go_all_chracc_plot())
  })
  
  # Render options for overview plot
  output$pt_diff_go_chracc_plot_trends_options <- renderUI({
    if (input$pt_diff_go_chracc_plot == "Trend lines") {
      radioButtons(
        "pt_diff_go_chracc_form", 
        "Show chromatin accessibility for: ", 
        choices = c("Gene average", "Individual bins")
      )
    }
  })
  
  # Render UI for GO term accessibility along pseudo-time overview
  output$pt_diff_go_chracc_overview_ui <- renderUI({
    if (input$pt_diff_go_chracc_plot == "Trend lines") {
      req(input$pt_diff_go_chracc_form)
      header_text <- paste(input$pt_diff_go_chracc_form, 
                           "chromatin accessibility along pseudo-time overview for", 
                           input$pt_diff_go_chracc_term)
      if (input$pt_diff_go_chracc_form == "Gene average") {
        tooltip_text <- "Each line is the fitted trend for the average predicted accessibility along pseudo-time for a significant gene. "
      } else if (input$pt_diff_go_chracc_form == "Individual bins") {
        tooltip_text <- "Each line is the fitted trend for the predicted accessibility along pseudo-time for a bin near significant genes. "
      }
    } else {
      header_text <- "GO term average accessibility along pseudo-time scatter plot"
      tooltip_text <- "Each point is the average predicted accessibility across all genomic bins near significant genes. "
    }
    tagList(
      h4(header_text),
      plotlyOutput("pt_diff_go_chracc_overview_plot"),
      bsTooltip("pt_diff_go_chracc_overview_plot",
                title = tooltip_text,
                placement = "top",
                options = list(container = "body")), 
      #actionButton("pt_diff_go_chracc_overview_plot_download", "Download plot")
    )
  })
  
  # Table of significant bins and genes for selected GO term
  pt_diff_go_chracc_sel_genes_table <- reactive({
    genes <- pt_diff_top_go_terms()$gene[pt_diff_top_go_terms()$GO.ID == input$pt_diff_go_chracc_term]
    genes <- unlist(strsplit(genes, ','))
    pt_diff_go_sig_bins_table()[(pt_diff_go_sig_bins_table()$nearest_gene %in% genes) &
                                  (pt_diff_go_sig_bins_table()$distance_to_gene <= input$pt_diff_go_gene_maxdist), , drop=F]
  })
  
  pt_diff_go_chracc_overview_plot <- reactive({
    go_sig_bins <- paste0(pt_diff_go_chracc_sel_genes_table()$chromosome, 
                          ' (', 
                          pt_diff_go_chracc_sel_genes_table()$start, 
                          '-',
                          pt_diff_go_chracc_sel_genes_table()$end, 
                          ')')
    go_sig_pred_mat <- pca_top_var_pred_mat()[go_sig_bins,]
    if (input$pt_diff_go_chracc_plot == "Trend lines") {
      if (input$pt_diff_go_chracc_form == "Gene average") {
        chracc <- aggregate(go_sig_pred_mat, 
                            by=list(gene=pt_diff_go_chracc_sel_genes_table()$nearest_gene), 
                            mean)
        rownames(chracc) <- chracc$gene
        chracc <- chracc[, pred_order()[, 1]]
      } else if (input$pt_diff_go_chracc_form == "Individual bins") {
        chracc <- go_sig_pred_mat[, pred_order()[, 1]]
      }
      pseudotime <- 1:ncol(chracc)
      fit_vals <- apply(chracc, 1, function(x) {
        data <- data.frame(pseudotime = pseudotime, 
                           chracc = x)
        fitted.values(mgcv::gam(chracc ~ s(pseudotime, k = 3), data = data))
      })
      fit_df <- data.frame(pseudotime = pseudotime, 
                           as.data.frame(fit_vals))
      if (input$pt_diff_go_chracc_form == "Individual bins") {
        colnames(fit_df)[-1] <- go_sig_bins
      }
      fit_long <- melt(fit_df, id = "pseudotime")
      g <- ggplot(fit_long, aes(x = pseudotime, y = value, color = variable, text = variable)) + geom_line()
      if (input$pt_diff_go_chracc_form == "Gene average") {
        g$labels$colour <- "Gene"
      } else {
        g$labels$colour <- "Genomic bin"
      }
      g <- g + ylab("Predicted log2 chromatin accessibility") + xlab("Pseudotime")
      g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
        theme(panel.border = element_blank(), axis.line = element_line()) + 
        theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
        theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
        theme(panel.background = element_rect(fill = "white"))
      p <- ggplotly(g, tooltip = 'text')
      return(p)
    } else {
      ggplotly(chracc_along_pt_plot(colMeans(go_sig_pred_mat), pred_order()))
    }
  })
  
  # Render overview plot for GO term accessibility along pseudotime
  output$pt_diff_go_chracc_overview_plot <- renderPlotly({pt_diff_go_chracc_overview_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_go_chracc_overview_plot_download, {
    download_plotly(pt_diff_go_chracc_overview_plot())
  })
  
  # Render UI for bar plot xlim
  output$pt_diff_go_barplot_xlim_ui <- renderUI({
    req(input$pt_diff_go_barplot_var)
    req(input$pt_diff_go_barplot_sort_by)
    req(input$pt_diff_go_barplot_top_cut)
    # Set bar values
    if (input$pt_diff_go_barplot_var == "p-value") {
      value <- - log10(pt_diff_top_go_terms()$pvalue)
    } else if (input$pt_diff_go_barplot_var == "FDR") {
      value <- - log10(pt_diff_top_go_terms()$FDR)
    }
    sliderInput(
      "pt_diff_go_barplot_xlim", 
      "Minimum x value: ", 
      min = 0, 
      max = min(value), 
      value = min(value) - (max(value) - min(value)) / 3
    )
  })
  
  # Render UI for bar plot show description details
  output$pt_diff_go_barplot_des_details_ui <- renderUI({
    if (input$pt_diff_go_barplot_show_des) {
      wellPanel(
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "pt_diff_go_barplot_show_des_size", 
              "GO term description font size", 
              min = 1, 
              max = 10, 
              value = 4
            )
          ),
          column(
            width = 4, 
            radioButtons(
              "pt_diff_go_barplot_show_des_opt", 
              "GO description display options", 
              choices = c("Show full description", 
                          "Show truncated description", 
                          "Split description into multiple lines")
            )
          ), 
          column(
            width = 4, 
            uiOutput("pt_diff_go_barplot_show_des_opt_format")
          )
        )
      )
    }
  })
  
  # Render UI for bar plot GO description formatting options
  output$pt_diff_go_barplot_show_des_opt_format <- renderUI({
    if (input$pt_diff_go_barplot_show_des_opt == "Show truncated description") {
      tagList(
        radioButtons(
          "pt_diff_go_barplot_des_trim_mode", 
          "Truncation mode: ", 
          choices = c("Fixed length", "Proportional to bar length"), 
          selected = "Fixed length"
        ), 
        sliderInput(
          "pt_diff_go_barplot_des_trim_len", 
          "Truncation length: ", 
          min = 0, max = 1, value = 0.8, step = 0.01
        )
      )
    } else if (input$pt_diff_go_barplot_show_des_opt == "Split description into multiple lines") {
      tagList(
        radioButtons(
          "pt_diff_go_barplot_des_split_mode", 
          "Split mode: ", 
          choices = c("Fixed line length", "Line length proportional to bar length"),
          selected = "Fixed line length"
        ), 
        sliderInput(
          "pt_diff_go_barplot_des_split_len", 
          "Line length: ", 
          min = 0, max = 1, value = 0.5, step = 0.01
        )
      )
    }
  })
  
  # Render UI for bar plot sort details
  output$pt_diff_go_barplot_sort_details_ui <- renderUI({
    if (input$pt_diff_go_barplot_sort_by == "custom") {
      fluidRow(
        column(
          width = 6,
          radioButtons(
            "pt_diff_go_barplot_custom_sort_method",
            "Input custom order by: ",
            choices = c("Text input",
                        "Drag to sort")
          )
        ),
        column(
          width = 6,
          uiOutput("pt_diff_go_barplot_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for GO bar plot custom sorting options
  output$pt_diff_go_barplot_custom_sort_ui <- renderUI({
    if (input$pt_diff_go_barplot_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "pt_diff_go_barplot_custom_sort_text",
          "Input GO IDs separated by line breaks: "
        ),
        fileInput(
          "pt_diff_go_barplot_custom_sort_txt_file",
          "Upload txt file indicating sort order",
          accept = "text/plain"
        ),
        actionButton("pt_submit_diff_go_barplot_custom_sort", "Confirm order", 
                     class = "regular-btn"),
        textOutput("pt_diff_go_barplot_custom_sort_submission_text")
      )
    } else if (input$pt_diff_go_barplot_custom_sort_method == "Drag to sort") {
      actionButton("pt_diff_go_barplot_custom_sort_drag_button", "Sort samples", 
                   class = "regular-btn")
    }
  })
  
  # Update GO bar plot custom sort text area input value based on uploaded file
  observeEvent(input$pt_diff_go_barplot_custom_sort_txt_file, {
    if (! is.null(input$pt_diff_go_barplot_custom_sort_txt_file)) {
      go_sort_text <- paste(readLines(input$pt_diff_go_barplot_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session,
        "pt_diff_go_barplot_custom_sort_text",
        value = go_sort_text
      )
    }
  })
  
  # Disease bar plot custom order value
  pt_diff_go_barplot_custom_order <- reactiveVal()
  
  # Update default custom order when GO results are computed
  observeEvent(pt_diff_top_go_terms(), {
    pt_diff_go_barplot_custom_order(pt_diff_top_go_terms()$GO.ID)
  })
  
  # Render pop-up modal for GO bar plot custom drag sort
  observeEvent(input$pt_diff_go_barplot_custom_sort_drag_button, {
    if (is.null(pt_diff_go_barplot_custom_order())) {
      go_order <- pt_diff_top_go_terms()$GO.ID
    } else {
      go_order <- pt_diff_go_barplot_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = go_order,
      input_id = "go_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("pt_submit_diff_go_barplot_custom_sort", "Confirm order", 
                     class = "regular-btn"),
        textOutput("pt_diff_go_barplot_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for GO bar plot custom sort
  output$pt_diff_go_barplot_custom_sort_submission_text <- renderText({
    pt_diff_go_barplot_custom_sort_submission_text()
  })
  
  # Process GO bar plot custom sort request
  pt_diff_go_barplot_custom_sort_submission_text <- eventReactive(input$pt_submit_diff_go_barplot_custom_sort, {
    if (input$pt_diff_go_barplot_custom_sort_method == "Text input") {
      # Read GO terms from submitted text
      go_terms <- unlist(strsplit(input$pt_diff_go_barplot_custom_sort_text, split = "\n"))
      go_terms <- sapply(go_terms, function(go) {
        go <- gsub(" ", "", go)
        go <- gsub("\t", "", go)
        go
      })
      go <- go[go != ""]
      # Check for non-selected GO terms
      extra <- go_terms[! (go_terms %in% pt_diff_top_go_terms()$GO.ID)]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected GO terms:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated GO terms
      counts <- sapply(pt_diff_top_go_terms()$GO.ID, function(go) {
        sum(go_terms %in% go)
      })
      if (any(counts > 1)) {
        return(paste("The following GO terms are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing GO terms
      if (any(counts == 0)) {
        return(paste("The following GO terms are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      pt_diff_go_barplot_custom_order(go_terms)
      return(paste("Sorting complete!"))
    } else if (input$pt_diff_go_barplot_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      pt_diff_go_barplot_custom_order(input$go_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  pt_diff_go_barplot <- reactive({
    req(input$pt_diff_go_barplot_xlim)
    # Set bar values
    if (input$pt_diff_go_barplot_var == "p-value") {
      df <- data.frame(go_term = pt_diff_top_go_terms()$GO.ID, 
                       go_des =  pt_diff_top_go_terms()$Term, 
                       value = - log10(pt_diff_top_go_terms()$pvalue))
    } else if (input$pt_diff_go_barplot_var == "FDR") {
      df <- data.frame(go_term = pt_diff_top_go_terms()$GO.ID, 
                       go_des =  pt_diff_top_go_terms()$Term, 
                       value = - log10(pt_diff_top_go_terms()$FDR))
    }
    # Sort barplot
    if (input$pt_diff_go_barplot_sort_by == "decrease") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value)])
    } else if (input$pt_diff_go_barplot_sort_by == "increase") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value, decreasing = TRUE)])
    } else if (input$pt_diff_go_barplot_sort_by == "custom") {
      df$go_term <- factor(df$go_term, levels = rev(pt_diff_go_barplot_custom_order()))
    }
    # Top n bars cut-off
    df <- df[1:input$pt_diff_go_barplot_top_cut, ]
    if (input$pt_diff_go_barplot_show_des) {
      req(input$pt_diff_go_barplot_show_des_opt)
      # Show GO descriptions
      # Get description lengths
      des_width <- sapply(df$go_des, function(des){
        strwidth(des, units = "inches", family = "sans")
      })
      if (input$pt_diff_go_barplot_show_des_opt == "Show truncated description") {
        req(input$pt_diff_go_barplot_des_trim_mode)
        req(input$pt_diff_go_barplot_des_trim_len)
        abbrev_len <- strwidth("...", units = "inches", family = "sans")
        if (input$pt_diff_go_barplot_des_trim_mode == "Fixed length") {
          trim_len <- rep(abbrev_len + input$pt_diff_go_barplot_des_trim_len * (max(des_width) - abbrev_len), length(des_width))
          names(trim_len) <- df$go_des
        } else {
          bar_len <- df$value - input$pt_diff_go_barplot_xlim
          max_len <- abbrev_len + input$pt_diff_go_barplot_des_trim_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - abbrev_len)
          trim_len <- max_len * bar_len / (max(df$value) - input$pt_diff_go_barplot_xlim)
          names(trim_len) <- df$go_des
        }
        # Trim terms
        trim_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= trim_len[term]) {
            return(term)
          } else {
            # Find approximate nchar to trim
            keep_nchar <- floor(nchar(term) * (trim_len[term] - abbrev_len) / des_width[term])
            while (strwidth(substring(term, 1, keep_nchar), units = "inches", family = "sans") > trim_len[term] - abbrev_len) {
              keep_nchar <- keep_nchar - 1
            }
            return(paste0(substring(term, 1, keep_nchar), "..."))
          }
        })
        df$go_des <- trim_terms
      } else if (input$pt_diff_go_barplot_show_des_opt == "Split description into multiple lines") {
        req(input$pt_diff_go_barplot_des_split_mode)
        req(input$pt_diff_go_barplot_des_split_len)
        if (input$pt_diff_go_barplot_des_split_mode == "Fixed line length") {
          min_len <- max(des_width) / 2
          line_len <- rep(min_len + input$pt_diff_go_barplot_des_split_len * (max(des_width) - min_len), length(des_width))
          names(line_len) <- df$go_des
        } else {
          bar_len <- df$value - input$pt_diff_go_barplot_xlim
          min_len <- max(des_width) / 2
          max_len <- min_len + input$pt_diff_go_barplot_des_split_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - min_len)
          line_len <- sapply(df$go_des, function(term) {
            ratio <- bar_len[df$go_des == term] / (max(df$value) - input$pt_diff_go_barplot_xlim)
            if ((max(df$value) - input$pt_diff_go_barplot_xlim) == 0) {
              ratio <- 1
            }
            max_len * ratio
          })
          names(line_len) <- df$go_des
        }
        # Format terms
        format_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= line_len[term]) {
            return(term)
          } else {
            # Find approximate nchar in a single line
            remain_term <- term
            split_lines <- c()
            line_nchar <- floor(nchar(term) * line_len[term] / des_width[term])
            while (strwidth(remain_term, units = "inches", family = "sans") > line_len[term] &&
                   ! -1 %in% unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))) {
              breaks <- unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))
              breaks <- breaks[!(breaks + 1) %in% breaks]
              break_i <- if (length(breaks) && min(breaks) <= line_nchar) {
                which.max(breaks[breaks <= line_nchar])
              } else {1}
              while (strwidth(trimws(substring(remain_term, 1, breaks[break_i])), 
                              units = "inches", family = "sans") > line_len[term] &&
                     break_i > 1) {
                break_i <- break_i - 1
              }
              split_lines <- c(split_lines, trimws(substring(remain_term, 1, breaks[break_i])))
              remain_term <- trimws(substring(remain_term, breaks[break_i] + 1, ))
            }
            split_lines <- c(split_lines, remain_term)
            return(paste(split_lines, collapse = "\n"))
          }
        })
        df$go_des <- format_terms
      }
    }
    g <- ggplot(df, aes(x = go_term, y = value, fill = value))
    g <- g + xlab("GO terms")
    if (input$pt_diff_go_barplot_var == "p-value") {
      g <- g + ylab('- log10 p-value')
      g <- g + labs(fill = '- log10 p-value')
    } else if (input$pt_diff_go_barplot_var == "FDR") {
      g <- g + ylab('- log10 FDR')
      g <- g + labs(fill = '- log10 FDR')
    }
    g <- g + geom_bar(stat = 'identity', width = input$pt_diff_go_barplot_bar_width) + theme_bw()
    g <- g + coord_flip(ylim = c(input$pt_diff_go_barplot_xlim, max(df$value)))
    if (input$pt_diff_go_barplot_show_des) {
      g <- g + geom_text(aes(x = go_term, y = input$pt_diff_go_barplot_xlim,
                             label = go_des, hjust = "left"),
                         color = "white", lineheight = 0.7,
                         size = input$pt_diff_go_barplot_show_des_size)
    }
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    return(g)
  })
  
  # Render GO bar plot
  output$pt_diff_go_barplot <- renderPlot({
    pt_diff_go_barplot()
  })
  
  observeEvent(input$pt_diff_go_barplot, {
    download_plot(pt_diff_go_barplot())
  })
  
  # Data frame of top GO terms with go column containing integer GO ids
  pt_diff_top_go_terms_df <- reactive({
    if (! is.null(pt_diff_top_go_terms())) {
      go_df <- as.data.frame.matrix(pt_diff_top_go_terms())
      go_df$go <- as.integer(gsub("GO:", "", go_df$GO.ID))
      go_df
    }
  })
  
  pt_diff_go_pval_graph <- reactive({
    if (! is.null(pt_diff_top_go_terms())) {
      df <- data.frame(go = pt_diff_top_go_terms_df()$go,
                       GO.ID = pt_diff_top_go_terms_df()$GO.ID,
                       logpvalue = - log10(as.numeric(pt_diff_top_go_terms_df()$pvalue)),
                       pvalue = pt_diff_top_go_terms_df()$pvalue,
                       annotated = pt_diff_top_go_terms_df()$Annotated,
                       term = pt_diff_top_go_terms_df()$Term,
                       fdr = pt_diff_top_go_terms_df()$FDR,
                       odds_ratio = pt_diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df,
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go,
                     y = ~logpvalue,
                     color = ~logpvalue,
                     size = ~annotated,
                     text = ~paste("GO id: ", GO.ID,
                                   '<br>Annotated: ', annotated,
                                   '<br>GO term: ', term,
                                   '<br>FDR: ', fdr,
                                   '<br>Odds ratio: ', odds_ratio,
                                   '<br>p-value: ', pvalue),
                     hoverinfo = 'text',
                     source = "pt_go_pval_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$pt_diff_go_ontology)),
                                         showticklabels = FALSE,
                                         zeroline = FALSE),
                            yaxis = list(title = '-log<sub>10</sub>pvalue'),
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$pt_diff_go_pval_graph_alpha),
                                y1 = - log10(input$pt_diff_go_pval_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Render plot for GO terms p values
  output$pt_diff_go_pval_graph <- renderPlotly({pt_diff_go_pval_graph()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_go_pval_graph_download, {
    download_plotly(pt_diff_go_pval_graph())
  })
  
  # Instructions on how to brush points
  output$pt_diff_go_pval_graph_brush_msg <- renderUI({
    if (is.null(event_data(event = "plotly_selected",
                           source = "pt_go_pval_graph",
                           session = shiny::getDefaultReactiveDomain()))) {
      p("You can brush on the p-value graph (select points using box select or 
      lasso select tool on upper right corner of image) to see specific samples 
        information in a table. ")
    }
  })
  
  # Make GO terms p-value plotly graph brushed points table
  observeEvent({
    event_data(event = "plotly_selected",
               source = "pt_go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  },{
    go_selected <- event_data(event = "plotly_selected",
                              source = "pt_go_pval_graph",
                              session = shiny::getDefaultReactiveDomain())
    df <- pt_diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
    output$pt_diff_go_pval_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                                rownames = FALSE,
                                                                filter = list(position = 'top', clear = FALSE),
                                                                selection = "none")
  })
  
  # Show detailed info modal on GO terms p-value graph click event
  observeEvent({
    event_data(event = "plotly_click",
               source = "pt_go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  }, {
    go_clicked <- event_data(event = "plotly_click",
                             source = "pt_go_pval_graph",
                             session = shiny::getDefaultReactiveDomain())
    go_info <- pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(pt_diff_top_go_terms_df()) != 'go']
    go_info$gene <- gsub(",", "<br/>", go_info$gene)
    go_info <- t(go_info)
    rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
    rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
    output$pt_diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info,
                                                                                  colnames = "",
                                                                                  selection = "none",
                                                                                  escape = FALSE))
    showModal(modalDialog(
      tagList(
        downloadButton("pt_go_genes_download", "Download significant genes", 
                       class = "regular-btn"),
        DT::dataTableOutput("pt_diff_go_graph_pt_details_table")
      ),
      easyClose = TRUE
    ))
  })
  
  pt_diff_go_fdr_graph <- reactive({
    if (! is.null(pt_diff_top_go_terms())) {
      df <- data.frame(go = pt_diff_top_go_terms_df()$go,
                       GO.ID = pt_diff_top_go_terms_df()$GO.ID,
                       logfdr = - log10(as.numeric(pt_diff_top_go_terms_df()$FDR)),
                       pvalue = pt_diff_top_go_terms_df()$pvalue,
                       annotated = pt_diff_top_go_terms_df()$Annotated,
                       term = pt_diff_top_go_terms_df()$Term,
                       fdr = pt_diff_top_go_terms_df()$FDR,
                       odds_ratio = pt_diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df,
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go,
                     y = ~logfdr,
                     color = ~logfdr,
                     size = ~annotated,
                     text = ~paste("GO id: ", GO.ID,
                                   '<br>Annotated: ', annotated,
                                   '<br>GO term: ', term,
                                   '<br>FDR: ', fdr,
                                   '<br>Odds ratio: ', odds_ratio,
                                   '<br>p-value: ', pvalue),
                     hoverinfo = 'text',
                     source = "pt_go_fdr_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$pt_diff_go_ontology)),
                                         showticklabels = FALSE,
                                         zeroline = FALSE),
                            yaxis = list(title = '-log<sub>10</sub>FDR'),
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$pt_diff_go_fdr_graph_alpha),
                                y1 = - log10(input$pt_diff_go_fdr_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Render plot for GO terms FDR
  output$pt_diff_go_fdr_graph <- renderPlotly({pt_diff_go_fdr_graph()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_go_fdr_graph_download, {
    download_plotly(pt_diff_go_fdr_graph())
  })
  
  # Instructions on how to brush points
  output$pt_diff_go_fdr_graph_brush_msg <- renderUI({
    if (is.null(event_data(event = "plotly_selected",
                           source = "pt_go_fdr_graph",
                           session = shiny::getDefaultReactiveDomain()))) {
      p("You can brush on the FDR graph (select points using box select or 
      lasso select tool on upper right corner of image) to see specific samples 
        information in a table. ")
    }
  })
  
  # Make GO terms FDR plotly graph brushed points table
  observeEvent(
    suppressWarnings(event_data(event = "plotly_selected",
                                source = "pt_go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())),
    {
      go_selected <- event_data(event = "plotly_selected",
                                source = "pt_go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())
      df <- pt_diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
      output$pt_diff_go_fdr_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                                 rownames = FALSE,
                                                                 filter = list(position = 'top', clear = FALSE),
                                                                 selection = "none")
    })
  
  # Show detailed info modal on GO terms FDR graph click event
  observeEvent(
    suppressWarnings(event_data(event = "plotly_click",
                                source = "pt_go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())),
    {
      go_clicked <- event_data(event = "plotly_click",
                               source = "pt_go_fdr_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(pt_diff_top_go_terms_df()) != 'go']
      go_info$gene <- gsub(",", "<br/>", go_info$gene)
      go_info <- t(go_info)
      rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
      rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
      output$pt_diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info,
                                                                                    colnames = "",
                                                                                    selection = "none",
                                                                                    escape = FALSE))
      showModal(modalDialog(
        tagList(
          downloadButton("pt_go_genes_download", "Download significant genes", 
                         class = "regular-btn"),
          DT::dataTableOutput("pt_diff_go_graph_pt_details_table")
        ),
        easyClose = TRUE
      ))
    }
  )
  
  pt_diff_go_volcano_plot <- reactive({
    if (! is.null(pt_diff_top_go_terms())) {
      df <- data.frame(GO.ID = pt_diff_top_go_terms_df()$GO.ID,
                       logpvalue = - log10(as.numeric(pt_diff_top_go_terms_df()$pvalue)),
                       pvalue = pt_diff_top_go_terms_df()$pvalue,
                       annotated = pt_diff_top_go_terms_df()$Annotated,
                       term = pt_diff_top_go_terms_df()$Term,
                       fdr = pt_diff_top_go_terms_df()$FDR,
                       odds_ratio = pt_diff_top_go_terms_df()$odds_ratio_pseudo)
      # Only keep finite odds ratio rows
      df <- df[is.finite(df$odds_ratio), ]
      # Indicate significance in df
      df$significance <- rep("non-significant", nrow(df))
      df$significance[(df$pvalue < input$pt_diff_go_volcano_plot_alpha) & (df$odds_ratio > input$pt_diff_go_volcano_plot_or_threshold)] <- "significant"
      # Set colors
      pal <- c("grey", "blue")
      pal <- setNames(pal, c("non-significant", "significant"))
      fig <- plot_ly(type = 'scatter',
                     mode = 'markers',
                     source = "pt_go_volcano_plot",
                     data = df,
                     x = ~odds_ratio,
                     y = ~logpvalue,
                     color = ~significance,
                     colors = pal,
                     text = ~paste("GO id: ", GO.ID,
                                   '<br>Annotated: ', annotated,
                                   '<br>GO term: ', term,
                                   '<br>FDR: ', fdr,
                                   '<br>Odds ratio: ', odds_ratio,
                                   '<br>p-value: ', pvalue),
                     hoverinfo = 'text')
      fig <- fig %>% layout(xaxis = list(title = 'Odds ratio'),
                            yaxis = list(title = '-log<sub>10</sub>pvalue'))
      fig
    }
  })
  
  # Render GO terms volcano plot
  output$pt_diff_go_volcano_plot <- renderPlotly({pt_diff_go_volcano_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$pt_diff_go_volcano_plot_download, {
    download_plotly(pt_diff_go_volcano_plot())
  })
  
  # Download GO term significant genes in modal pop-up
  output$pt_go_genes_download <- downloadHandler(
    filename = {
      go_clicked <- event_data(event = "plotly_click",
                               source = "pt_go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      paste0(pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, 'GO.ID'], "_significant_genes.txt")
    },
    content = function(file) {
      go_clicked <- event_data(event = "plotly_click",
                               source = "pt_go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- pt_diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(pt_diff_top_go_terms_df()) != 'go']
      write.table(unlist(strsplit(go_info$gene, ",")),
                  file,
                  row.names = FALSE,
                  col.names = FALSE,
                  quote = FALSE)
    }
  )
  
  # Differential test top GO terms download
  output$pt_diff_go_table_download <- downloadHandler(
    filename = "Top_GO_terms.txt",
    content = function(file) {
      write.table(pt_diff_top_go_terms(),
                  file,
                  row.names = FALSE,
                  quote = FALSE,
                  sep = "\t")
    }
  )
  
  # Render significant differential bins nearest genes associated top GO terms table
  output$pt_diff_go_table <- DT::renderDataTable({
    if (! is.null(pt_diff_top_go_terms())) {
      pt_diff_top_go_terms() %>%
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE),
                  selection = "none",
                  options = list(scrollX = TRUE)) %>%
        formatRound(columns=c('pvalue', 'FDR', "odds_ratio_conditional",
                              "odds_ratio_unconditional", "odds_ratio_pseudo"),
                    digits=4)
    }
  })
  
  output$heatmap_page_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to display a heatmap. ")
    } else if (n_bins_selected() < 2) {
      p("You must select at least 2 genomic bins to display a heatmap. ")
    } else {
      max_hypervar <- 10000
      if (Sys.getenv('SHINY_PORT') != "") {
        max_hypervar <- 3000
      }
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h2("BIRD predictions heat map")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "heatmap_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "heatmap_page_info",
          title = "<h3>BIRD predictions heat map</h3>",
          content = do.call(paste0, 
                            popover_contents()$heatmap_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        sliderInput(
          "heatmap_top_var", 
          label = tags$span("Number of top variance rows to include in heat map", 
                            bsButton("heatmap_top_var_info", 
                                     label = "", 
                                     icon = icon("info"),
                                     style = "info", 
                                     size = "extra-small")), 
          min = 1000, 
          max = max_hypervar, 
          value = 2000, 
          step = 100
        ),
        bsPopover(
          id = "heatmap_top_var_info",
          title = "<h4>Heat map top variance genomic bins</h4>",
          content = do.call(paste0, 
                            popover_contents()$heatmap_top_var_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fluidRow(
          column(
            6, 
            radioButtons(
              "heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            )
          ), 
          column(
            6, 
            checkboxInput(
              "heatmap_show_nearest_genes", 
              label = "Show nearest genes",
              value = FALSE
            ),
            checkboxInput(
              "heatmap_scale", 
              "Scale heatmap rows", 
              value = TRUE
            ),
          )
        ),
        actionButton("show_interactive_heatmap", "Show interactive heat map", 
                     class = "regular-btn"),
        h4("Heat map"),
        plotOutput("heat_map"), 
        bsTooltip("heat_map", 
                  title = "The heat map columns are selected samples ordered by column clusters. Each heat map row is a genomic bin. Each heat map cell value is the predicted log<sub>2</sub> chromatin accessibility value at a genomic bin in a selected sample", 
                  placement = "top"),
        actionButton("heat_map_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Create Heatmap object
  heat_map <- reactive({
    n_top_var <- min(input$heatmap_top_var, nrow(pred_hypervar()))
    top_var_idx <- base::sort(pred_hypervar()$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    
    # Filter prediction matrix by top variance rows
    pred_mat_sorted <- pred_mat()[pred_hypervar()$feature[top_var_idx], ] # This is sorted by decreasing variance
    pred_mat_sorted_gbins <- rownames(pred_mat_sorted)
    
    # Make heat map
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$heatmap_sort_by == "Decreasing variance") {
      row.order <- order(1:nrow(pred_mat_sorted))
      cluster.rows <- FALSE
    } else if (input$heatmap_sort_by == "Genomic position") {
      sorted_gbins <- pred_hypervar()$feature[base::sort(top_var_idx)] # Genomic bins sorted by genomic position
      row.order <- sapply(pred_mat_sorted_gbins, function(x) {
        which(sorted_gbins == x)
      })
      row.order <- order(row.order)
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    if (input$heatmap_show_nearest_genes) {
      nearest_genes <- gbin_tss()[rownames(pred_mat_sorted), ]$gene
      nearest_genes[is.na(nearest_genes)] <- "None"
      rownames(pred_mat_sorted) <- nearest_genes
    }
    if (input$heatmap_scale) {
      pred_mat_sorted <- t(scale(t(pred_mat_sorted)))
      pred_mat_sorted[is.na(pred_mat_sorted)] <- 0
    }
    ht <- Heatmap(pred_mat_sorted, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "predicted \nchromatin \naccessibility"))
    if (input$heatmap_show_nearest_genes) {
      ht <- ht + rowAnnotation(gbins = anno_text(pred_mat_sorted_gbins), 
                               nearest_genes = anno_text(nearest_genes))
    }
    removeModal()
    return(draw(ht))
  })
  
  # Render heat map
  output$heat_map <- renderPlot({
    heat_map()
  })
  
  observeEvent(input$heat_map_download, {
    download_plot(heat_map())
  })
  
  # Interactive heat map
  observeEvent(input$show_interactive_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, heat_map())
  })
  
  # Render differential analysis page ui
  output$diff_page_ui <- renderUI({
    if (nrow(selected_samples()) < 3) {
      p("You must select at least 3 samples to perform differential analysis. ")
    } else if (n_bins_selected() < 2) {
      p("You must select at least 2 genomic bins to perform differential analysis. ")
    } else {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h2("Group differential analysis")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_page_info",
          title = "<h3>Differential analysis steps</h3>",
          content = do.call(paste0, 
                            popover_contents()$diff_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        tabsetPanel(
          # Tab panel for clustering/grouping samples
          tabPanel(
            title = "Group samples", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px", 
              sidebarLayout(
                sidebarPanel(
                  h4("Sample grouping methods and parameters"),
                  radioButtons(
                    "samples_grouping_method", 
                    "Group samples by: ", 
                    c("manual selection", "k-means clustering"), 
                    selected = character(0)
                  ), 
                  bsTooltip("samples_grouping_method", 
                            title = "Manual selection methods include text input, drag-and-drop, and lasso selection from samples plot. ", 
                            placement = "right", 
                            options = list(container = "body")), 
                  uiOutput("diff_sample_grouping_options_ui")
                ), 
                mainPanel(
                  uiOutput("diff_sample_grouping_ui")
                )
              )
            )
          ), 
          # Tab panel for differential analysis
          tabPanel(
            title = "Differential testing", 
            tags$div(
              style = "margin-bottom:50px; margin-top:50px", 
              uiOutput('diff_test_analysis_panel_ui')
            )
          )
        )
      )
    }
  })
  
  # UI for grouping option parameters that show up on sidebar
  output$diff_sample_grouping_options_ui <- renderUI({
    req(input$samples_grouping_method)
    if (input$samples_grouping_method == "k-means clustering") {
      max_hypervar <- 10000
      if (Sys.getenv('SHINY_PORT') != "") {
        max_hypervar <- 3000
      }
      tagList(
        # PCA
        sliderInput(
          "diff_pca_top_var", 
          label = "Number of top variance rows to use in PCA computation", 
          min = 1000, 
          max = max_hypervar, 
          value = 2000, 
          step = 100
        ),
        bsTooltip("diff_pca_top_var", 
                  title = "Only this number of hyper-variable bins will be selected to use in PCA. The maximum number of hyper-variable bins is 10,000 in session run on local host but only 3,000 for those run on server.", 
                  placement = "right", 
                  options = list(container = "body")), 
        wellPanel(
          fluidRow(
            style = 'margin-left: 2%; margin-right: 2%;',
            tags$div(
              style = "width: 70%; display: inline-block; vertical-align: middle;", 
              selectInput(
                "diff_pca_show_graph", 
                label = "Show PCA results: ", 
                choices = c("PCA Plot", "Explained Variance", "Cumulative Explained Variance")
              )
            ),
            tags$div(
              style = "display: inline-block; vertical-align: middle;", 
              actionButton("diff_pca_show_graph_submit", "View graph", 
                           class = "regular-btn")
            )
          )
        ),
        uiOutput("diff_n_pc_ui")
      )
    } else if (input$samples_grouping_method == "manual selection") {
      tagList(
        selectInput(
          "diff_manual_grouping_method", 
          "Select groups by: ", 
          c("Text input", "Drag and drop", "Select from plot")
        ), 
        uiOutput("diff_manual_grouping_options_ui")
      )
    }
  })
  
  output$diff_n_pc_ui <- renderUI({
    req(diff_pca_res())
    req(diff_opt_n_pc())
    tagList(
      sliderInput(
        "diff_n_pc", 
        label = "Number of PCs to use for sample clustering: ", 
        min = 1, 
        max = min(30, ncol(diff_pca_res())), 
        value = diff_opt_n_pc(), 
        step = 1
      ),
      checkboxInput(
        "diff_use_opt_n_pc", 
        label = "Use optimal number of PCs", 
        value = TRUE
      ),
      htmlOutput('diff_opt_n_pc_msg'),
      bsTooltip("diff_opt_n_pc_msg", 
                title = "The optimal number of PCs is calculated by elbow method on cumulative explained variance. ", 
                placement = "left", 
                options = list(container = "body"))
    )
  })
  
  # UI for grouping details for specific grouping option
  output$diff_sample_grouping_ui <- renderUI({
    req(input$samples_grouping_method)
    req
    if (input$samples_grouping_method == "k-means clustering") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Samples k-means clustering")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_kmeans_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_kmeans_info",
          title = "<h3>Use k-means clustering to group samples</h3>",
          content = do.call(paste0, 
                            popover_contents()$diff_group_kmeans_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        # Define number of sample clusters
        wellPanel(
          fluidRow(
            column(6, uiOutput("diff_n_sample_clust_ui")), 
            column(6, checkboxInput(
              "diff_use_opt_n_sample_clust", 
              label = "Use optimal number of sample clusters", 
              value = TRUE
            ))
          ),
          htmlOutput('diff_opt_n_sample_clust_msg'), 
          bsTooltip("diff_opt_n_sample_clust_msg", 
                    title = "The optimal number of clusters is calculated by elbow method. ", 
                    placement = "left", 
                    options = list(container = "body"))
        ),
        checkboxInput(
          "diff_show_sample_clust_wss_plot", 
          label = "Show Total Within Cluster Sum of Squares Plot", 
          value = FALSE
        ),
        uiOutput("diff_sample_clust_wss_plot_ui"),
        checkboxInput(
          "diff_show_sample_clust_res", 
          label = "Show samples k-means clustering result", 
          value = TRUE
        ), 
        uiOutput("diff_sample_clust_res_ui"),
        actionButton(
          "submit_diff_groups_kmeans", 
          label = "Confirm groups", 
          class = "important-btn"
        ),
        textOutput("diff_groups_kmeans_submission_text")
      )
    } else if (input$samples_grouping_method == "manual selection") {
      uiOutput("diff_manual_grouping_ui")
    }
  })
  
  # UI panel for differential analysis k-means grouping number of clusters slider
  output$diff_n_sample_clust_ui <- renderUI({
    sliderInput(
      "diff_n_sample_clust", 
      label = "Number of sample clusters: ", 
      min = 2, 
      max = min(diff_max_n_sample_clust, ncol(pred_mat()) - 1), 
      value = 2, 
      step = 1
    )
  })
  
  # UI panel for manual group selection parameters
  output$diff_manual_grouping_options_ui <- renderUI({
    if (input$diff_manual_grouping_method == "Select from plot") {
      tagList(
        sliderInput(
          "diff_pca_top_var", 
          label = "Number of top variance rows to use in PCA computation", 
          min = 1000, 
          max = 10000, 
          value = 2000, 
          step = 100
        ),
        actionButton("diff_plotsel_group_view", "View selected groups", 
                     style = "width: 100%; border: 1px solid white;", 
                     class = "regular-btn"), 
        actionButton("diff_plotsel_group_clear", "Clear all groups", 
                     style = "width: 100%; border: 1px solid white;", 
                     class = "regular-btn"), 
        actionButton("diff_plotsel_group_submit", "Confirm group selection", 
                     class = "important-btn",
                     style = "width: 100%; border: 1px solid white;"), 
        textOutput("diff_plotsel_group_submit_message")
      )
    }
  })
  
  # UI panel for manual group selection
  output$diff_manual_grouping_ui <- renderUI({
    if (input$diff_manual_grouping_method == "Text input") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Group samples by text input")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_text_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_text_info",
          title = "<h3>Use text input to group samples</h3>",
          content = do.call(paste0, 
                            popover_contents()$diff_group_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        textAreaInput(
          "diff_sample_groups_text", 
          label = tags$span("Input comma-separated sample ids (each line is a group)",
                            bsButton("diff_sample_groups_text_info", 
                                     label = "", 
                                     icon = icon("info"), 
                                     style = "info", 
                                     size = "extra-small")), 
          rows = 5),
        bsPopover(
          id = "diff_sample_groups_text_info",
          title = "<h4>Use text input to group samples</h4>",
          content = do.call(paste0, 
                            popover_contents()$diff_sample_groups_text_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        fileInput(
          "diff_sample_groups_txt_file", 
          "Upload txt file indicating sample groups", 
          accept = "text/plain"
        ),
        actionButton(
          "submit_diff_groups_text", 
          label = "Confirm groups", 
          class = "important-btn"
        ),
        textOutput("diff_groups_text_submission_text")
      )
    } else if (input$diff_manual_grouping_method == "Drag and drop") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Group samples by drag and drop")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_dd_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_dd_info",
          title = "<h3>Use drag-and-drop to group samples</h3>",
          content = do.call(paste0, 
                            popover_contents()$diff_group_dd_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        uiOutput("diff_group_sel_bucket"), 
        uiOutput("diff_dd_del_group_ui"), 
        uiOutput("diff_dd_add_group_ui"), 
        actionButton("diff_dd_reset_groups", "Reset", 
                     style = "width: 40%; border: 1px solid white;", 
                     class = "regular-btn"),
        br(),
        actionButton("submit_diff_groups_dd", "Confirm groups", 
                     style = "width: 40%; border: 1px solid white;", 
                     class = "important-btn"), 
        uiOutput("diff_groups_text_submission_dd")
      )
    } else if (input$diff_manual_grouping_method == "Select from plot") {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h3("Group samples from plot")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "diff_group_plotsel_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "diff_group_plotsel_info",
          title = "<h3>Select sample groups from plot</h3>",
          content = do.call(paste0, 
                            popover_contents()$diff_group_plotsel_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        uiOutput("diff_plotsel_plot_ui"), 
        checkboxInput("diff_plotsel_show_sel_pts", 
                      "Show selected samples in table", 
                      value = TRUE), 
        uiOutput("diff_plotsel_sel_pts_table_ui"),
        tags$div(
          style = "display: inline-block;", 
          actionButton("diff_plotsel_add_group", "Add to new group", 
                       style = "border: 1px solid white;", 
                       class = "regular-btn"),
          actionButton("diff_plotsel_add_to_group", "Add to existing group", 
                       style = "border: 1px solid white;", 
                       class = "regular-btn"),
          actionButton("diff_plotsel_make_rest_group", "Add all remaining samples to new group", 
                       style = "border: 1px solid white;", 
                       class = "regular-btn")
        )
      )
    }
  })
  
  # Show modal with PCA results graph
  observeEvent(input$diff_pca_show_graph_submit, {
    showModal(modalDialog(
      uiOutput("diff_pca_ui"),
      size = 'l',
      easyClose = TRUE
    ))
  })
  
  # Sample groups - named vector similar to clustering vector
  diff_sample_groups <- reactiveVal()
  
  # Reset sample groups when selected samples change
  observeEvent(selected_samples(), {
    diff_sample_groups(NULL)
  })
  
  # Reactive value containing selected groups from plot
  diff_plotsel_groups <- reactiveVal(list())
  
  # Render UI for group selection plot
  output$diff_plotsel_plot_ui <- renderUI({
    if (length(unlist(diff_plotsel_groups())) == nrow(selected_samples())) {
      p("All samples have been grouped. Click on Confirm groups to submit sample groups. ")
    } else {
      tagList(
        h4("Samples PCA plot"), 
        plotlyOutput("diff_plotsel_plot"),
        bsTooltip("diff_plotsel_plot", 
                  title = "Samples PCA plot. Use box select or lasso select tools on top to select and group samples from this plot. ", 
                  placement = "top", 
                  options = list(container = "body"))
      )
    }
  })
  
  # Render plot selection PCA plot
  output$diff_plotsel_plot <- renderPlotly({
    top_pcs <- diff_pca_res()[, 1:2]
    df <- cbind(top_pcs, selected_samples())
    grouped_samples <- unlist(diff_plotsel_groups())
    df <- df[! df$sample %in% grouped_samples, ]
    g <- ggplot(data = df, 
                mapping = aes(PC1, PC2, 
                              colour = factor(project), 
                              customdata = sample, 
                              text = paste("File source: ", file_source, 
                                           '<br>Project: ', project, 
                                           '<br>Sample: ', sample))) + geom_point()
    g$labels$colour <- "Project"
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    p <- ggplotly(g, 
                  tooltip = 'text', 
                  source = "diff_plotsel_plot")
    event_register(p, "plotly_selected")
    p
  })
  
  # Selected samples from plot
  diff_plotsel_plot_samples_selected <- reactiveVal(c())
  
  # Update selected samples from plot
  observe({
    selected <- event_data(event = "plotly_selected", 
                           source = "diff_plotsel_plot",
                           session = shiny::getDefaultReactiveDomain())
    diff_plotsel_plot_samples_selected(selected$customdata)
  })
  
  # Render UI for selected points table
  output$diff_plotsel_sel_pts_table_ui <- renderUI({
    if (input$diff_plotsel_show_sel_pts) {
      tagList(
        h4("Selected samples"), 
        DT::dataTableOutput("diff_plotsel_sel_pts_table")
      )
    }
  })
  
  # Render selected points table
  output$diff_plotsel_sel_pts_table <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% diff_plotsel_plot_samples_selected(), ], 
                                                           rownames = FALSE,
                                                           filter = list(position = 'top', clear = FALSE), 
                                                           selection = "none")
  
  # Add new group
  observeEvent(input$diff_plotsel_add_group, {
    if (length(diff_plotsel_plot_samples_selected()) > 0) {
      new_group <- list(diff_plotsel_plot_samples_selected())
      diff_plotsel_groups(c(diff_plotsel_groups(), new_group))
      diff_plotsel_plot_samples_selected(c())
    }
  })
  
  # Add all remaining samples to new group
  observeEvent(input$diff_plotsel_make_rest_group, {
    if (length(unlist(diff_plotsel_groups())) < nrow(selected_samples())) {
      new_group <- list(selected_samples()$sample[! selected_samples()$sample %in% unlist(diff_plotsel_groups())])
      diff_plotsel_groups(c(diff_plotsel_groups(), new_group))
      diff_plotsel_plot_samples_selected(c())
    }
  })
  
  # Show pop-up when user adds samples to existing group
  observeEvent(input$diff_plotsel_add_to_group, {
    if (length(diff_plotsel_plot_samples_selected()) > 0) {
      if (length(diff_plotsel_groups()) > 0) {
        showModal(modalDialog(
          tagList(
            selectInput("diff_plotsel_add_to_group_sel", 
                        "Add to group: ", 
                        choices = c(1:length(diff_plotsel_groups()))), 
            actionButton("diff_plotsel_add_to_group_submit", "Confirm adding to selected group", 
                         class = "regular-btn")
          ), 
          size = 'l',
          easyClose = TRUE
        ))
      } else {
        showModal(modalDialog(
          p("There is no existing group. Please create groups first."), 
          size = 'l',
          easyClose = TRUE
        ))
      }
    }
  })
  
  # Add samples to existing group
  observeEvent(input$diff_plotsel_add_to_group_submit, {
    add_to_group <- as.numeric(input$diff_plotsel_add_to_group_sel)
    groups_list <- diff_plotsel_groups()
    groups_list[[add_to_group]] <- c(groups_list[[add_to_group]], diff_plotsel_plot_samples_selected())
    diff_plotsel_groups(groups_list)
    diff_plotsel_plot_samples_selected(c())
    removeModal()
  })
  
  # Show pop-up for group viewing
  observeEvent(input$diff_plotsel_group_view, {
    showModal(modalDialog(
      h4("PCA plot of grouped samples"),
      plotlyOutput("diff_plotsel_groups_plot"),
      bsTooltip("diff_plotsel_groups_plot", 
                title = "Each data point is a sample colored by current group", 
                placement = "top", 
                options = list(container = "body")),
      #actionButton("diff_plotsel_groups_plot_download", "Download plot"),
      h4("User-selected groups"),
      uiOutput("diff_plotsel_group_modal_ui"), 
      size = 'l',
      easyClose = TRUE
    ))
  })
  
  diff_plotsel_groups_plot <- reactive({
    top_pcs <- diff_pca_res()[, 1:2]
    df <- cbind(top_pcs, selected_samples())
    groups <- rep('None', nrow(selected_samples()))
    if (length(diff_plotsel_groups())) {
      for (i in 1:length(diff_plotsel_groups())) {
        groups[df$sample %in% diff_plotsel_groups()[[i]]] <- i
      }
    }
    df$group <- groups
    g <- ggplot(data = df, 
                mapping = aes(PC1, PC2, 
                              colour = factor(group),
                              text = paste("File source: ", file_source, 
                                           '<br>Project: ', project, 
                                           '<br>Sample: ', sample, 
                                           '<br>Group: ', group))) + geom_point()
    g$labels$colour <- "Group"
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    p <- ggplotly(g, 
                  tooltip = 'text')
    p
  })
  
  # Render plotly PCA plot colored by groups
  output$diff_plotsel_groups_plot <- renderPlotly({diff_plotsel_groups_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$diff_plotsel_groups_plot_download, {
    download_plotly(diff_plotsel_groups_plot())
  })
  
  # UI for group tables
  output$diff_plotsel_group_modal_ui <- renderUI({
    if (length(diff_plotsel_groups()) > 0) {
      lapply(1:length(diff_plotsel_groups()), function(x) {
        wellPanel(
          strong(paste("Group", x)), 
          hr(),
          DT::dataTableOutput(paste0("diff_plotsel_group", x, "_table"))
        )
      })
    } else {
      p("No group has been created. ")
    }
  })
  
  # Render data tables for created groups
  observeEvent(diff_plotsel_groups(), ignoreNULL = FALSE, {
    if (length(diff_plotsel_groups()) > 0) {
      lapply(1:length(diff_plotsel_groups()), function(x) {
        samples <- diff_plotsel_groups()[[x]]
        df <- selected_samples()[selected_samples()$sample %in% samples, ]
        output[[paste0("diff_plotsel_group", x, "_table")]] <- DT::renderDataTable(df, 
                                                                                   rownames = FALSE,
                                                                                   filter = list(position = 'top', clear = FALSE), 
                                                                                   selection = "none")
      })
    }
  })
  
  # Clear all groups pop-up
  observeEvent(input$diff_plotsel_group_clear, {
    showModal(modalDialog(
      p("Clear all groups?"), 
      actionButton("diff_plotsel_group_clear_confirm", "Yes", 
                   class = "regular-btn")
    ))
  })
  
  # Clear all groups
  observeEvent(input$diff_plotsel_group_clear_confirm, {
    diff_plotsel_groups(list())
    removeModal()
  })
  
  # Render group submission message
  output$diff_plotsel_group_submit_message <- renderText({
    diff_plotsel_group_submit_message()
  })
  
  # Update sample groups
  diff_plotsel_group_submit_message <- eventReactive(input$diff_plotsel_group_submit, {
    if (length(unlist(diff_plotsel_groups())) == nrow(selected_samples())) {
      if (length(diff_plotsel_groups()) == 1) {
        return(paste("Failed. Please make at least 2 groups."))
      }
      if (all(sapply(diff_plotsel_groups(), length) == 1)) {
        return(paste("Failed. Please make sure there is at least 1 group with multiple samples. "))
      }
      vec <- rep(0, nrow(selected_samples()))
      names(vec) <- selected_samples()$sample
      for (i in 1:length(diff_plotsel_groups())) {
        vec[diff_plotsel_groups()[[i]]] <- i
      }
      diff_sample_groups(vec)
      return(paste("Grouping completed!"))
    } else {
      return(paste("Failed. Please group all samples before submission."))
    }
  })
  
  # Update group selection text area input value based on uploaded file
  observeEvent(input$diff_sample_groups_txt_file, {
    if (! is.null(input$diff_sample_groups_txt_file)) {
      groups_text <- paste(readLines(input$diff_sample_groups_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "diff_sample_groups_text", 
        value = groups_text
      )
    }
  })
  
  # Render submission text
  output$diff_groups_text_submission_text <- renderText({
    diff_groups_text_submission_text()
  })
  
  # Update submission text based on action button and text evaluation results
  diff_groups_text_submission_text <- eventReactive(input$submit_diff_groups_text, {
    # Read sample groups from submitted text
    groups_list <- unlist(strsplit(input$diff_sample_groups_text, split = "\n"))
    groups_list <- lapply(groups_list, function(group) {
      samples <- unlist(strsplit(group, split = ","))
      samples <- gsub(" ", "", samples)
      samples <- gsub("\t", "", samples)
      samples
    })
    groups_list <- groups_list[groups_list != ""]
    if (length(unlist(groups_list)) == 0) {
      return(paste("Grouping failed. \nInput is empty."))
    }
    # Check if samples exist in selection
    sample_ids <- colnames(pred_mat())
    if (any(! unlist(groups_list) %in% sample_ids)) {
      bad_samples <- unlist(groups_list)[which(! unlist(groups_list) %in% sample_ids)]
      return(paste0("Grouping failed. \nThe following samples are not found in selected samples:\n", 
                    paste(unique(bad_samples), collapse = "\n")))
    } else if (! all(sample_ids %in% unlist(groups_list))) {
      bad_samples <- sample_ids[which(! sample_ids %in% unlist(groups_list))]
      return(paste0("Grouping failed. \nThe following samples are not assigned to any groups:\n", 
                    paste(unique(bad_samples), collapse = "\n")))
    }
    sample_groups <- rep(0, ncol(pred_mat()))
    names(sample_groups) <- sample_ids
    for (i in seq_along(groups_list)) {
      group_vec <- groups_list[[i]]
      for (sample in group_vec) {
        if (sample_groups[sample] != 0) {
          return(paste0("Grouping failed. \n", sample, " is found in multiple groups."))
        }
        sample_groups[sample] <- i
      }
    }
    if (length(unique(sample_groups)) < 2) {
      paste("Grouping failed. \nYou need at least 2 groups to perform differential analysis.")
    } else if (all(table(sample_groups[sample_groups > 0]) == 1)) {
      paste("Grouping failed. \nYou need at least one group with multiple samples to perform differential analysis.")
    } else {
      diff_sample_groups(sample_groups)
      paste("Grouping completed!")
    }
  })
  
  # Reactive value containing drag and drop groups
  diff_dd_groups <- reactiveVal()
  
  # Update drag and drop groups when selected samples change
  observe({
    sel_samples <- selected_samples()$sample
    diff_dd_groups(tibble(text = c("Drag samples from here", "group 1", "group 2"), 
                          values = list(sel_samples, NULL, NULL), 
                          ids = c("diff_samples_bank", "diff_group1", "diff_group2")))
  })
  
  # Render UI for last rank list deletion
  output$diff_dd_del_group_ui <- renderUI({
    if ((nrow(diff_dd_groups()) > 3)) {
      actionButton("diff_dd_del_group", "Delete last group", 
                   style = "width: 40%; border: 1px solid white;", 
                   class = "regular-btn")
    }
  })
  
  # Remove last rank list
  observeEvent(input$diff_dd_del_group, {
    last_group <- paste0("diff_group", nrow(diff_dd_groups()) - 1)
    last_group_items <- input[[last_group]]
    updated_samples_bank <- c(input$diff_samples_bank, last_group_items)
    curr_groups <- diff_dd_groups() 
    curr_groups$values <- input$diff_dd_bucket
    curr_groups$values[[1]] <- updated_samples_bank
    diff_dd_groups(curr_groups[- nrow(curr_groups), ])
  })
  
  # Render UI for adding new rank list
  output$diff_dd_add_group_ui <- renderUI({
    if (nrow(diff_dd_groups()) < ncol(pred_mat())) {
      actionButton("diff_dd_add_group", "Add new group", 
                   style = "width: 40%; border: 1px solid white;", 
                   class = "regular-btn")
    }
  })
  
  # Add new rank list
  observeEvent(input$diff_dd_add_group, {
    new_group <- tibble(text = paste("group", nrow(diff_dd_groups())),
                        values = NULL, 
                        ids = paste0("diff_group",nrow(diff_dd_groups())))
    curr_groups_vals <- input$diff_dd_bucket
    curr_groups_vals[length(curr_groups_vals) + 1] <- list(NULL)
    curr_groups <- tibble(text = c("Drag samples from here", paste("group", 1:nrow(diff_dd_groups()))),
                          values = curr_groups_vals, 
                          ids = c("diff_samples_bank", paste0("diff_group", 1:nrow(diff_dd_groups()))))
    diff_dd_groups(curr_groups)
  })
  
  # Reset rank lists pop-up
  observeEvent(input$diff_dd_reset_groups, {
    showModal(modalDialog(
      p("Clear all groups? "), 
      actionButton("diff_dd_reset_groups_confirm", "Yes", 
                   class = "regular-btn")
    ))
  })
  
  # Reset rank lists
  observeEvent(input$diff_dd_reset_groups_confirm, {
    sel_samples <- selected_samples()$sample
    diff_dd_groups(tibble(text = c("Drag samples from here", "group 1", "group 2"), 
                          values = list(sel_samples, NULL, NULL), 
                          ids = c("diff_samples_bank", "diff_group1", "diff_group2")))
    removeModal()
  })
  
  # Rank list items for bucket list 
  diff_groups_rank_lists <- reactive({
    diff_dd_groups() %>% mutate(
      rank.list = pmap(list(text, values, ids), function(x,y,z){
        add_rank_list(
          text = x,
          labels = y ,
          input_id = z
        )
      })
    ) %>% pull(rank.list)
  })
  
  # Render UI for drag and drop group selection 
  output$diff_group_sel_bucket <- renderUI({
    rank_list_items <- diff_groups_rank_lists()
    do.call("bucket_list", args = c(
      list(header = "",
           group_name = "diff_dd_bucket",
           orientation = "horizontal"),
      rank_list_items
    ))
  })
  
  # Render submission text
  output$diff_groups_text_submission_dd <- renderText({
    diff_groups_text_submission_dd()
  })
  
  # Update submission text based on action button and drag and drop groups
  diff_groups_text_submission_dd <- eventReactive(input$submit_diff_groups_dd, {
    groups_list <- input$diff_dd_bucket
    groups_list[1] <- NULL
    sample_groups <- rep(0, ncol(pred_mat()))
    names(sample_groups) <- colnames(pred_mat())
    for (i in seq_along(groups_list)) {
      group_vec <- groups_list[[i]]
      for (sample in group_vec) {
        sample_groups[sample] <- i
      }
    }
    if (all(table(sample_groups[sample_groups > 0]) == 1)) {
      paste("Grouping failed. \nYou need at least one group with multiple samples to perform differential analysis.")
    } else if (any(sample_groups == 0)) {
      paste0("Grouping failed. \nThe following samples are not assigned to any groups:\n", 
             paste(names(sample_groups[sample_groups == 0]), collapse = "\n"))
    } else {
      diff_sample_groups(sample_groups)
      paste("Grouping completed!")
    }
  })
  
  # Get PCA result
  diff_pca_res_full <- reactive({
    
    req(pred_hypervar())
    req(input$diff_pca_top_var)
    # Calculate hyper variance for each bin
    top_var_idx <- order(pred_hypervar()$hypervar, decreasing = T)[1:input$diff_pca_top_var]
    top_var_idx <- sort(top_var_idx)
    pred_mat_sorted <- t(pred_mat()[pred_hypervar()$feature[top_var_idx], ])
    
    # Remove near zero variance columns
    showModal(modalDialog("Filtering near zero variance bins...", footer = NULL, easyClose = TRUE, size = "s"))
    zerovar_bins <- nearZeroVar(pred_mat_sorted)
    if (length(zerovar_bins) > 0) {
      pred_mat_sorted <- pred_mat_sorted[, - zerovar_bins]
    }
    removeModal()
    
    if (any(dim(pred_mat_sorted) == 0)) {
      return(NA)
    }
    
    showModal(modalDialog("Performing PCA...", footer = NULL, easyClose = TRUE, size = "s"))
    pca_result <- prcomp(pred_mat_sorted, 
                         scale = TRUE)
    removeModal()
    
    return(pca_result)
  })
  
  # Get transformed vectors from PCA result
  diff_pca_res <- reactive({
    req(diff_pca_res_full())
    res <- data.frame(diff_pca_res_full()$x)
    # Sort result columns by PC
    return(res[, paste0("PC", 1:ncol(res))])
  })
  
  # Get optimal number of PCs
  diff_opt_n_pc <- reactive({
    sdev <- diff_pca_res_full()$sdev
    # Only consider first 30 PCs
    sdev <- sdev[1:min(30,length(sdev))]
    x <- 1:length(sdev)
    pcadim <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(sdev~x+x2)$residuals^2)
    }))
    pcadim
  })
  
  # Render panel with PCA results or message if no results can be generated
  output$diff_pca_plot_ui <- renderUI({
    req(diff_pca_res())
    if (ncol(diff_pca_res()) < 2) {
      p("Too few genomic bins with significant variance.")
    } else {
      tagList(
        h4("PCA plot"),
        plotOutput("diff_pca_plot", brush = "diff_pca_plot_brush"), 
        bsTooltip("diff_pca_plot", 
                  title = "Each data point in this plot is a sample. Brush on this plot to view sample details. ", 
                  placement = "top", 
                  options = list(container = "body")),
        actionButton("diff_pca_plot_download", "Download plot", 
                     class = "regular-btn"), 
        hr(),
        h4("PCA brushed points table"),
        uiOutput("diff_pca_plot_brush_msg"),
        # Display table with brushed samples
        DT::dataTableOutput('diff_pca_brushed')
      )
    }
  })
  
  # Instructions on how to brush points
  output$diff_pca_plot_brush_msg <- renderUI({
    if (is.null(input$diff_pca_plot_brush)) {
      p("You can brush on the PCA graph (click and drag on plot) to see specific samples 
        information in a table. ")
    }
  })
  
  diff_pca_plot <- reactive({
    req(diff_pca_res())
    if (ncol(diff_pca_res()) >= 2) {
      top_pcs <- diff_pca_res()[, 1:2]
      proj <- selected_samples()$project
      pca_plot <- ggplot(data = top_pcs, 
                         mapping = aes(PC1, PC2, colour = factor(proj))) + geom_point()
      pca_plot$labels$colour <- "Project"
      pca_plot <- pca_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
        theme(panel.border = element_blank(), axis.line = element_line()) + 
        theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
        theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
        theme(panel.background = element_rect(fill = "white"))
      pca_plot
    }
  })
  
  # Render PCA plot
  output$diff_pca_plot <- renderPlot({
    diff_pca_plot()
  })
  
  observeEvent(input$diff_pca_plot_download, {
    download_plot(diff_pca_plot())
  })
  
  # Render PCA brushed points table
  observeEvent(input$diff_pca_plot_brush, {
    top_pcs <- diff_pca_res()[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$diff_pca_plot_brush, xvar = "PC1", yvar = "PC2"))
    output$diff_pca_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                                   rownames = FALSE,
                                                   filter = list(position = 'top', clear = FALSE), 
                                                   selection = "none")
  })
  
  diff_pca_var_plot <- reactive({
    explained_var <- data.frame(t(summary(diff_pca_res_full())$importance))
    explained_var <- explained_var[paste0('PC', 1:min(30, nrow(explained_var))), ]
    var_plot <- ggplot(data = explained_var, 
                       mapping = aes(factor(rownames(explained_var), levels = rownames(explained_var)), 
                                     explained_var$Proportion.of.Variance, group=1))
    var_plot <- var_plot + geom_line() + geom_point()
    var_plot <- var_plot + xlab("Principal Components") + ylab("Cumulative Proportion of Variance Explained")
    var_plot <- var_plot + geom_text(aes(label=explained_var$Proportion.of.Variance), vjust=-0.25)
    var_plot <- var_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    var_plot
  })
  
  # Render PCA variance plot
  output$diff_pca_var_plot <- renderPlot({
    diff_pca_var_plot()
  })
  
  observeEvent(input$diff_pca_var_plot_download, {
    download_plot(diff_pca_var_plot())
  })
  
  diff_pca_cumvar_plot <- reactive({
    cumvar <- data.frame(t(summary(diff_pca_res_full())$importance))
    cumvar <- cumvar[paste0('PC', 1:nrow(cumvar)), ]
    cumvar_plot <- ggplot(data = cumvar, 
                          mapping = aes(factor(rownames(cumvar), levels = rownames(cumvar)), 
                                        cumvar$Cumulative.Proportion, group=1))
    cumvar_plot <- cumvar_plot + geom_line() + geom_point()
    cumvar_plot <- cumvar_plot + geom_vline(xintercept = paste0('PC', diff_opt_n_pc()), linetype = "dashed")
    cumvar_plot <- cumvar_plot + xlab("Principal Components") + ylab("Proportion of Variance Explained")
    cumvar_plot <- cumvar_plot + geom_text(aes(label=cumvar$Cumulative.Proportion), vjust=-0.25)
    cumvar_plot <- cumvar_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    cumvar_plot
  })
  
  # Render PCA cumulative variance plot
  output$diff_pca_cumvar_plot <- renderPlot({
    diff_pca_cumvar_plot()
  })
  
  observeEvent(input$diff_pca_cumvar_plot_download, {
    download_plot(diff_pca_cumvar_plot())
  })
  
  # Render PCA results UI panel
  output$diff_pca_ui <- renderUI({
    if (input$diff_pca_show_graph == "PCA Plot") {
      # Output PCA plot
      uiOutput("diff_pca_plot_ui")
    } else if (input$diff_pca_show_graph == "Explained Variance") {
      # Output explained variance plot
      tagList(
        h4("PCA explained variance plot"), 
        plotOutput("diff_pca_var_plot"), 
        bsTooltip("diff_pca_var_plot", 
                  title = "Explained variance for each PC.", 
                  placement = "top", 
                  options = list(container = "body")), 
        actionButton("diff_pca_var_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    } else if (input$diff_pca_show_graph == "Cumulative Explained Variance"){
      # Output cumulative variance plot
      tagList(
        h4("PCA cumulative explained variance plot"), 
        plotOutput("diff_pca_cumvar_plot"), 
        bsTooltip("diff_pca_cumvar_plot", 
                  title = "Cumulative explained variance along number of top PCs.", 
                  placement = "top", 
                  options = list(container = "body")), 
        actionButton("diff_pca_cumvar_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Update chosen number of PCs on optimal choice check box
  observeEvent(input$diff_use_opt_n_pc, {
    if (input$diff_use_opt_n_pc) {
      updateSliderInput(
        session, 
        "diff_n_pc", 
        value = diff_opt_n_pc()
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of PCs
  observeEvent(input$diff_n_pc, {
    if (input$diff_n_pc != diff_opt_n_pc()) {
      updateCheckboxInput(
        session, 
        "diff_use_opt_n_pc", 
        value = FALSE
      )
    }
  })
  
  # Message stating the optimal number of clusters
  output$diff_opt_n_pc_msg <- renderUI({
    HTML(paste0("Optimal number of PCs: <b>", diff_opt_n_pc(), "</b>"))
  })
  
  # All sample clustering results for differential analysis
  all_sample_clust_res <- reactive({
    req(diff_pca_res())
    req(input$diff_n_pc)
    showModal(modalDialog("Clustering samples...", footer = NULL, easyClose = TRUE, size = "s"))
    scaled_df <- diff_pca_res()[, 1:input$diff_n_pc]
    set.seed(12345)
    # Do k-means clustering with all possible number of clusters
    all_res <- list()
    for (i in 2:min(diff_max_n_sample_clust, nrow(diff_pca_res()) - 1)) {
      suppressWarnings(kmeans_res <- kmeans(scaled_df, centers = i, nstart = 25, iter.max = 100))
      all_res[[as.character(i)]] <- kmeans_res
    }
    removeModal()
    return(all_res)
  })
  
  # Optimal number of sample clusters
  diff_opt_n_sample_clust <- reactive({
    req(all_sample_clust_res())
    # Use elbow method to find optimal number of clusters
    wss <- sapply(all_sample_clust_res(), function(x) {x$tot.withinss})
    x <- 1:length(wss)
    opt_nclust <- which.min(sapply(x, function(i) {
      x2 <- pmax(0,x-i)
      sum(lm(wss~x+x2)$residuals^2)
    })) + 1
    return(opt_nclust)
  })
  
  # Selected sample clustering results
  diff_sample_clust_res <- reactive({
    kmeans_res <- all_sample_clust_res()[[as.character(input$diff_n_sample_clust)]]
    return(kmeans_res)
  })
  
  # Message stating the optimal number of clusters
  output$diff_opt_n_sample_clust_msg <- renderUI({
    HTML(paste("Optimal number of clusters:", strong(diff_opt_n_sample_clust())))
  })
  
  diff_sample_clust_wss_plot <- reactive({
    tot_wss <- unlist(lapply(all_sample_clust_res(), function(x) {x$tot.withinss}))
    wss_df <- data.frame(n_clust = c(2:min(diff_max_n_sample_clust, ncol(pred_mat()) - 1)), 
                         wss = tot_wss)
    wcss_plot <- ggplot(data = wss_df, 
                        mapping = aes(n_clust, wss))
    wcss_plot <- wcss_plot + geom_line() + geom_point()
    wcss_plot <- wcss_plot + xlab("Number of Clusters") + ylab("Total Within Cluster Sum of Squares")
    wcss_plot <- wcss_plot + geom_vline(xintercept = diff_opt_n_sample_clust(), linetype="dashed", color = "blue")
    wcss_plot <- wcss_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    wcss_plot
  })
  
  # Sample clusters WSS plot
  output$diff_sample_clust_wss_plot <- renderPlot({
    diff_sample_clust_wss_plot()
  })
  
  observeEvent(input$diff_sample_clust_wss_plot_download, {
    download_plot(diff_sample_clust_wss_plot())
  })
  
  # UI for sample clusters WSS plot
  output$diff_sample_clust_wss_plot_ui <- renderUI({
    if (input$diff_show_sample_clust_wss_plot) {
      tagList(
        h4("Sample clusters within-cluster sum of squares plot"),
        plotOutput('diff_sample_clust_wss_plot'), 
        bsTooltip("diff_sample_clust_wss_plot", 
                  title = "This plot shows the total within-cluster sum of squares for grouping samples into different number of clusters. The dashed line indicates the optimal number of clusters suggested by elbow method. ", 
                  placement = "top", 
                  options = list(container = "body")), 
        actionButton("diff_sample_clust_wss_plot_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  diff_sample_clust_plot_pca <- reactive({
    req(diff_pca_res_full())
    req(diff_sample_clust_res())
    showModal(modalDialog("Making cluster plot...", footer = NULL, easyClose = TRUE, size = "s"))
    # Plot the top 2 PCs
    clust_plot <- ggplot(data = data.frame(diff_pca_res_full()$x)[, 1:2], 
                         mapping = aes(PC1, PC2, colour = factor(diff_sample_clust_res()$cluster)))
    clust_plot <- clust_plot + geom_point()
    clust_plot$labels$colour <- "Cluster"
    explained_var <- summary(diff_pca_res_full())$importance[2, 1:2]
    clust_plot <- clust_plot + xlab(paste0("PC1 (", explained_var[1] * 100, "% variance)"))
    clust_plot <- clust_plot + ylab(paste0("PC2 (", explained_var[2] * 100, "% variance)"))
    clust_plot <- clust_plot + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + 
      theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    removeModal()
    clust_plot
  })
  
  # Render sample clusters PCA plot
  output$diff_sample_clust_plot_pca <- renderPlot({
    diff_sample_clust_plot_pca()
  })
  
  observeEvent(input$diff_sample_clust_plot_pca_download, {
    download_plot(diff_sample_clust_plot_pca())
  })
  
  # Render PCA brushed points table
  observeEvent(input$diff_sample_clust_plot_pca_brush, {
    top_pcs <- data.frame(diff_pca_res_full()$x)[, 1:2]
    brushed_samples <- rownames(brushedPoints(top_pcs, input$diff_sample_clust_plot_pca_brush, xvar = "PC1", yvar = "PC2"))
    output$diff_sample_clust_plot_pca_brushed <- DT::renderDataTable(selected_samples()[selected_samples()$sample %in% brushed_samples, ],
                                                                     rownames = FALSE,
                                                                     filter = list(position = 'top', clear = FALSE), 
                                                                     selection = "none")
  })
  
  # Render table for sample cluster assignment
  output$diff_sample_clust_table <- DT::renderDataTable(data.frame(cluster = as.factor(diff_sample_clust_res()$cluster), 
                                                                   sample = names(diff_sample_clust_res()$cluster)), 
                                                        rownames = FALSE,
                                                        filter = list(position = 'top', clear = FALSE), 
                                                        selection = "none")
  
  # Render UI for differential analysis sample clustering results panels
  output$diff_sample_clust_res_panel <- renderUI({
    if (input$diff_sample_clust_res_show_panel == "Cluster Plot (PCA)") {
      tagList(
        h4("PCA plot of samples"),
        plotOutput('diff_sample_clust_plot_pca', brush = 'diff_sample_clust_plot_pca_brush'), 
        bsTooltip("diff_sample_clust_plot_pca", 
                  title = "This plot shows the top 2 PCs of PCA. Each point is a sample colored by cluster. ", 
                  placement = "top", 
                  options = list(container = "body")),
        actionButton("diff_sample_clust_plot_pca_download", "Download plot", 
                     class = "regular-btn"), 
        hr(),
        # Display table with brushed samples
        h4("PCA plot brushed points"),
        uiOutput("diff_sample_clust_plot_pca_brush_msg"),
        DT::dataTableOutput('diff_sample_clust_plot_pca_brushed')
      )
    } else if (input$diff_sample_clust_res_show_panel == "Clustering") {
      tagList(
        h4("Samples clustering table"),
        downloadButton('diff_sample_clust_table_download', 'Download clustering table', 
                       class = "regular-btn"), 
        DT::dataTableOutput('diff_sample_clust_table')
      )
    } 
  })
  
  # Instructions on how to brush points
  output$diff_sample_clust_plot_pca_brush_msg <- renderUI({
    if (is.null(input$diff_sample_clust_plot_pca_brush)) {
      p("You can brush on the PCA graph (click and drag on plot) to see specific samples 
        information in a table. ")
    }
  })
  
  # Differential analysis samples kmeans cluster result download
  output$diff_sample_clust_table_download <- downloadHandler(
    filename = function() { "Samples_kmeans_clusters.txt" },
    content = function(file) {
      write.table(data.frame(cluster = as.factor(diff_sample_clust_res()$cluster), 
                             sample = names(diff_sample_clust_res()$cluster)),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Render UI for selecting differential analysis sample clustering results panels
  output$diff_sample_clust_res_ui <- renderUI({
    if (input$diff_show_sample_clust_res) {
      tagList(
        selectInput(
          "diff_sample_clust_res_show_panel", 
          label = "Choose sample clustering result panel to display: ", 
          choices = c("Cluster Plot (PCA)", 
                      "Clustering"), 
          selected = "Cluster Plot (PCA)"
        ), 
        uiOutput('diff_sample_clust_res_panel')
      )
    }
  })
  
  # Update chosen number of sample clusters on optimal choice check box
  observeEvent(input$diff_use_opt_n_sample_clust, {
    if (input$diff_use_opt_n_sample_clust) {
      updateSliderInput(
        session, 
        "diff_n_sample_clust", 
        value = diff_opt_n_sample_clust()
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of sample clusters
  observeEvent(input$diff_n_sample_clust, {
    if (input$diff_n_sample_clust != diff_opt_n_sample_clust()) {
      updateCheckboxInput(
        session, 
        "diff_use_opt_n_sample_clust", 
        value = FALSE
      )
    }
  })
  
  output$diff_groups_kmeans_submission_text <- renderText({
    diff_groups_kmeans_submission_text()
  })
  
  # Update submission text based on action button and kmeans clusters evaluation results
  diff_groups_kmeans_submission_text <- eventReactive(input$submit_diff_groups_kmeans, {
    diff_sample_groups(diff_sample_clust_res()$cluster)
    paste0("Grouping completed!")
  })
  
  # Render UI for differential test panel
  output$diff_test_analysis_panel_ui <- renderUI({
    if (! is.null(diff_sample_groups())) {
      sidebarLayout(
        sidebarPanel(
          div(style = "display: inline-block;vertical-align: middle;", h4("Differential test parameters")), 
          div(style = "display: inline-block;vertical-align: middle;", 
              bsButton(
                "diff_param_info", 
                label = "", 
                icon = icon("info"), 
                style = "info", 
                size = "extra-small"
              )), 
          bsPopover(
            id = "diff_param_info",
            title = "<h4>Differential test parameters</h4>",
            content = do.call(paste0, 
                              popover_contents()$diff_param_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          checkboxInput(
            "diff_select_all_sample_groups",
            "Perform test for all sample groups", 
            value = FALSE
          ), 
          uiOutput("diff_select_sample_groups_ui"), 
          bsTooltip("diff_select_sample_groups_ui", 
                    title = "At least 2 groups must be selected, with at least 1 group containing multiple samples. ", 
                    placement = "right", 
                    options = list(container = "body")),
          uiOutput("diff_sel_test_method_ui"), 
          bsTooltip("diff_sel_test_method_ui", 
                    title = "Tests on two groups include t-test, non-parametric Wilcoxon test, and permutation test. Tests on more than two groups include ANOVA test, non-parametric Kruskal-Wallis test, and permutation test. ", 
                    placement = "right", 
                    options = list(container = "body")),
          uiOutput("diff_sel_squeezevar"), 
          uiOutput("diff_permu_num_ui"),
          uiOutput("diff_test_alt_hyp_ui"),
          uiOutput("diff_test_alt_msg_ui"),
          checkboxInput("diff_scale","Scale predictions for each sample"),
          uiOutput('run_diff_test_button_ui') 
        ), 
        mainPanel(
          div(style = "display: inline-block;vertical-align: middle;", h3("Differential test results")), 
          div(style = "display: inline-block;vertical-align: middle;", 
              bsButton(
                "diff_res_panels_info", 
                label = "", 
                icon = icon("info"), 
                style = "info", 
                size = "extra-small"
              )), 
          bsPopover(
            id = "diff_res_panels_info",
            title = "<h4>Differential test results</h4>",
            content = do.call(paste0, 
                              popover_contents()$diff_res_panels_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          uiOutput('diff_res_panels')
        )
      )
    } else {
      p("Please group samples in Group Samples tab and click on Confirm Grouping button to make sample groups first. ")
    }
  })
  
  # Render UI for selecting sample groups for differential test
  output$diff_select_sample_groups_ui <- renderUI({
    selectInput("diff_select_sample_groups",
                "Select groups where differential tests will be performed (at least two should be selected)",
                sort(unique(diff_sample_groups())),
                selected = sort(unique(diff_sample_groups()))[1:2],
                multiple = TRUE)
  })
  
  # Render UI for selecting test method for differential test
  output$diff_sel_test_method_ui <- renderUI({
    if (length(input$diff_select_sample_groups) > 2) {
      radioButtons("diff_sel_test_method",
                   "Select test method",
                   list("ANOVA test"="anovatest",
                        "Kruskal-Wallis test (nonparametric)"="kw",
                        "Permutation test"="permutation"))
    } else if (length(input$diff_select_sample_groups) == 2) {
      radioButtons("diff_sel_test_method",
                   "Select test method",
                   list("t test"="ttest",
                        "wilcoxon test (nonparametric)"="wilcox",
                        "Permutation test"="permutation"))
    }
  })
  
  # Render UI for differential test squeeze variance check box
  output$diff_sel_squeezevar <- renderUI({
    if ((input$diff_sel_test_method %in% c("anovatest", "permutation")) && (length(input$diff_select_sample_groups) > 2)) {
      checkboxInput("diff_squeezevar", "Use shrinkage to squeeze group variances", value = TRUE)
    }
  })
  
  # Render UI for selecting permutation number
  output$diff_permu_num_ui <- renderUI({
    if ((length(input$diff_sel_test_method) > 0) && (input$diff_sel_test_method == "permutation")) {
      sliderInput("diff_permu_num",
                  "Number of permutations",
                  min = 100, 
                  max = 1000, 
                  value = 100, 
                  step = 100)
    }
  })
  
  # Render UI for differential test alternative hypothesis
  output$diff_test_alt_hyp_ui <- renderUI({
    if (length(input$diff_select_sample_groups) == 2) {
      radioButtons("diff_test_alt_hyp",
                   "Select alternative hypothesis type",
                   c("two.sided", "less", "greater"))
    }
  })
  
  # Render UI for differential test alternative hypothesis message
  output$diff_test_alt_msg_ui <- renderUI({
    if (length(input$diff_select_sample_groups) == 2) {
      clu <- diff_sample_groups()
      clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
      uclu <- unique(clu)
      if ((! is.null(input$diff_test_alt_hyp)) && (input$diff_test_alt_hyp == "two.sided")) {
        p(paste0("Group ",uclu[1]," will be compared with group ",uclu[2],". The alternative hypothesis is that group ",uclu[1]," is not equal to group ",uclu[2],"."))
      } else {
        p(paste0("Group ",uclu[1]," will be compared with group ",uclu[2],". The alternative hypothesis is that group ",uclu[1]," is ",input$diff_test_alt_hyp," than group ",uclu[2],"."))
      }
    }
  })
  
  # Render UI for differential test run button
  output$run_diff_test_button_ui <- renderUI({
    if (length(input$diff_select_sample_groups) < 2) {
      return(tags$span(style="color:red", "Please select at least 2 sample groups to perform differential test. "))
    } 
    clu <- diff_sample_groups()
    clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
    if (length(clu) == length(input$diff_select_sample_groups)) {
      tags$span(style="color:red", "Please select at least 1 group containing more than 1 sample to perform differential test, as group size of 1 for all groups causes 0 degree of freedom. ")
    } else {
      actionButton("run_diff_test","Perform Test", 
                   class = "important-btn")
    }
  })
  
  # Update selected sample groups on select all check box
  observeEvent(input$diff_select_all_sample_groups, {
    if (input$diff_select_all_sample_groups) {
      updateSelectInput(
        session, 
        "diff_select_sample_groups", 
        selected = sort(unique(diff_sample_groups()))
      )
    }
  })
  
  # Update optimal choice check box when user selects a different number of PCs
  observeEvent(input$diff_select_sample_groups, {
    if (! all(sort(unique(diff_sample_groups())) %in% input$diff_select_sample_groups)) {
      updateCheckboxInput(
        session, 
        "diff_select_all_sample_groups", 
        value = FALSE
      )
    }
  })
  
  # Perform differential tests (adapted from SCRAT)
  diff_test_res <- reactive({
    if ((! is.null(input$run_diff_test)) && (input$run_diff_test > 0)) {
      showModal(modalDialog("Performing test...", footer = NULL, easyClose = TRUE, size = "s"))
      isolate({
        if (length(input$diff_select_sample_groups) > 2) {
          clu <- diff_sample_groups()
          data <- pred_mat()[, clu %in% as.numeric(input$diff_select_sample_groups)]
          data <- data[rowVars(data) > 0, ] # Remove zero variance bins
          clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
          if (input$diff_scale) {
            dm <- dimnames(data)
            data <- apply(data,2,scale)
            dimnames(data) <- dm
          }
          if (input$diff_sel_test_method=="kw") {
            res <- t(apply(data,1,function(rowdata) {
              tmp <- kruskal.test(rowdata,clu)
              c(tmp$statistic,tmp$p.value)
            }))
            stat <- res[,1]
            FDR <- p.adjust(res[,2],method="fdr")
            removeModal()
            return(data.frame(genomic_bin=row.names(data),statistics=stat,pvalue=res[,2],FDR=FDR,stringsAsFactors = F))
          }
          if (! input$diff_squeezevar) {
            # Remove rows with 0 SSW
            bad_rows <- which(rowSums(sapply(unique(clu),function(i) {
              rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2)
            })) == 0)
            if (length(bad_rows) > 0) {
              data <- data[- bad_rows, ]
            }
            cluSS <- sapply(unique(clu),function(i) {
              rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2)
            })
          } else {
            cluSS <- sapply(unique(clu),function(i) {
              suppressWarnings(squeezeVar(rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2), 
                                          df = sum(clu==i))$var.post)
            })
          }
          if (input$diff_sel_test_method=="anovatest") {
            totalSS <- rowSums((sweep(data,1,rowMeans(data),"-"))^2)
            stat <- ((totalSS-rowSums(cluSS))/(length(unique(clu)) - 1))/(rowSums(cluSS)/(ncol(data) - length(unique(clu))))
            pval <- pf(stat,(length(unique(clu)) - 1),(ncol(data) - length(unique(clu))),lower.tail = F)
            FDR <- p.adjust(pval,method="fdr")
          } else if (input$diff_sel_test_method=="permutation") {
            totalSS <- rowSums((sweep(data,1,rowMeans(data),"-"))^2)
            stat <- ((totalSS-rowSums(cluSS))/(length(unique(clu)) - 1))/(rowSums(cluSS)/(ncol(data) - length(unique(clu))))
            permustat <- sapply(1:as.numeric(input$diff_permu_num),function(id) {
              sampclu <- sample(clu)
              if (input$diff_squeezevar) {
                cluSS <- sapply(unique(sampclu),function(i) {
                  suppressWarnings(squeezeVar(rowSums((sweep(data[,sampclu==i,drop=F],1,rowMeans(data[,sampclu==i,drop=F]),"-"))^2), 
                                              df = sum(sampclu==i))$var.post)
                })
              } else {
                cluSS <- sapply(unique(sampclu),function(i) {
                  rowSums((sweep(data[,sampclu==i,drop=F],1,rowMeans(data[,sampclu==i,drop=F]),"-"))^2)
                })
              }
              ((totalSS-rowSums(cluSS))/(length(unique(clu)) - 1))/(rowSums(cluSS)/(ncol(data) - length(unique(clu))))
            })
            pval <- rowMeans(sweep(permustat,1,stat,"-") > 0)
            FDR <- p.adjust(pval,method="fdr")
          }
          removeModal()
          return(data.frame(genomic_bin=row.names(data),statistics=stat,pvalue=pval,FDR=FDR,stringsAsFactors = F))
        } else if (length(input$diff_select_sample_groups) == 2) {
          clu <- diff_sample_groups()
          data <- pred_mat()[, clu %in% as.numeric(input$diff_select_sample_groups)]
          data <- data[rowVars(data) > 0, ] # Remove zero variance bins
          clu <- clu[clu %in% as.numeric(input$diff_select_sample_groups)]
          
          if (input$diff_scale) {
            dm <- dimnames(data)
            data <- apply(data,2,scale)
            dimnames(data) <- dm
          }
          uclu <- unique(clu)
          if (input$diff_sel_test_method=="permutation") {
            sampmat <- t(sapply(1:as.numeric(input$diff_permu_num),function(i) {
              sample(clu)
            }))
          }
          if (input$diff_sel_test_method!="wilcox") {
            # Remove rows with 0 SSW
            bad_rows <- which(rowSums(sapply(unique(clu),function(i) {
              rowSums((sweep(data[,clu==i,drop=F],1,rowMeans(data[,clu==i,drop=F]),"-"))^2)
            })) == 0)
            if (length(bad_rows) > 0) {
              data <- data[- bad_rows, ]
            }
          }
          res <- t(apply(data,1,function(i) {
            if (input$diff_sel_test_method=="wilcox") {
              suppressWarnings(tmptest <- wilcox.test(i[clu==uclu[1]],i[clu==uclu[2]],alternative = input$diff_test_alt_hyp,var.equal = T))
              c(tmptest$statistic,tmptest$p.value)
            } else if (input$diff_sel_test_method=="ttest") {
              tmptest <- t.test(i[clu==uclu[1]],i[clu==uclu[2]],alternative = input$diff_test_alt_hyp,var.equal = T)      
              c(tmptest$statistic,tmptest$p.value)
            } else if (input$diff_sel_test_method=="permutation") {
              tmptest <- t.test(i[clu==uclu[1]],i[clu==uclu[2]],alternative = input$diff_test_alt_hyp,var.equal = T)$statistic
              permut <- sapply(1:as.numeric(input$diff_permu_num),function(id) {
                sampclu <- sampmat[id,]
                samp1 <- i[sampclu==uclu[1]]
                samp2 <- i[sampclu==uclu[2]]
                mean1 <- mean(samp1)
                mean2 <- mean(samp2)
                var1 <- var(samp1)
                if (length(samp1) == 1) {
                  var1 <- 0
                }
                var2 <- var(samp2)
                if (length(samp2) == 1) {
                  var1 <- 0
                }
                n1 <- length(samp1)
                n2 <- length(samp2)
                (mean1 - mean2)/sqrt((1/n1+1/n2)*((n1-1)*var1+(n2-1)*var2)/(n1+n2-2))
              })
              if (input$diff_test_alt_hyp == "greater") {
                pval <- mean(tmptest < permut)      
              } else if (input$diff_test_alt_hyp == "less") {
                pval <- mean(tmptest > permut)      
              } else if (input$diff_test_alt_hyp == "two.sided") {
                pval <- mean(abs(tmptest) < abs(permut))      
              }
              c(tmptest,pval)
            }
          }))
          FDR <- p.adjust(res[,2],method="fdr")
          removeModal()
          return(data.frame(genomic_bin=row.names(data),statistics=res[,1],pvalue=res[,2],FDR=FDR,stringsAsFactors = F))
        }
      })
      removeModal()
    }
  })
  
  # Render differential analysis results panels
  output$diff_res_panels <- renderUI({
    if (! is.null(diff_test_res())) {
      tabsetPanel(
        tabPanel("Results",
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   h4("Differential test results table"),
                   downloadButton("diff_res_download", "Download results table", 
                                  class = "regular-btn"),
                   DT::dataTableOutput("diff_res_table")
                 )),
        tabPanel("Summary",
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   wellPanel(
                     h4("Significant bins summary"),
                     fluidRow(
                       column(6, sliderInput("diff_alpha", 
                                             "Level of significance (FDR): ", 
                                             min = 0.0001, 
                                             max = 0.5, 
                                             value = 0.05)), 
                       column(6, downloadButton("diff_res_sig_bed_download", "Download significant bins BED file", 
                                                class = "regular-btn"))
                     ),
                     textOutput("diff_sum_text")
                   ),
                   wellPanel(
                     radioButtons("diff_res_hist_val",
                                  "Histogram of: ",
                                  c("statistics", "p-value", "FDR")),
                     h4("Histogram summary"),
                     plotOutput("diff_sum_hist"), 
                     bsTooltip("diff_sum_hist", 
                               title = "Histogram of selected value", 
                               placement = "top", 
                               options = list(container = "body")), 
                     actionButton("diff_sum_hist_download", "Download plot", 
                                  class = "regular-btn")
                   ), 
                   wellPanel(
                     h4("p-value adjustment line plot"),
                     plotOutput("diff_sum_lineplot"), 
                     bsTooltip("diff_sum_lineplot", 
                               title = "Line plot of sorted p-values for all bins before and after FDR adjustment. Dashed line indicates the selected significance level. ", 
                               placement = "top", 
                               options = list(container = "body")), 
                     actionButton("diff_sum_lineplot_download", "Download plot", 
                                  class = "regular-btn")
                   )
                 )), 
        tabPanel("Volcano plot", 
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   wellPanel(
                     fluidRow(
                       column(6, 
                              selectInput(
                                'diff_fc_from', 
                                'Calculate fold change from group:', 
                                c("", input$diff_select_sample_groups)
                              )), 
                       column(6, 
                              selectInput(
                                'diff_fc_to', 
                                'To group:', 
                                c("", input$diff_select_sample_groups)
                              ))
                     ),
                     radioButtons(
                       'diff_volcano_y', 
                       'Vertical axis variable:', 
                       c('p-value', 'FDR')
                     ),
                     uiOutput('diff_volcano_run_button_ui')
                   ), 
                   uiOutput('diff_volcano_plot_ui')
                 )),
        tabPanel("Gene ontology", 
                 tags$div(
                   style = "margin-top:30px; margin-bottom:30px;", 
                   wellPanel(
                     wellPanel(
                       # GO options
                       fluidRow(
                         column(
                           6, 
                           radioButtons(
                             "diff_go_alpha_var", 
                             "Apply significance level cut-off to: ", 
                             c("FDR", 
                               "p-value")
                           )
                         ), 
                         column(
                           6, 
                           sliderInput(
                             "diff_go_alpha", 
                             "Level of significance: ", 
                             min = 0.0001, 
                             max = 0.5, 
                             value = 0.05
                           )
                         )
                       ),
                       checkboxInput(
                         "diff_go_use_logfc_cut", 
                         "Use logFC cut-off"
                       ),
                       uiOutput("diff_go_logfc_cut_ui"),
                       uiOutput("diff_go_gene_maxdist_ui"),
                       textOutput("diff_go_sig_genes_msg"), 
                       checkboxInput(
                         "diff_go_show_external_tool", 
                         "Show external tools", 
                         value = FALSE
                       ),
                       uiOutput("diff_go_external_tool_ui"), 
                       bsTooltip("diff_go_external_tool_ui", 
                                 title = "Use and external tool to analyze significant regions/genes in greater detail. ", 
                                 placement = "left", 
                                 options = list(container = "body")),
                       checkboxInput("diff_go_show_sig_bins_table", 
                                     "Show table mapping significant bins to nearest genes"), 
                       uiOutput('diff_go_sig_bins_table_ui')
                     ),
                     radioButtons("diff_go_ctrl", 
                                  "Control gene list: ", 
                                  c("All genes near selected genomic range",
                                    "All genes near BIRD default prediction range")), 
                     bsTooltip("diff_go_ctrl", 
                               title = "Using only genes near the selected genomic range as control genes is recommended as using all genes will greatly slow down the runtime. ", 
                               placement = "left", 
                               options = list(container = "body")),
                     radioButtons("diff_go_ontology", 
                                  "GO ontology: ", 
                                  c("Biological Process" = "BP", 
                                    "Molecular function" = "MF", 
                                    "Cellular component" = "CC")), 
                     sliderInput("diff_go_top_n", 
                                 "Number of top GO terms to return: ", 
                                 min = 10, 
                                 max = 500, 
                                 value = 20, 
                                 step = 10), 
                     actionButton("run_diff_go", "Find top GO terms", 
                                  class = "important-btn")
                   ), 
                   textOutput('no_feasible_go_terms_warning'), 
                   uiOutput('diff_go_sel_res_ui')
                 ))
      )
    } else {
      p("Select sample groups and click on Perform Test to perform differential test on selected groups. ")
    }
  })
  
  # Differential test result table
  output$diff_res_table <- DT::renderDataTable({
    if (! is.null(diff_test_res())) {
      diff_test_res() %>% 
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = "none") %>% 
        formatRound(columns=c('statistics', 'pvalue', "FDR"), digits=4)
    }
  })
  
  # Differential test result download
  output$diff_res_download <- downloadHandler(
    filename = function() { "BIRD_predictions_differential_analysis.txt" },
    content = function(file) {
      write.table(diff_test_res(),
                  file,
                  row.names=F,
                  quote=F,
                  sep="\t")
    }
  )
  
  # Differential test significant bins BED file download
  output$diff_res_sig_bed_download <- downloadHandler(
    filename = "BIRD_predictions_significant_differential_bins.bed", 
    content = function(file) {
      significant_bins <- diff_test_res()[diff_test_res()$FDR < input$diff_alpha, 1]
      write.table(parse_gbin(significant_bins), 
                  file, 
                  col.names = FALSE, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render text message for number of significant bins
  output$diff_sum_text <- renderText({
    if (!is.null(diff_test_res())) {
      paste("There are ",sum(diff_test_res()$FDR < input$diff_alpha),"significant bins, which is",round(mean(diff_test_res()$FDR < input$diff_alpha),digits=4) * 100,"percent of all selected genomic bins")
    }
  })
  
  diff_sum_hist <- reactive({
    if (!is.null(diff_test_res())) {
      if (input$diff_res_hist_val == "statistics") {
        g <- ggplot(diff_test_res(), aes(statistics)) + geom_histogram() 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="Statistics", y="Frequency")
        g
      } else if (input$diff_res_hist_val == "FDR") {
        g <- ggplot(diff_test_res(), aes(FDR)) + geom_histogram() 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="FDR", y="Frequency")
        g <- g + geom_vline(xintercept = input$diff_alpha, linetype = "dotted", colour = "blue")
        g
      } else if (input$diff_res_hist_val == "p-value") {
        g <- ggplot(diff_test_res(), aes(pvalue)) + geom_histogram() 
        g <- g + theme(panel.background = element_blank()) 
        g <- g + labs(x="p-value", y="Frequency")
        g
      }
    }
  })
  
  # Render summary histogram for differential test result
  output$diff_sum_hist <- renderPlot({
    diff_sum_hist()
  })
  
  observeEvent(input$diff_sum_hist_download, {
    download_plot(diff_sum_hist())
  })
  
  diff_sum_lineplot <- reactive({
    g <- ggplot(diff_test_res()[order(diff_test_res()$pvalue), ], aes(1:nrow(diff_test_res())))
    g <- g + geom_line(aes(y=pvalue, color = "red")) + geom_line(aes(y=FDR, color = "blue"))
    g <- g + geom_hline(yintercept = input$diff_alpha, linetype = "dotted", colour = "blue")
    g <- g + theme(panel.background = element_blank())
    g <- g + labs(x="Genomic bins sorted by p-values", y="Values")
    g <- g + scale_colour_manual(name = 'Values', 
                                 values = c('blue'='blue','red'='red'), 
                                 labels = c('FDR','p-value'))
    g
  })
  
  # Render summary line plot for differential test result
  output$diff_sum_lineplot <- renderPlot({
    diff_sum_lineplot()
  })
  
  observeEvent(input$diff_sum_lineplot_download, {
    download_plot(diff_sum_lineplot())
  })
  
  # Render UI for differential test volcano plot run button
  output$diff_volcano_run_button_ui <- renderUI({
    if ((input$diff_fc_from == "") || (input$diff_fc_to == "")) {
      p("Please select 2 groups for fold change calculation. ")
    } else if (input$diff_fc_from == input$diff_fc_to) {
      p("Selected groups cannot be the same group. Please select 2 different groups. ")
    } else {
      actionButton("diff_volcano_run_button", "Make volcano plot", 
                   class = "important-btn")
    }
  })
  
  # Calculate fold change
  diff_logfc <- reactive({
    if ((! is.null(input$diff_volcano_run_button)) && (input$diff_volcano_run_button > 0)) {
      isolate({
        showModal(modalDialog("Computing fold change...", footer = NULL, easyClose = TRUE, size = "s"))
        data <- pred_mat()[diff_test_res()$genomic_bin, ]
        logFC <- apply(data, 1, function(x) {
          mean(x[diff_sample_groups() == input$diff_fc_to]) - mean(x[diff_sample_groups() == input$diff_fc_from])
        })
        removeModal()
        return(logFC)
      })
    }
  })
  
  # Render UI for differential test volcano plot
  output$diff_volcano_plot_ui <- renderUI({
    if ((! is.null(diff_logfc())) && (input$diff_volcano_run_button > 0)) {
      tagList(
        tags$div(
          id = "diff_volcano_params",
          fluidRow(
            column(6, 
                   sliderInput(
                     "diff_volcano_alpha", 
                     paste("Select", isolate(input$diff_volcano_y), "significance level"), 
                     min = 0, 
                     max = 1, 
                     value = 0.05
                   )), 
            column(6, 
                   sliderInput(
                     "diff_volcano_logfc_threshold", 
                     "Select log(FC) threshold", 
                     min = 0, 
                     max = ceiling(max(abs(diff_logfc()))), 
                     value = min(ceiling(max(abs(diff_logfc()))), 1), 
                     step = 0.01
                   ))
          )
        ), 
        bsTooltip("diff_volcano_params", 
                  title = "These are cut-offs beyond which the points (genomic bins) in the volcano plot will be colored and annotated as significantly more or less accessible. ", 
                  placement = "top", 
                  options = list(container = "body")),
        h4("Volcano plot of differential test results"),
        plotOutput("diff_volcano_plot", brush = "diff_volcano_plot_brush"), 
        bsTooltip("diff_volcano_plot", 
                  title = paste0("Each data point in the plot refers to a genomic bin. The plot shows the -log<sub>10</sub>", input$diff_volcano_y, " plotted against log<sub>2</sub> fold change"), 
                  placement = "top", 
                  options = list(container = "body")),
        actionButton("diff_volcano_plot_download", "Download plot", 
                     class = "regular-btn"),
        hr(), 
        h4("Volcano plot brushed genomic bins"),
        uiOutput("diff_volcano_plot_brush_msg"),
        downloadButton("diff_volcano_plot_brushed_download", "Download brushed points table", 
                       class = "regular-btn"), 
        DT::dataTableOutput("diff_volcano_plot_brushed")
      )
    }
  })
  
  # Instructions on how to brush points
  output$diff_volcano_plot_brush_msg <- renderUI({
    if (is.null(input$diff_volcano_plot_brush)) {
      p("You can brush on the volcano plot (click and drag on plot) to see specific samples 
        information in a table. ")
    }
  })
  
  diff_volcano_plot <- reactive({
    req(input$diff_volcano_alpha)
    req(input$diff_volcano_logfc_threshold)
    if (input$diff_volcano_run_button > 0) {
      isolate({
        if (input$diff_volcano_y == 'FDR') {
          df <- data.frame(pvalue = - log10(diff_test_res()$FDR), 
                           logFC = diff_logfc())
        } else if (input$diff_volcano_y == 'p-value') {
          df <- data.frame(pvalue = - log10(diff_test_res()$pvalue), 
                           logFC = diff_logfc())
        }
        change <- rep('non-significant', length(diff_logfc()))
        change[(df$pvalue > - log10(input$diff_volcano_alpha)) & (df$logFC > input$diff_volcano_logfc_threshold)] <- 'more accessible'
        change[(df$pvalue > - log10(input$diff_volcano_alpha)) & (df$logFC < - input$diff_volcano_logfc_threshold)] <- 'less accessible'
        df$change <- change
        color <- c('red', 'blue', 'grey')
        names(color) <- c('more accessible', 'less accessible', 'non-significant')
        g <- ggplot(df, mapping = aes(x = logFC, y = pvalue, color = change))
        g <- g + geom_point()
        g <- g + scale_color_manual(values = color)
        g <- g + xlab(expression(log[2]*FC))
        if (input$diff_volcano_y == 'FDR') {
          g <- g + ylab(expression(-log[10]*FDR))
        } else if (input$diff_volcano_y == 'p-value') {
          g <- g + ylab(expression(-log[10]*pvalue))
        }
        # Remove grid lines and add axis lines
        g <- g + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                       panel.background = element_blank(), axis.line = element_line(colour = "black"))
        g
      })
    }
  })
  
  # Render differential test volcano plot
  output$diff_volcano_plot <- renderPlot({
    diff_volcano_plot()
  })
  
  observeEvent(input$diff_volcano_plot, {
    download_plot(diff_volcano_plot())
  })
  
  diff_volcano_plot_brushed_table <- reactiveVal()
  
  # Make volcano plot brushed points table
  observeEvent(input$diff_volcano_plot_brush, {
    if (input$diff_volcano_y == 'FDR') {
      df <- data.frame(genomic_bin = diff_test_res()$genomic_bin, 
                       pvalue = - log10(diff_test_res()$FDR), 
                       logFC = diff_logfc())
    } else if (input$diff_volcano_y == 'p-value') {
      df <- data.frame(genomic_bin = diff_test_res()$genomic_bin, 
                       pvalue = - log10(diff_test_res()$pvalue), 
                       logFC = diff_logfc())
    }
    df <- brushedPoints(df, input$diff_volcano_plot_brush)
    gbin_names <- df$genomic_bin
    df <- parse_gbin(gbin_names)
    brushed_gbin_tss <- gbin_tss()[gbin_names, ]
    brushed_gbin_snp <- gbin_snp()[gbin_names, ]
    df$nearest_gene <- as.factor(brushed_gbin_tss$gene)
    df$distance_to_gene <- brushed_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(brushed_gbin_tss$relative_position_to_tss)
    df$nearest_snp <- brushed_gbin_snp$snp_id
    df$snp_position <- brushed_gbin_snp$position
    df$snp_associated_trait <- brushed_gbin_snp[, 3]
    df$distance_to_snp <- brushed_gbin_snp$distance
    diff_volcano_plot_brushed_table(df)
    output$diff_volcano_plot_brushed <- DT::renderDataTable(df, 
                                                            rownames = FALSE,
                                                            filter = list(position = 'top', clear = FALSE), 
                                                            selection = 'single', 
                                                            options = list(scrollX = TRUE))
  })
  
  # Differential test volcano plot brushed points table file download
  output$diff_volcano_plot_brushed_download <- downloadHandler(
    filename = "Differential_test_volcano_brushed_points.txt", 
    content = function(file) {
      write.table(diff_volcano_plot_brushed_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render UI for choosing logFC cut-off
  output$diff_go_logfc_cut_ui <- renderUI({
    if (input$diff_go_use_logfc_cut) {
      wellPanel(
        fluidRow(
          column(
            4,
            selectInput(
              'diff_go_fc_from', 
              'Use fold change from group:', 
              c("", input$diff_select_sample_groups)
            )
          ), 
          column(
            4, 
            selectInput(
              'diff_go_fc_to', 
              'To group:', 
              c("", input$diff_select_sample_groups)
            )
          ),
          column(
            4, 
            uiOutput("diff_go_fc_confirm_ui")
          )
        ), 
        uiOutput("diff_go_logfc_cut_slider"), 
        radioButtons(
          "diff_go_use_which_sig_bins", 
          "Use genomic bins that are:", 
          choices = c("Both significantly more accessible and less accessible" = "both", 
                      "Significantly more accessible" = "more", 
                      "Significantly less accessible" = "less")
        )
      )
    }
  })
  
  output$diff_go_fc_confirm_ui <- renderUI({
    if ((input$diff_go_fc_from == "") || (input$diff_go_fc_to == "")) {
      p("Please select 2 groups for fold change calculation. ")
    } else if (input$diff_go_fc_from == input$diff_go_fc_to) {
      p("Selected groups cannot be the same group. Please select 2 different groups. ")
    } else {
      actionButton("diff_go_fc_confirm_groups", "Confirm groups", class = "important-btn")
    }
  })
  
  # Calculate fold change
  diff_go_logfc <- reactive({
    if ((! is.null(input$diff_go_fc_confirm_groups)) && (input$diff_go_fc_confirm_groups > 0)) {
      isolate({
        data <- pred_mat()[diff_test_res()$genomic_bin, ]
        logFC <- apply(data, 1, function(x) {
          mean(x[diff_sample_groups() == input$diff_go_fc_to]) - mean(x[diff_sample_groups() == input$diff_go_fc_from])
        })
        return(logFC)
      })
    }
  })
  
  output$diff_go_logfc_cut_slider <- renderUI({
    if ((! is.null(input$diff_go_fc_confirm_groups)) && (input$diff_go_fc_confirm_groups > 0)) {
      isolate({
        sliderInput(
          "diff_go_logfc_cut",
          "LogFC threshold: ", 
          max = max(abs(diff_go_logfc())), 
          min = 0, 
          value = min(1, max(abs(diff_go_logfc())))
        )
      })
    }
  })
  
  # Significant bins used for GO analysis
  diff_go_sig_bins <- reactive({
    significant_bins <- diff_test_res()
    if ((input$diff_go_use_logfc_cut) && (! is.null(input$diff_go_fc_confirm_groups)) && (input$diff_go_fc_confirm_groups > 0)) {
      if (input$diff_go_use_which_sig_bins == "both") {
        significant_bins <- significant_bins[abs(diff_go_logfc()) > input$diff_go_logfc_cut, ]
      } else if (input$diff_go_use_which_sig_bins == "less") {
        significant_bins <- significant_bins[diff_go_logfc() < - input$diff_go_logfc_cut, ]
      } else if (input$diff_go_use_which_sig_bins == "more") {
        significant_bins <- significant_bins[diff_go_logfc() > input$diff_go_logfc_cut, ]
      }
    }
    if (input$diff_go_alpha_var == "FDR") {
      significant_bins <- significant_bins[significant_bins$FDR < input$diff_go_alpha, 1]
    } else {
      significant_bins <- significant_bins[significant_bins$pvalue < input$diff_go_alpha, 1]
    }
    significant_bins
  })
  
  output$diff_go_gene_maxdist_ui <- renderUI({
    if ((!is.null(diff_test_res())) && (input$run_diff_test > 0)) {
      isolate({
        tagList(
          fluidRow(
            column(
              width = 8,
              # Select distance limit for mapping bins to nearest genes
              shinyWidgets::sliderTextInput(
                "diff_go_gene_maxdist", 
                "Maximum distance limit of bins to nearest gene TSS", 
                choices = c(100, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5 * c(1:10)), 
                post = "bp",
                selected = 500
              ),
              # sliderInput("diff_go_gene_maxdist", 
              #             "Maximum distance limit of bins to nearest gene TSS",
              #             min = 0, 
              #             max = 1e6, 
              #             value = 500, 
              #             post = "bp",
              #             step = 100), 
            ), 
            column(
              width = 4, 
              checkboxInput(
                "diff_go_show_gene_dist_plot", 
                "Show distribution of cluster bins distance to genes", 
                value = FALSE
              )
            )
          ),
          uiOutput("diff_go_gene_dist_plot_ui")
        )
      })
    }
  })
  
  output$diff_go_gene_dist_plot_ui <- renderUI({
    if (input$diff_go_show_gene_dist_plot) {
      tagList(
        plotlyOutput("diff_go_gene_dist_plot"), 
        #actionButton("diff_go_gene_dist_plot_download", "Download plot")
      )
    }
  })
  
  diff_go_nearest_genes <- reactive({
    gbin_names <- diff_go_sig_bins()
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    nearest_genes <- unique(sel_gbin_gene[sel_gbin_gene$distance <= input$diff_go_gene_maxdist, ]$gene)
    nearest_genes <- nearest_genes[! is.na(nearest_genes)]
    nearest_genes
  })
  
  diff_go_gene_dist_plot <- reactive({
    gbin_names <- diff_go_sig_bins()
    sel_gbin_gene <- gbin_tss()[gbin_names, ]
    sel_gbin_gene <- sel_gbin_gene[! is.na(sel_gbin_gene$distance), ]
    g <- ggplot(sel_gbin_gene, aes(x = distance))
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance <= input$diff_go_gene_maxdist, ], 
                            binwidth = 100, fill = "blue")
    g <- g + geom_histogram(data = sel_gbin_gene[sel_gbin_gene$distance > input$diff_go_gene_maxdist, ], 
                            binwidth = 100)
    g <- g + xlab("Distance from bin to nearest gene") + ylab("Count") 
    g <- g + ggtitle("Significant genomic bins distance distribution to nearest gene TSS")
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    ggplotly(g)
  })
  
  output$diff_go_gene_dist_plot <- renderPlotly({diff_go_gene_dist_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$diff_go_gene_dist_plot_download, {
    download_plotly(diff_go_gene_dist_plot())
  })
  
  # Render text message for number of significant bins and nearest genes
  output$diff_go_sig_genes_msg <- renderText({
    if (!is.null(diff_test_res())) {
      significant_bins <- diff_go_sig_bins()
      sig_genes <- diff_go_nearest_genes()
      paste("There are ", 
            length(significant_bins[! is.na(significant_bins)]), 
            "significant bins, which maps to", 
            length(sig_genes), 
            "nearest genes that will be used in GO term enrichment analysis. ")
    }
  })
  
  output$diff_go_external_tool_ui <- renderUI({
    if (input$diff_go_show_external_tool) {
      tagList(
        fluidRow(
          column(6, wellPanel(uiOutput("diff_go_ext_gene_func"))), 
          column(6, wellPanel(uiOutput("diff_go_ext_gbin_func"))), 
        )
      )
    }
  })
  
  output$diff_go_ext_gene_func <- renderUI({
    significant_bins <- diff_go_sig_bins()
    sig_genes <- diff_go_nearest_genes()
    sig_genes_text <- paste(sig_genes, collapse = "\n")
    if (sig_genes_text == "") {
      sig_genes_text <- " "
    }
    tagList(
      h4("Gene set analysis"), 
      actionButton(
        inputId = "diff_enrichr_link", 
        label = "Go to Enrichr", 
        onclick = "window.open('https://maayanlab.cloud/Enrichr/')", 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(),
      rclipButton(
        inputId = "diff_go_sig_genes_clipbtn", 
        label = "Copy significant genes", 
        clipText = sig_genes_text, 
        icon = icon("clipboard"), 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(), 
      downloadButton("diff_go_ext_genes_txt_download", "Download significant genes text file", 
                     style = "width: 100%; border: 1px solid white;", 
                     class = "regular-btn")
    )
  })
  
  output$diff_go_ext_gbin_func <- renderUI({
    showModal(modalDialog("Preparing significant bins BED file for external tools...", 
                          footer = NULL, easyClose = TRUE, size = "s"))
    df <- parse_gbin(diff_go_sig_bins())
    clip_bed <- paste(capture.output(write.table(df, 
                                                 col.names = FALSE, 
                                                 row.names = FALSE, 
                                                 quote = FALSE, 
                                                 sep = "\t")), 
                      collapse = "\n")
    if (clip_bed == "") {
      clip_bed <- " "
    }
    removeModal()
    tagList(
      h4("Genomic regions analysis"), 
      actionButton(
        inputId = "diff_great_link", 
        label = "Go to GREAT", 
        onclick = "window.open('https://great.stanford.edu/great/public/html/')", 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(),
      rclipButton(
        inputId = "diff_go_sig_gbins_clipbtn", 
        label = "Copy significant bins BED", 
        clipText = clip_bed, 
        icon = icon("clipboard"), 
        style = "width: 100%; border: 1px solid white;", 
        class = "regular-btn"
      ), 
      br(), 
      downloadButton("diff_go_ext_bed_download", "Download significant bins BED", 
                     style = "width: 100%; border: 1px solid white;", 
                     class = "regular-btn")
    )
  })
  
  output$diff_go_ext_genes_txt_download <- downloadHandler(
    filename = "Significant_genes.txt", 
    content = function(file) {
      significant_bins <- diff_go_sig_bins()
      sig_genes <- diff_go_nearest_genes()
      writeLines(sig_genes, file)
    }
  )
  
  output$diff_go_ext_bed_download <- downloadHandler(
    filename = "Significant_bins.bed", 
    content = function(file) {
      write.table(parse_gbin(diff_go_sig_bins()), 
                  file, 
                  col.names = FALSE, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # UI for significant bins table
  output$diff_go_sig_bins_table_ui <- renderUI({
    if (input$diff_go_show_sig_bins_table) {
      tagList(
        h4("Significant genomic bins and their nearest genes table"),
        downloadButton('diff_go_sig_bins_table_download', "Download significant bins and nearest genes table", 
                       class = "regular-btn"),
        DT::dataTableOutput('diff_go_sig_bins_table')
      )
    }
  })
  
  # Reactive significant bins table
  diff_go_sig_bins_table <- reactive({
    significant_bins <- diff_go_sig_bins()
    df <- parse_gbin(significant_bins)
    sig_gbin_tss <- gbin_tss()[significant_bins, ]
    df$nearest_gene <- as.factor(sig_gbin_tss$gene)
    df$distance_to_gene <- sig_gbin_tss$distance
    df$relative_position_to_tss <- as.factor(sig_gbin_tss$relative_position_to_tss)
    df
  })
  
  # Differential test significant bins and nearest genes file download
  output$diff_go_sig_bins_table_download <- downloadHandler(
    filename = "Significant_differential_bins_genes.txt", 
    content = function(file) {
      write.table(diff_go_sig_bins_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render table showing significant bins and nearest genes
  output$diff_go_sig_bins_table <- DT::renderDataTable(diff_go_sig_bins_table() %>%
                                                         datatable(rownames = FALSE,
                                                                   filter = list(position = 'top', clear = FALSE), 
                                                                   selection = "none", 
                                                                   options = list(scrollX = TRUE)))
  
  # Record whether there is no feasible GO terms found for current submission
  no_feasible_go_terms <- reactiveVal(FALSE)
  
  # Warning message when there is no feasible GO terms found for current submission
  output$no_feasible_go_terms_warning <- renderText({
    if (no_feasible_go_terms()) {
      paste("No enrichment can pe performed - no genes have feasible GO mapping. \nPlease include more genes. ")
    }
  })
  
  # Conditional MLE odds ratio calculation
  cond_or <- function(x) {
    m <- sum(x[, 1L])
    n <- sum(x[, 2L])
    k <- sum(x[1L, ])
    x <- x[1L, 1L]
    lo <- max(0L, k - n)
    hi <- min(k, m)
    
    support <- lo:hi #Interval of definition of Hypergeometric Distribution
    
    logdc <- dhyper(support, m, n, k, log = TRUE) #log of Hypergeometric Probability Function
    
    dnhyper <- function(ncp) {
      d <- logdc + log(ncp) * support
      d <- exp(d - max(d))
      d/sum(d)
    }
    
    mnhyper <- function(ncp) {
      if (ncp == 0) 
        return(lo)
      if (ncp == Inf) 
        return(hi)
      sum(support * dnhyper(ncp))
    }
    
    mle <- function(x) {
      if (x == lo) 
        return(0)
      if (x == hi) 
        return(Inf)
      mu <- mnhyper(1)
      if (mu > x) 
        uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
      else if (mu < x) 
        1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 
                                                  1))$root
      else 1
    }
    
    mle(x)
  }
  
  # Unconditional MLE odds ratio calculation
  uncond_or <- function(x) {
    x[1, 1] * x[2, 2] / (x[1, 2] * x[2, 1])
  }
  
  # Find top GO terms associated with genes near significant differential bins
  diff_top_go_terms <- reactive({
    if ((! is.null(input$run_diff_go)) && (input$run_diff_go > 0)) {
      isolate({
        showModal(modalDialog("Finding top GO terms...", footer = NULL, easyClose = TRUE, size = "s"))
        significant_bins <- diff_go_sig_bins()
        sig_genes <- diff_go_nearest_genes()
        ctrl_genes <- NULL
        if (input$diff_go_ctrl == "All genes near BIRD default prediction range") {
          ctrl_genes <- unique(gbin_tss()$gene)
        } else if (input$diff_go_ctrl == "All genes near selected genomic range") {
          ctrl_genes <- unique(gbin_tss()[rownames(pred_mat()), ]$gene)
        }
        ctrl_genes <- ctrl_genes[! is.na(ctrl_genes)]
        top_go_table <- gene_GO(sig_genes, ctrl_genes, top = input$diff_go_top_n, go_ontology = input$diff_go_ontology)
        if (is.null(top_go_table)) {
          no_feasible_go_terms(TRUE)
        } else {
          no_feasible_go_terms(FALSE)
        }
        removeModal()
        return(top_go_table)
      })
    }
  })
  
  # Render UI for selecting differential analysis results to display
  output$diff_go_sel_res_ui <- renderUI({
    if (! is.null(diff_top_go_terms())) {
      tagList(
        selectInput(
          'diff_go_sel_res', 
          'Select GO result to show: ', 
          c('Top GO terms table', 
            'GO terms p-value graph', 
            'GO terms FDR graph', 
            'Volcano plot', 
            'GO terms bar plot')
        ), 
        uiOutput('diff_go_res_ui')
      )
    }
  })
  
  # Render Ui for displaying GO analysis results
  output$diff_go_res_ui <- renderUI({
    if (input$diff_go_sel_res == 'Top GO terms table') {
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h4("Top GO terms table")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_table_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_table_info",
          title = "<h4>Top GO terms table</h4>",
          content = do.call(paste0, 
                            popover_contents()$go_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        br(),
        downloadButton('diff_go_table_download', "Download top GO terms table", 
                       class = "regular-btn"),
        DT::dataTableOutput("diff_go_table")
      )
    } else if (input$diff_go_sel_res == 'GO terms p-value graph') {
      tagList(
        sliderInput(
          'diff_go_pval_graph_alpha', 
          'Significance level', 
          min = 0.0001, 
          max = 1, 
          value = 0.05
        ), 
        # bsTooltip("diff_go_pval_graph_alpha", 
        #           title = "Control position of p-value threshold (dashed line)", 
        #           placement = "top", 
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms p-value graph")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_pval_graph_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_pval_graph_info",
          title = "<h4>GO terms p-value graph</h4>",
          content = do.call(paste0, 
                            popover_contents()$go_pval_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotlyOutput('diff_go_pval_graph'), 
        bsTooltip("diff_go_pval_graph", 
                  title = "Graph of -log<sub>10</sub>p-values vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ", 
                  placement = "top", 
                  options = list(container = "body")),
        #actionButton("diff_go_pval_graph_download", "Download plot"),
        hr(), 
        h4("GO terms p-value graph selected points"),
        uiOutput("diff_go_pval_graph_brush_msg"),
        DT::dataTableOutput('diff_go_pval_graph_brushed')
      )
    } else if (input$diff_go_sel_res == 'GO terms FDR graph') {
      tagList(
        sliderInput(
          'diff_go_fdr_graph_alpha', 
          'Significance level', 
          min = 0.0001, 
          max = 1, 
          value = 0.05
        ), 
        # bsTooltip("diff_go_fdr_graph_alpha", 
        #           title = "Control position of FDR threshold (dashed line)", 
        #           placement = "top", 
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms FDR graph")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_fdr_graph_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_fdr_graph_info",
          title = "<h4>GO terms FDR graph</h4>",
          content = do.call(paste0, 
                            popover_contents()$go_fdr_graph_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotlyOutput('diff_go_fdr_graph'), 
        bsTooltip("diff_go_fdr_graph", 
                  title = "Graph of -log<sub>10</sub>FDR vs. GO IDs. Size is proportional to annotation size. Click, hover, and select to interact with graph. ", 
                  placement = "top", 
                  options = list(container = "body")),
        #actionButton("diff_go_fdr_graph_download", "Download plot"),
        hr(), 
        h4("GO terms FDR graph selected points"),
        uiOutput("diff_go_fdr_graph_brush_msg"),
        DT::dataTableOutput('diff_go_fdr_graph_brushed')
      )
    } else if (input$diff_go_sel_res == 'Volcano plot') {
      max_odds_ratio <- max(diff_top_go_terms_df()$odds_ratio_pseudo[is.finite(diff_top_go_terms_df()$odds_ratio_pseudo)])
      tagList(
        tags$div(
          id = "diff_go_volcano_plot_params",
          fluidRow(
            column(6, 
                   sliderInput(
                     'diff_go_volcano_plot_alpha', 
                     'Significance level', 
                     min = 0.0001, 
                     max = 1, 
                     value = 0.05
                   )),
            column(6, 
                   sliderInput(
                     'diff_go_volcano_plot_or_threshold', 
                     'Odds ratio threshold',
                     min = 0, 
                     max = max_odds_ratio, 
                     value = min(1, max_odds_ratio)
                   ))
          )
        ),
        # bsTooltip("diff_go_volcano_plot_params", 
        #           title = "Adjust these cut-offs to color significant vs. non-significant GO terms differently in volcano plot. ", 
        #           placement = "top", 
        #           options = list(container = "body")),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms volcano plot")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_volcano_plot_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_volcano_plot_info",
          title = "<h4>GO terms volcano plot</h4>",
          content = do.call(paste0, 
                            popover_contents()$go_volcano_plot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotlyOutput('diff_go_volcano_plot'), 
        bsTooltip("diff_go_volcano_plot", 
                  title = "For each GO term, -log<sub>10</sub>p-value is plotted against odds ratio (computed with pseudo-count). ", 
                  placement = "top", 
                  options = list(container = "body")),
        #actionButton("diff_go_volcano_plot_download","Download plot")
      )
    } else if (input$diff_go_sel_res == 'GO terms bar plot') {
      tagList(
        radioButtons(
          "diff_go_barplot_var", 
          "Bar plot value: ", 
          choices = c("- log10 p-value" = "p-value", 
                      "- log10 FDR" = "FDR")
        ),
        fluidRow(
          column(
            width = 4, 
            radioButtons(
              "diff_go_barplot_sort_by", 
              label = "Sort bar plot by: ", 
              choices = c("Default order" = "default", 
                          "Decreasing value" = "decrease", 
                          "Increasing value" = "increase", 
                          "Custom order" = "custom")
            )
          ), 
          column(
            width = 8, 
            uiOutput("diff_go_barplot_sort_details_ui")
          )
        ), 
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "diff_go_barplot_top_cut", 
              "Number of top GO terms to show: ", 
              min = 2, 
              max = nrow(diff_top_go_terms()), 
              value = min(10, nrow(diff_top_go_terms())), 
              step = 1
            )
          ), 
          column(
            width = 4, 
            sliderInput(
              "diff_go_barplot_bar_width", 
              "Bar width: ", 
              min = 0.1, 
              max = 1.0, 
              value = 0.5,
              step = 0.1
            )
          ),
          column(
            width = 4, 
            uiOutput("diff_go_barplot_xlim_ui")
          )
        ),
        checkboxInput(
          "diff_go_barplot_show_des", 
          "Show GO term descriptions", 
          value = FALSE
        ),
        uiOutput("diff_go_barplot_des_details_ui"),
        div(style = "display: inline-block;vertical-align: middle;", h4("GO terms bar plot")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "go_barplot_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "go_barplot_info",
          title = "<h4>GO terms bar plot</h4>",
          content = do.call(paste0, 
                            popover_contents()$go_barplot_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        plotOutput("diff_go_barplot"), 
        actionButton("diff_go_barplot_download", "Download plot", 
                     class = "regular-btn")
      )
    }
  })
  
  # Render UI for bar plot xlim
  output$diff_go_barplot_xlim_ui <- renderUI({
    req(input$diff_go_barplot_var)
    req(input$diff_go_barplot_sort_by)
    req(input$diff_go_barplot_top_cut)
    # Set bar values
    if (input$diff_go_barplot_var == "p-value") {
      value <- - log10(diff_top_go_terms()$pvalue)
    } else if (input$diff_go_barplot_var == "FDR") {
      value <- - log10(diff_top_go_terms()$FDR)
    }
    sliderInput(
      "diff_go_barplot_xlim", 
      "Minimum x value: ", 
      min = 0, 
      max = min(value), 
      value = min(value) - (max(value) - min(value)) / 3
    )
  })
  
  # Render UI for bar plot show description details
  output$diff_go_barplot_des_details_ui <- renderUI({
    if (input$diff_go_barplot_show_des) {
      wellPanel(
        fluidRow(
          column(
            width = 4, 
            sliderInput(
              "diff_go_barplot_show_des_size", 
              "GO term description font size", 
              min = 1, 
              max = 10, 
              value = 4
            )
          ),
          column(
            width = 4, 
            radioButtons(
              "diff_go_barplot_show_des_opt", 
              "GO description display options", 
              choices = c("Show full description", 
                          "Show truncated description", 
                          "Split description into multiple lines")
            )
          ), 
          column(
            width = 4, 
            uiOutput("diff_go_barplot_show_des_opt_format")
          )
        )
      )
    }
  })
  
  # Render UI for bar plot GO description formatting options
  output$diff_go_barplot_show_des_opt_format <- renderUI({
    if (input$diff_go_barplot_show_des_opt == "Show truncated description") {
      tagList(
        radioButtons(
          "diff_go_barplot_des_trim_mode", 
          "Truncation mode: ", 
          choices = c("Fixed length", "Proportional to bar length"), 
          selected = "Fixed length"
        ), 
        sliderInput(
          "diff_go_barplot_des_trim_len", 
          "Truncation length: ", 
          min = 0, max = 1, value = 0.8, step = 0.01
        )
      )
    } else if (input$diff_go_barplot_show_des_opt == "Split description into multiple lines") {
      tagList(
        radioButtons(
          "diff_go_barplot_des_split_mode", 
          "Split mode: ", 
          choices = c("Fixed line length", "Line length proportional to bar length"),
          selected = "Fixed line length"
        ), 
        sliderInput(
          "diff_go_barplot_des_split_len", 
          "Line length: ", 
          min = 0, max = 1, value = 0.5, step = 0.01
        )
      )
    }
  })
  
  # Render UI for bar plot sort details
  output$diff_go_barplot_sort_details_ui <- renderUI({
    if (input$diff_go_barplot_sort_by == "custom") {
      fluidRow(
        column(
          width = 6, 
          radioButtons(
            "diff_go_barplot_custom_sort_method", 
            "Input custom order by: ", 
            choices = c("Text input", 
                        "Drag to sort")
          )
        ), 
        column(
          width = 6, 
          uiOutput("diff_go_barplot_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for GO bar plot custom sorting options
  output$diff_go_barplot_custom_sort_ui <- renderUI({
    if (input$diff_go_barplot_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "diff_go_barplot_custom_sort_text", 
          "Input GO IDs separated by line breaks: "
        ),
        fileInput(
          "diff_go_barplot_custom_sort_txt_file", 
          "Upload txt file indicating sort order", 
          accept = "text/plain"
        ),
        actionButton("submit_diff_go_barplot_custom_sort", "Confirm order", 
                     class = "regular-btn"), 
        textOutput("diff_go_barplot_custom_sort_submission_text")
      )
    } else if (input$diff_go_barplot_custom_sort_method == "Drag to sort") {
      actionButton("diff_go_barplot_custom_sort_drag_button", "Sort samples", 
                   class = "regular-btn")
    }
  })
  
  # Update GO bar plot custom sort text area input value based on uploaded file
  observeEvent(input$diff_go_barplot_custom_sort_txt_file, {
    if (! is.null(input$diff_go_barplot_custom_sort_txt_file)) {
      go_sort_text <- paste(readLines(input$diff_go_barplot_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "diff_go_barplot_custom_sort_text", 
        value = go_sort_text
      )
    }
  })
  
  # Disease bar plot custom order value
  diff_go_barplot_custom_order <- reactiveVal()
  
  # Update default custom order when GO results are computed
  observeEvent(diff_top_go_terms(), {
    diff_go_barplot_custom_order(diff_top_go_terms()$GO.ID)
  })
  
  # Render pop-up modal for GO bar plot custom drag sort
  observeEvent(input$diff_go_barplot_custom_sort_drag_button, {
    if (is.null(diff_go_barplot_custom_order())) {
      go_order <- diff_top_go_terms()$GO.ID
    } else {
      go_order <- diff_go_barplot_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = go_order,
      input_id = "go_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("submit_diff_go_barplot_custom_sort", "Confirm order", 
                     class = "regular-btn"), 
        textOutput("diff_go_barplot_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for GO bar plot custom sort
  output$diff_go_barplot_custom_sort_submission_text <- renderText({
    diff_go_barplot_custom_sort_submission_text()
  })
  
  # Process GO bar plot custom sort request
  diff_go_barplot_custom_sort_submission_text <- eventReactive(input$submit_diff_go_barplot_custom_sort, {
    if (input$diff_go_barplot_custom_sort_method == "Text input") {
      # Read GO terms from submitted text
      go_terms <- unlist(strsplit(input$diff_go_barplot_custom_sort_text, split = "\n"))
      go_terms <- sapply(go_terms, function(go) {
        go <- gsub(" ", "", go)
        go <- gsub("\t", "", go)
        go
      })
      go <- go[go != ""]
      # Check for non-selected GO terms
      extra <- go_terms[! (go_terms %in% diff_top_go_terms()$GO.ID)]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected GO terms:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated GO terms
      counts <- sapply(diff_top_go_terms()$GO.ID, function(go) {
        sum(go_terms %in% go)
      })
      if (any(counts > 1)) {
        return(paste("The following GO terms are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing GO terms
      if (any(counts == 0)) {
        return(paste("The following GO terms are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      diff_go_barplot_custom_order(go_terms)
      return(paste("Sorting complete!"))
    } else if (input$diff_go_barplot_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      diff_go_barplot_custom_order(input$go_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  diff_go_barplot <- reactive({
    req(input$diff_go_barplot_xlim)
    # Set bar values
    if (input$diff_go_barplot_var == "p-value") {
      df <- data.frame(go_term = diff_top_go_terms()$GO.ID, 
                       go_des =  diff_top_go_terms()$Term, 
                       value = - log10(diff_top_go_terms()$pvalue))
    } else if (input$diff_go_barplot_var == "FDR") {
      df <- data.frame(go_term = diff_top_go_terms()$GO.ID, 
                       go_des =  diff_top_go_terms()$Term, 
                       value = - log10(diff_top_go_terms()$FDR))
    }
    # Sort barplot
    if (input$diff_go_barplot_sort_by == "decrease") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value)])
    } else if (input$diff_go_barplot_sort_by == "increase") {
      df$go_term <- factor(df$go_term, levels = df$go_term[order(df$value, decreasing = TRUE)])
    } else if (input$diff_go_barplot_sort_by == "custom") {
      df$go_term <- factor(df$go_term, levels = rev(diff_go_barplot_custom_order()))
    }
    # Top n bars cut-off
    df <- df[1:input$diff_go_barplot_top_cut, ]
    if (input$diff_go_barplot_show_des) {
      req(input$diff_go_barplot_show_des_opt)
      # Show GO descriptions
      # Get description lengths
      des_width <- sapply(df$go_des, function(des){
        strwidth(des, units = "inches", family = "sans")
      })
      if (input$diff_go_barplot_show_des_opt == "Show truncated description") {
        req(input$diff_go_barplot_des_trim_mode)
        req(input$diff_go_barplot_des_trim_len)
        abbrev_len <- strwidth("...", units = "inches", family = "sans")
        if (input$diff_go_barplot_des_trim_mode == "Fixed length") {
          trim_len <- rep(abbrev_len + input$diff_go_barplot_des_trim_len * (max(des_width) - abbrev_len), length(des_width))
          names(trim_len) <- df$go_des
        } else {
          bar_len <- df$value - input$diff_go_barplot_xlim
          max_len <- abbrev_len + input$diff_go_barplot_des_trim_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - abbrev_len)
          trim_len <- max_len * bar_len / (max(df$value) - input$diff_go_barplot_xlim)
          names(trim_len) <- df$go_des
        }
        # Trim terms
        trim_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= trim_len[term]) {
            return(term)
          } else {
            # Find approximate nchar to trim
            keep_nchar <- floor(nchar(term) * (trim_len[term] - abbrev_len) / des_width[term])
            while (strwidth(substring(term, 1, keep_nchar), units = "inches", family = "sans") > trim_len[term] - abbrev_len) {
              keep_nchar <- keep_nchar - 1
            }
            return(paste0(substring(term, 1, keep_nchar), "..."))
          }
        })
        df$go_des <- trim_terms
      } else if (input$diff_go_barplot_show_des_opt == "Split description into multiple lines") {
        req(input$diff_go_barplot_des_split_mode)
        req(input$diff_go_barplot_des_split_len)
        if (input$diff_go_barplot_des_split_mode == "Fixed line length") {
          min_len <- max(des_width) / 2
          line_len <- rep(min_len + input$diff_go_barplot_des_split_len * 
                            (max(des_width) - min_len), length(des_width))
          names(line_len) <- df$go_des
        } else {
          bar_len <- df$value - input$diff_go_barplot_xlim
          min_len <- max(des_width) / 2
          max_len <- min_len + input$diff_go_barplot_des_split_len * 
            (max(des_width / (bar_len + 0.01)) * max(bar_len + 0.01) - min_len)
          line_len <- sapply(df$go_des, function(term) {
            ratio <- bar_len[df$go_des == term] / (max(df$value) - input$diff_go_barplot_xlim)
            if ((max(df$value) - input$diff_go_barplot_xlim) == 0) {
              ratio <- 1
            }
            max_len * ratio
          })
          names(line_len) <- df$go_des
        }
        # Format terms
        format_terms <- sapply(df$go_des, function(term) {
          if (des_width[term] <= line_len[term]) {
            return(term)
          } else {
            # Find approximate nchar in a single line
            remain_term <- term
            split_lines <- c()
            line_nchar <- floor(nchar(term) * line_len[term] / des_width[term])
            while (strwidth(remain_term, units = "inches", family = "sans") > line_len[term] &&
                   ! -1 %in% unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))) {
              breaks <- unlist(gregexpr(pattern ="([^a-zA-Z0-9])", remain_term))
              breaks <- breaks[!(breaks + 1) %in% breaks]
              break_i <- if (length(breaks) && min(breaks) <= line_nchar) {
                which.max(breaks[breaks <= line_nchar])
              } else {1}
              while (strwidth(trimws(substring(remain_term, 1, breaks[break_i])), 
                              units = "inches", family = "sans") > line_len[term] &&
                     break_i > 1) {
                break_i <- break_i - 1
              }
              split_lines <- c(split_lines, trimws(substring(remain_term, 1, breaks[break_i])))
              remain_term <- trimws(substring(remain_term, breaks[break_i] + 1, ))
            }
            split_lines <- c(split_lines, remain_term)
            return(paste(split_lines, collapse = "\n"))
          }
        })
        df$go_des <- format_terms
      }
    }
    g <- ggplot(df, aes(x = go_term, y = value, fill = value))
    g <- g + xlab("GO terms")
    if (input$diff_go_barplot_var == "p-value") {
      g <- g + ylab('- log10 p-value')
      g <- g + labs(fill = '- log10 p-value')
    } else if (input$diff_go_barplot_var == "FDR") {
      g <- g + ylab('- log10 FDR')
      g <- g + labs(fill = '- log10 FDR')
    }
    g <- g + geom_bar(stat = 'identity', width = input$diff_go_barplot_bar_width) + theme_bw()
    g <- g + coord_flip(ylim = c(input$diff_go_barplot_xlim, max(df$value)))
    if (input$diff_go_barplot_show_des) {
      g <- g + geom_text(aes(x = go_term, y = input$diff_go_barplot_xlim,
                             label = go_des, hjust = "left"),
                         color = "white", lineheight = 0.7,
                         size = input$diff_go_barplot_show_des_size)
    }
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    return(g)
  })
  
  # Render GO bar plot
  output$diff_go_barplot <- renderPlot({
    diff_go_barplot()
  })
  
  observeEvent(input$diff_go_barplot_download, {
    download_plot(diff_go_barplot())
  })
  
  # Data frame of top GO terms with go column containing integer GO ids
  diff_top_go_terms_df <- reactive({
    if (! is.null(diff_top_go_terms())) {
      go_df <- as.data.frame.matrix(diff_top_go_terms())
      go_df$go <- as.integer(gsub("GO:", "", go_df$GO.ID))
      go_df
    }
  })
  
  diff_go_pval_graph <- reactive({
    if (! is.null(diff_top_go_terms())) {
      df <- data.frame(go = diff_top_go_terms_df()$go, 
                       GO.ID = diff_top_go_terms_df()$GO.ID,
                       logpvalue = - log10(as.numeric(diff_top_go_terms_df()$pvalue)), 
                       pvalue = diff_top_go_terms_df()$pvalue, 
                       annotated = diff_top_go_terms_df()$Annotated, 
                       term = diff_top_go_terms_df()$Term, 
                       fdr = diff_top_go_terms_df()$FDR, 
                       odds_ratio = diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df, 
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go, 
                     y = ~logpvalue, 
                     color = ~logpvalue, 
                     size = ~annotated, 
                     text = ~paste("GO id: ", GO.ID, 
                                   '<br>Annotated: ', annotated, 
                                   '<br>GO term: ', term, 
                                   '<br>FDR: ', fdr, 
                                   '<br>Odds ratio: ', odds_ratio, 
                                   '<br>p-value: ', pvalue), 
                     hoverinfo = 'text', 
                     source = "go_pval_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$diff_go_ontology)), 
                                         showticklabels = FALSE, 
                                         zeroline = FALSE), 
                            yaxis = list(title = '-log<sub>10</sub>pvalue'), 
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$diff_go_pval_graph_alpha),
                                y1 = - log10(input$diff_go_pval_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Render plot for GO terms p values
  output$diff_go_pval_graph <- renderPlotly({diff_go_pval_graph()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$diff_go_pval_graph_download, {
    download_plotly(diff_go_pval_graph())
  })
  
  # Instructions on how to brush points
  output$diff_go_pval_graph_brush_msg <- renderUI({
    if (is.null(event_data(event = "plotly_selected", 
                           source = "go_pval_graph",
                           session = shiny::getDefaultReactiveDomain()))) {
      p("You can brush on the p-value plot (use box select or lasso select tool 
      on upper right corner to select points) to see specific samples 
        information in a table. ")
    }
  })
  
  # Make GO terms p-value plotly graph brushed points table
  observeEvent({
    event_data(event = "plotly_selected", 
               source = "go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  },{
    go_selected <- event_data(event = "plotly_selected", 
                              source = "go_pval_graph",
                              session = shiny::getDefaultReactiveDomain())
    df <- diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
    output$diff_go_pval_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                             rownames = FALSE,
                                                             filter = list(position = 'top', clear = FALSE), 
                                                             selection = "none")
  })
  
  # Show detailed info modal on GO terms p-value graph click event
  observeEvent({
    event_data(event = "plotly_click", 
               source = "go_pval_graph",
               session = shiny::getDefaultReactiveDomain())
  }, {
    go_clicked <- event_data(event = "plotly_click", 
                             source = "go_pval_graph",
                             session = shiny::getDefaultReactiveDomain())
    go_info <- diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(diff_top_go_terms_df()) != 'go']
    go_info$gene <- gsub(",", "<br/>", go_info$gene)
    go_info <- t(go_info)
    rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
    rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
    rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
    output$diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info, 
                                                                               colnames = "", 
                                                                               selection = "none", 
                                                                               escape = FALSE))
    showModal(modalDialog(
      tagList(
        downloadButton("go_genes_download", "Download significant genes", 
                       class = "regular-btn"),
        DT::dataTableOutput("diff_go_graph_pt_details_table")
      ), 
      easyClose = TRUE
    ))
  })
  
  diff_go_fdr_graph <- reactive({
    if (! is.null(diff_top_go_terms())) {
      df <- data.frame(go = diff_top_go_terms_df()$go, 
                       GO.ID = diff_top_go_terms_df()$GO.ID, 
                       logfdr = - log10(as.numeric(diff_top_go_terms_df()$FDR)), 
                       pvalue = diff_top_go_terms_df()$pvalue, 
                       annotated = diff_top_go_terms_df()$Annotated, 
                       term = diff_top_go_terms_df()$Term, 
                       fdr = diff_top_go_terms_df()$FDR, 
                       odds_ratio = diff_top_go_terms_df()$odds_ratio_conditional)
      fig <- plot_ly(data = df, 
                     type = 'scatter',
                     mode = 'markers',
                     x = ~go, 
                     y = ~logfdr, 
                     color = ~logfdr, 
                     size = ~annotated, 
                     text = ~paste("GO id: ", GO.ID, 
                                   '<br>Annotated: ', annotated, 
                                   '<br>GO term: ', term, 
                                   '<br>FDR: ', fdr, 
                                   '<br>Odds ratio: ', odds_ratio, 
                                   '<br>p-value: ', pvalue), 
                     hoverinfo = 'text', 
                     source = "go_fdr_graph")
      # Hide color scale
      fig <- fig %>% hide_colorbar()
      fig <- fig %>% layout(xaxis = list(title = paste0('GO:', isolate(input$diff_go_ontology)), 
                                         showticklabels = FALSE, 
                                         zeroline = FALSE), 
                            yaxis = list(title = '-log<sub>10</sub>FDR'), 
                            shapes = list(
                              # Horizontal line
                              list(
                                type = "line",
                                x0 = 0,
                                x1 = 1,
                                xref = "paper",
                                y0 = - log10(input$diff_go_fdr_graph_alpha),
                                y1 = - log10(input$diff_go_fdr_graph_alpha),
                                line = list(color = 'blue', dash = 'dot')
                              )
                            ))
      fig
    }
  })
  
  # Render plot for GO terms FDR
  output$diff_go_fdr_graph <- renderPlotly({diff_go_fdr_graph()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$diff_go_fdr_graph_download, {
    download_plotly(diff_go_fdr_graph())
  })
  
  # Instructions on how to brush points
  output$diff_go_fdr_graph_brush_msg <- renderUI({
    if (is.null(event_data(event = "plotly_selected", 
                           source = "go_fdr_graph",
                           session = shiny::getDefaultReactiveDomain()))) {
      p("You can brush on the FDR plot (use box select or lasso select tool 
      on upper right corner to select points) to see specific samples 
        information in a table. ")
    }
  })
  
  # Make GO terms FDR plotly graph brushed points table
  observeEvent(
    suppressWarnings(event_data(event = "plotly_selected", 
                                source = "go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())), 
    {
      go_selected <- event_data(event = "plotly_selected", 
                                source = "go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())
      df <- diff_top_go_terms_df()[go_selected$pointNumber + 1, ]
      output$diff_go_fdr_graph_brushed <- DT::renderDataTable(subset(df, select = -c(go)),
                                                              rownames = FALSE,
                                                              filter = list(position = 'top', clear = FALSE), 
                                                              selection = "none")
    })
  
  # Show detailed info modal on GO terms FDR graph click event
  observeEvent(
    suppressWarnings(event_data(event = "plotly_click", 
                                source = "go_fdr_graph",
                                session = shiny::getDefaultReactiveDomain())),
    {
      go_clicked <- event_data(event = "plotly_click", 
                               source = "go_fdr_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(diff_top_go_terms_df()) != 'go']
      go_info$gene <- gsub(",", "<br/>", go_info$gene)
      go_info <- t(go_info)
      rownames(go_info)[rownames(go_info) == 'gene'] <- 'Significant genes'
      rownames(go_info)[rownames(go_info) == 'pvalue'] <- 'p-value'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_conditional'] <- 'Odds ratio (estimated by conditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_unconditional'] <- 'Odds ratio (estimated by unconditional MLE)'
      rownames(go_info)[rownames(go_info) == 'odds_ratio_pseudo'] <- 'Odds ratio (estimated by unconditional MLE with pseudocount of 0.5)'
      output$diff_go_graph_pt_details_table <- DT::renderDataTable(DT::datatable(go_info, 
                                                                                 colnames = "", 
                                                                                 selection = "none", 
                                                                                 escape = FALSE))
      showModal(modalDialog(
        tagList(
          downloadButton("go_genes_download", "Download significant genes", 
                         class = "regular-btn"),
          DT::dataTableOutput("diff_go_graph_pt_details_table")
        ), 
        easyClose = TRUE
      ))
    }
  )
  
  diff_go_volcano_plot <- reactive({
    if (! is.null(diff_top_go_terms())) {
      df <- data.frame(GO.ID = diff_top_go_terms_df()$GO.ID, 
                       logpvalue = - log10(as.numeric(diff_top_go_terms_df()$pvalue)), 
                       pvalue = diff_top_go_terms_df()$pvalue, 
                       annotated = diff_top_go_terms_df()$Annotated, 
                       term = diff_top_go_terms_df()$Term, 
                       fdr = diff_top_go_terms_df()$FDR, 
                       odds_ratio = diff_top_go_terms_df()$odds_ratio_pseudo)
      # Only keep finite odds ratio rows
      df <- df[is.finite(df$odds_ratio), ]
      # Indicate significance in df
      df$significance <- rep("non-significant", nrow(df))
      df$significance[(df$pvalue < input$diff_go_volcano_plot_alpha) & (df$odds_ratio > input$diff_go_volcano_plot_or_threshold)] <- "significant"
      # Set colors
      pal <- c("grey", "blue")
      pal <- setNames(pal, c("non-significant", "significant"))
      fig <- plot_ly(type = 'scatter',
                     mode = 'markers', 
                     source = "go_volcano_plot", 
                     data = df, 
                     x = ~odds_ratio, 
                     y = ~logpvalue, 
                     color = ~significance, 
                     colors = pal,
                     text = ~paste("GO id: ", GO.ID, 
                                   '<br>Annotated: ', annotated, 
                                   '<br>GO term: ', term, 
                                   '<br>FDR: ', fdr, 
                                   '<br>Odds ratio: ', odds_ratio, 
                                   '<br>p-value: ', pvalue), 
                     hoverinfo = 'text')
      fig <- fig %>% layout(xaxis = list(title = 'Odds ratio'), 
                            yaxis = list(title = '-log<sub>10</sub>pvalue'))
      fig
    }
  })
  
  # Render GO terms volcano plot
  output$diff_go_volcano_plot <- renderPlotly({diff_go_volcano_plot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$diff_go_volcano_plot_download, {
    download_plotly(diff_go_volcano_plot())
  })
  
  # Download GO term significant genes in modal pop-up
  output$go_genes_download <- downloadHandler(
    filename = {
      go_clicked <- event_data(event = "plotly_click", 
                               source = "go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      paste0(diff_top_go_terms_df()[go_clicked$pointNumber + 1, 'GO.ID'], "_significant_genes.txt")
    }, 
    content = function(file) {
      go_clicked <- event_data(event = "plotly_click", 
                               source = "go_pval_graph",
                               session = shiny::getDefaultReactiveDomain())
      go_info <- diff_top_go_terms_df()[go_clicked$pointNumber + 1, colnames(diff_top_go_terms_df()) != 'go']
      write.table(unlist(strsplit(go_info$gene, ",")), 
                  file, 
                  row.names = FALSE, 
                  col.names = FALSE,
                  quote = FALSE)
    }
  )
  
  # Differential test top GO terms download
  output$diff_go_table_download <- downloadHandler(
    filename = "Top_GO_terms.txt", 
    content = function(file) {
      write.table(diff_top_go_terms(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render significant differential bins nearest genes associated top GO terms table
  output$diff_go_table <- DT::renderDataTable({
    if (! is.null(diff_top_go_terms())) {
      diff_top_go_terms() %>% 
        datatable(rownames = FALSE,
                  filter = list(position = 'top', clear = FALSE), 
                  selection = "none", 
                  options = list(scrollX = TRUE)) %>%
        formatRound(columns=c('pvalue', 'FDR', "odds_ratio_conditional", 
                              "odds_ratio_unconditional", "odds_ratio_pseudo"), 
                    digits=4)
    }
  })
  
  output$gtex_snp_page_ui <- renderUI({
    tagList(
      div(style = "display: inline-block;vertical-align: middle;", h2("GTEx tissues SNPs")), 
      div(style = "display: inline-block;vertical-align: middle;", 
          bsButton(
            "gtex_page_info", 
            label = "", 
            icon = icon("info"), 
            style = "info", 
            size = "extra-small"
          )), 
      bsPopover(
        id = "gtex_page_info",
        title = "<h3>GTEx tissues SNPs</h3>",
        content = do.call(paste0, 
                          popover_contents()$gtex_page_info),
        placement = "right",
        trigger = "focus",
        options = list(container = "body", 
                       html = TRUE)
      ),
      sidebarLayout(
        sidebarPanel(
          div(style = "display: inline-block;vertical-align: middle;", h3("Heatmap settings")), 
          div(style = "display: inline-block;vertical-align: middle;", 
              bsButton(
                "gtex_heatmap_settings_info", 
                label = "", 
                icon = icon("info"), 
                style = "info", 
                size = "extra-small"
              )), 
          bsPopover(
            id = "gtex_heatmap_settings_info",
            title = "<h4>Heatmap settings</h4>",
            content = do.call(paste0, 
                              popover_contents()$gtex_heatmap_settings_info),
            placement = "right",
            trigger = "focus",
            options = list(container = "body", 
                           html = TRUE)
          ),
          actionButton("show_gtex_tissue_table", 
                       "Subset GTEx tissues", 
                       style = "width: 100%; border: 1px solid white;", 
                       class = "regular-btn"),
          actionButton("show_gtex_trait_table", 
                       "Subset traits", 
                       style = "width: 100%; border: 1px solid white;", 
                       class = "regular-btn"),
          fluidRow(
            column(
              6, 
              h4("Row parameters"), 
              radioButtons(
                "gtex_trait_heatmap_rowsort", 
                "Sort rows by:",
                c("Hierarchical clusters", "Default order")
              ), 
              uiOutput("gtex_trait_heatmap_row_dendro"), 
              uiOutput("gtex_trait_heatmap_row_show_label_ui"),
              checkboxInput(
                "gtex_trait_heatmap_scale", 
                "Scale rows", 
                value = TRUE
              ), 
            ), 
            column(
              6, 
              h4("Column parameters"), 
              radioButtons(
                "gtex_trait_heatmap_colsort", 
                "Sort columns by:",
                c("Hierarchical clusters", "Default order")
              ), 
              uiOutput("gtex_trait_heatmap_col_dendro"), 
              checkboxInput(
                "gtex_trait_heatmap_col_show_label", 
                "Show column labels", 
                value = TRUE
              )
            )
          ), 
          actionButton("update_gtex_heatmap", 
                       "Apply settings and update heatmap", 
                       style = "width: 100%; border: 1px solid white;", 
                       class = "important-btn")
        ), 
        mainPanel(
          plotlyOutput("gtex_trait_heatmap"), 
          #actionButton("gtex_trait_heatmap_download", "Download plot"),
          downloadButton("download_gtex_trait_table", "Download numeric table", 
                         class = "regular-btn")
        )
      )
    )
  })
  
  # Selected tissues index
  gtex_sel_tissues <- reactiveVal(c(1:31))
  
  output$gtex_tissue_table <- DT::renderDataTable(gtex_tissue_table(),
                                                  rownames = FALSE, 
                                                  filter = list(position = 'top', clear = FALSE), 
                                                  selection = list(mode = "multiple", 
                                                                   selected = gtex_sel_tissues()),
                                                  escape = FALSE)
  
  # Show gtex tissue selection modal 
  observeEvent(input$show_gtex_tissue_table, {
    showModal(
      modalDialog(
        div(style = "display: inline-block;vertical-align: middle;", h4("GTEx tissue selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("gtex_tissue_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "gtex_tissue_table_info",
          title = "<h4>GTEx tissue selection table</h4>",
          content = do.call(paste0,
                            popover_contents()$gtex_tissue_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        fluidRow(
          column(
            3, 
            actionButton(
              "gtex_tissue_table_sel_all", 
              "Select all", 
              width = "100%", 
              class = "regular-btn"
            )
          ), 
          column(
            3, 
            actionButton(
              "gtex_tissue_table_sel_none", 
              "Deselect all", 
              width = "100%", 
              class = "regular-btn"
            )
          )
        ),
        dataTableOutput("gtex_tissue_table"), 
        textOutput("gtex_tissue_sel_warning"),
        actionButton("update_gtex_tissue_sel", "Confirm selection", 
                     class = "regular-btn"),
        modalButton("Cancel"),
        size = "l", 
        footer = NULL
      )
    )
  })
  
  output$gtex_tissue_sel_warning <- renderText({
    if (length(input$gtex_tissue_table_rows_selected) <= 1) {
      return("You must select at least 2 tissues. ")
    }
  })
  
  # Make proxy for controlling selected rows
  gtex_tissue_table_proxy <- DT::dataTableProxy("gtex_tissue_table")
  
  # Select all of gtex tissue table
  observeEvent(input$gtex_tissue_table_sel_all, {
    gtex_tissue_table_proxy %>% selectRows(input$gtex_tissue_table_rows_all)
  })
  
  # Deselect all of gtex tissue table
  observeEvent(input$gtex_tissue_table_sel_none, {
    gtex_tissue_table_proxy %>% selectRows(NULL)
  })
  
  # Update gtex tissue selection
  observeEvent(input$update_gtex_tissue_sel, {
    # Check that at least 2 traits selected
    if (length(input$gtex_tissue_table_rows_selected) > 1) {
      gtex_sel_tissues(input$gtex_tissue_table_rows_selected)
      removeModal()
    }
  })
  
  # Selected tissues index
  gtex_sel_traits <- reactiveVal()
  
  observe({
    if (is.null(gtex_sel_traits())) {
      gtex_sel_traits(order(gtex_trait_table()$hypervar, decreasing = T)[1:2000])
    }
  })
  
  output$gtex_trait_table <- DT::renderDataTable(gtex_trait_table(),
                                                  rownames = FALSE, 
                                                  filter = list(position = 'top', clear = FALSE), 
                                                  selection = list(mode = "multiple", 
                                                                   selected = gtex_sel_traits()),
                                                  escape = FALSE)
  
  # Show gtex trait selection modal 
  observeEvent(input$show_gtex_trait_table, {
    showModal(
      modalDialog(
        div(style = "display: inline-block;vertical-align: middle;", h4("GTEx trait selection table")), 
        div(style = "display: inline-block;vertical-align: middle;", bsButton("gtex_trait_table_info", 
                                                                              label = "", 
                                                                              icon = icon("info"), 
                                                                              style = "info", 
                                                                              size = "extra-small")), 
        bsPopover(
          id = "gtex_trait_table_info",
          title = "<h4>GTEx trait selection table</h4>",
          content = do.call(paste0,
                            popover_contents()$gtex_trait_table_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body",
                         html = TRUE)
        ),
        fluidRow(
          column(
            3, 
            actionButton(
              "gtex_trait_table_sel_all", 
              "Select all", 
              width = "100%", 
              class = "regular-btn"
            )
          ), 
          column(
            3, 
            actionButton(
              "gtex_trait_table_sel_none", 
              "Deselect all", 
              width = "100%", 
              class = "regular-btn"
            )
          )
        ),
        dataTableOutput("gtex_trait_table"), 
        textOutput("gtex_trait_sel_warning"),
        actionButton("update_gtex_trait_sel", "Confirm selection", 
                     class = "regular-btn"),
        modalButton("Cancel"),
        size = "l", 
        footer = NULL
      )
    )
  })
  
  # Make proxy for controlling selected rows
  gtex_trait_table_proxy <- DT::dataTableProxy("gtex_trait_table")
  
  # Select all of gtex trait table
  observeEvent(input$gtex_trait_table_sel_all, {
    gtex_trait_table_proxy %>% selectRows(input$gtex_trait_table_rows_all)
  })
  
  # Deselect all of gtex trait table
  observeEvent(input$gtex_trait_table_sel_none, {
    gtex_trait_table_proxy %>% selectRows(NULL)
  })
  
  output$gtex_trait_sel_warning <- renderText({
    if (length(input$gtex_trait_table_rows_selected) <= 1) {
      return("You must select at least 2 traits. ")
    } else if (length(input$gtex_trait_table_rows_selected) > 2000) {
      return(paste("You selected", length(input$gtex_trait_table_rows_selected), 
                   "traits. You can only select up to 2000 traits. "))
    }
  })
  
  # Update gtex trait selection
  observeEvent(input$update_gtex_trait_sel, {
    # Check that at least 2 traits selected
    if ((length(input$gtex_trait_table_rows_selected) > 1) & (length(input$gtex_trait_table_rows_selected) <= 2000)) {
      gtex_sel_traits(input$gtex_trait_table_rows_selected)
      removeModal()
    }
  })
  
  # Render heatmap rows show label option
  output$gtex_trait_heatmap_row_show_label_ui <- renderUI({
    if (length(gtex_sel_traits()) <= 20) {
      checkboxInput("gtex_trait_heatmap_row_show_label", "Show row labels", value = TRUE)
    }
  })
  
  # Render heatmap rows show dendrogram option
  output$gtex_trait_heatmap_row_dendro <- renderUI({
    req(input$gtex_trait_heatmap_rowsort)
    if (input$gtex_trait_heatmap_rowsort == "Hierarchical clusters") {
      checkboxInput(
        "gtex_trait_heatmap_row_show_dendro", 
        "Show row clusters dendrogram", 
        value = TRUE
      )
    }
  })
  
  # Render heatmap columns show dendrogram option
  output$gtex_trait_heatmap_col_dendro <- renderUI({
    req(input$gtex_trait_heatmap_colsort)
    if (input$gtex_trait_heatmap_colsort == "Hierarchical clusters") {
      checkboxInput(
        "gtex_trait_heatmap_col_show_dendro", 
        "Show column clusters dendrogram", 
        value = TRUE
      )
    }
  })
  
  # gtex traits matrix for heatmap
  gtex_trait_mat <- reactiveVal()
  
  observe(
    if (is.null(gtex_trait_mat())) {
      gtex_trait_mat(gtex_trait())
    }
  )
  
  # gtex traits heatmap
  gtex_trait_heatmap <- reactiveVal(
    # readRDS("../app files/gtex_trait_heatmaply.rds")
    readRDS(url("http://jilab.biostat.jhsph.edu/software/PDDB/app_files/gtex_trait_heatmaply.rds"))
  )
  
  # Render gtex traits heatmap
  output$gtex_trait_heatmap <- renderPlotly({
    showModal(modalDialog("Making heatmap...", footer = NULL, easyClose = TRUE, size = "s"))
    ht <- gtex_trait_heatmap()
    removeModal()
    ht
  })
  
  # Update gtex traits matrix
  observeEvent(input$update_gtex_heatmap, {
    showModal(modalDialog("Making heatmap...", easyClose = TRUE, size = "s", footer = NULL))
    # Update matrix
    mat <- gtex_trait()
    if (input$gtex_trait_heatmap_scale) {
      mat <- scaled_gtex_trait()
    }
    mat <- mat[gtex_sel_traits(), gtex_sel_tissues()]
    gtex_trait_mat(mat)
    # Update heatmaply object
    dendro <- "none"
    if ((input$gtex_trait_heatmap_rowsort == "Hierarchical clusters") &&
        (input$gtex_trait_heatmap_colsort == "Hierarchical clusters")) {
      dendro <- "both"
    } else if (input$gtex_trait_heatmap_rowsort == "Hierarchical clusters") {
      dendro <- "row"
    } else if (input$gtex_trait_heatmap_colsort == "Hierarchical clusters") {
      dendro <- "column"
    }
    show_dendro <- c(F, F)
    if ((! is.null(input$gtex_trait_heatmap_row_show_dendro)) && 
        input$gtex_trait_heatmap_row_show_dendro) show_dendro[1] <- TRUE
    if ((! is.null(input$gtex_trait_heatmap_col_show_dendro)) && 
        input$gtex_trait_heatmap_col_show_dendro) show_dendro[2] <- TRUE
    rowlab <- FALSE
    if ((! is.null(input$gtex_trait_heatmap_row_show_label)) &&
        input$gtex_trait_heatmap_row_show_label) rowlab <- input$gtex_trait_heatmap_row_show_label
    gtex_trait_heatmap(heatmaply(mat, 
                                 dendrogram = dendro,
                                 show_dendrogram = show_dendro,
                                 showticklabels = c(input$gtex_trait_heatmap_col_show_label, rowlab)))
    removeModal()
  })
  
  # Update download_plot value on download plot button click
  observeEvent(input$gtex_trait_heatmap_download, {
    download_plotly(gtex_trait_heatmap())
  })
  
  # Download gtex traits matrix
  output$download_gtex_trait_table <- downloadHandler(
    filename = paste0("gtex_trait_table.txt"), 
    content = function(file) {
      write.table(gtex_trait_mat(), 
                  file, 
                  row.names = TRUE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  update_disease_sel <- reactiveVal()
  
  # Render disease snp analysis page ui
  output$disease_page_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to perform disease SNP analysis. ")
    } else {
      update_disease_sel(TRUE)
      tagList(
        div(style = "display: inline-block;vertical-align: middle;", h2("Disease SNP analysis")), 
        div(style = "display: inline-block;vertical-align: middle;", 
            bsButton(
              "snp_page_info", 
              label = "", 
              icon = icon("info"), 
              style = "info", 
              size = "extra-small"
            )), 
        bsPopover(
          id = "snp_page_info",
          title = "<h3>Disease SNP analysis</h3>",
          content = do.call(paste0, 
                            popover_contents()$snp_page_info),
          placement = "right",
          trigger = "focus",
          options = list(container = "body", 
                         html = TRUE)
        ),
        sidebarLayout(
          sidebarPanel(
            selectizeInput(
              "disease_sel", 
              "Select a disease/trait to investigate:", 
              choices = NULL, 
              multiple = TRUE
            ),
            actionButton(
              "show_disease_snp_table", 
              "Show disease associated SNPs table", 
              style = "width:100%;", 
              class = "regular-btn"
            ), 
            shinyWidgets::sliderTextInput(
              "disease_snp_ext", 
              "SNP window extension length:", 
              choices = c(100, 500, 1000, 5000, 1e4, 2e4, 5e4, 1e5, 1.5e5), 
              selected = 500
            ),
            textOutput("disease_snp_nbins_msg"),
            uiOutput("disease_nbins_server_warning"),
            actionButton("show_disease_snp_bins_table", "Show table of genomic bins covered by SNP windows", 
                         style = "width:100%;", 
                         class = "regular-btn"),
            downloadButton("disease_snp_bins_download", "Download BED file of genomic bins covered by SNP windows", 
                           style = "width:100%;", 
                           class = "regular-btn"), 
            uiOutput("disease_run_analysis_ui")
          ), 
          mainPanel(
            uiOutput("disease_res_ui")
          )
        )
      )
    }
  })
  
  output$disease_nbins_server_warning <- renderUI({
    is_local <- Sys.getenv('SHINY_PORT') == ""
    if (! is_local) {
      p("You can include up to 10,000 bins in your SNP windows on server. You can 
      also run this app from local R session to lift this limit.", 
      style = "color:red;")
    }
  })
  
  # Server-side selectize for disease_sel
  observeEvent(update_disease_sel(), {
    updateSelectizeInput(session, 'disease_sel', choices = unique(snp_gbin()$disease.trait), server = TRUE)
    update_disease_sel(NULL)
  })
  
  # Disease SNP table
  disease_snp_table <- reactive({
    tb <- snp_gbin()[snp_gbin()$disease.trait %in% input$disease_sel, ]
    tb$disease.trait <- as.factor(tb$disease.trait)
    tb$snp_id <- as.factor(tb$snp_id)
    tb$chromosome <- as.factor(tb$chromosome)
    # Reset disease SNP selection
    disease_snp_sel(NULL)
    tb
  })
  
  # Selected SNPs
  disease_snp_sel <- reactiveVal()
  
  # Render disease SNP table on button click
  observeEvent(input$show_disease_snp_table, {
    output$disease_snp_table <- DT::renderDataTable(disease_snp_table(), 
                                                    rownames = FALSE,
                                                    filter = list(position = 'top', clear = FALSE), 
                                                    selection = "multiple")
    showModal(
      modalDialog(
        downloadButton("disease_snp_table_download", "Download table", 
                       class = "regular-btn"),
        DT::dataTableOutput("disease_snp_table"), 
        actionButton("submit_disease_snp_sel", "Confirm SNP subset", 
                     class = "regular-btn"),
        textOutput("disease_snp_sel_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render disease SNP subset submission text
  output$disease_snp_sel_submission_text <- renderText({
    disease_snp_sel_submission_text()
  })
  
  # Update disease SNP selection results
  disease_snp_sel_submission_text <- eventReactive(input$submit_disease_snp_sel, {
    if (length(input$disease_snp_table_rows_selected) == 0) {
      return(paste("Failed: no SNP have been selected. "))
    }
    disease_snp_sel(disease_snp_table()[input$disease_snp_table_rows_selected, 'snp_id'])
    return(paste("Subset complete! "))
  })
  
  # Download disease SNP table
  output$disease_snp_table_download <- downloadHandler(
    filename = paste0(snp_gbin()$disease.trait, "_snp.txt"), 
    content = function(file) {
      write.table(disease_snp_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Genomic bins covered by SNP windows (as GRange object)
  disease_gbins <- reactiveVal()
  
  # SNP windows to genomic bins table
  disease_gbins_table <- reactiveVal(
    setNames(data.frame(matrix(ncol = 6, nrow = 0)), 
             c("disease_trait", "snp_id", "chromosome", "position", "covered_bin_start", "covered_bin_end"))
  )
  
  # Update disease_gbins and disease_gbins_table
  observe({
    disease_snps <- disease_snp_table()
    if (! is.null(disease_snp_sel())) {
      disease_snps <- disease_snp_table()[disease_snp_table()$snp_id %in% disease_snp_sel(), ]
    }
    snp_ranges <- GRanges(seqnames = disease_snps$chromosome, 
                          ranges = IRanges(start = disease_snps$position - input$disease_snp_ext, 
                                           end = disease_snps$position + input$disease_snp_ext))
    hits <- findOverlaps(snp_ranges, bird_ranges())
    disease_gbins(bird_ranges()[unique(hits@to)])
    gbin_hits <- bird_ranges()[hits@to]
    disease_gbins_table(data.frame(disease_trait = as.factor(disease_snps[hits@from, 'disease.trait']),
                                   snp_id = as.factor(disease_snps[hits@from, 'snp_id']), 
                                   chromosome = as.factor(disease_snps[hits@from, 'chromosome']), 
                                   position = disease_snps[hits@from, 'position'], 
                                   covered_bin_start = start(gbin_hits), 
                                   covered_bin_end = end(gbin_hits)))
  })
  
  # Text message for number of bins in SNP windows
  output$disease_snp_nbins_msg <- renderText({
    msg <- paste("There are", length(disease_gbins()), "genomic bins in your SNP windows.")
    msg
  })
  
  # Render SNP bins table on button click
  observeEvent(input$show_disease_snp_bins_table, {
    output$disease_snp_nbins_table <- DT::renderDataTable(disease_gbins_table(), 
                                                          rownames = FALSE,
                                                          filter = list(position = 'top', clear = FALSE), 
                                                          selection = "none")
    showModal(
      modalDialog(
        downloadButton("disease_snp_nbins_table_download", "Download table", 
                       class = "regular-btn"),
        DT::dataTableOutput("disease_snp_nbins_table"), 
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Download disease SNP bins table
  output$disease_snp_nbins_table_download <- downloadHandler(
    filename = "snp_bins.txt", 
    content = function(file) {
      write.table(disease_gbins_table(), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Download BED file for SNP covered bins
  output$disease_snp_bins_download <- downloadHandler(
    filename = "snp_windows.bed", 
    content = function(file) {
      disease_snps <- disease_snp_table()[disease_snp_table()$snp_id %in% disease_snp_sel(), ]
      write.table(data.frame(chromosome = disease_snps$chromosome, 
                             start = disease_snps$position - input$disease_snp_ext, 
                             end = disease_snps$position + input$disease_snp_ext), 
                  file, 
                  row.names = FALSE, 
                  col.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Render UI panel for disease run analysis button
  output$disease_run_analysis_ui <- renderUI({
    if (length(disease_gbins()) == 0) {
      p("There are no genomic bins in the SNP window. Please select more disease/trait 
        or use a larger SNP window extension. ", style = "color:red;")
    } else if ((length(disease_gbins()) > 10000) && (Sys.getenv('SHINY_PORT') != "")) {
      p("You have selected too many bins. You can include up to 10,000 
        bins in your SNP windows on server. You can also run this app from local 
        R session to lift this limit.", style = "color:red;")
    } else {
      actionButton("disease_run_analysis", "Run disease SNP analysis", 
                   style = "width:100%; border: 1px solid white;",
                   class = "important-btn")
    }
  })
  
  # Prediction matrix for disease bins
  disease_pred_mat <- reactive({
    req(nrow(selected_samples()) > 0)
    showModal(modalDialog('Retrieving sample predictions...', footer = NULL, easyClose = TRUE, size = "s"))
    database_pred_mat <- get_database_pred_mat(disease_gbins())
    if (sum(selected_samples()$read_from == "local") > 0) {
      local_pred_mat <- get_local_pred_mat(disease_gbins())
      if (ncol(database_pred_mat) > 0) {
        # Have both local and database samples
        pred_mat <- cbind(database_pred_mat, local_pred_mat)
      } else {
        # Only have local samples
        pred_mat <- local_pred_mat
      }
    } else {
      # Only have database samples
      pred_mat <- database_pred_mat
    }
    removeModal()
    pred_mat
  })
  
  sample_avgs <- reactive({
    req(nrow(selected_samples()) > 0)
    avgs <- numeric(nrow(selected_samples()))
    names(avgs) <- colnames(pred_mat)
    database_samples <- selected_samples()$sample[selected_samples()$read_from == "database"]
    local_samples <- selected_samples()$sample[selected_samples()$read_from == "local"]
    if (length(database_samples) > 0) {
      # Get means for database samples from pre-computed sample averages
      avgs[database_samples] <- database_sample_avgs()[database_samples]
    }
    if (length(local_samples) > 0) {
      local_pred_mat <- get_local_pred_mat(bird_ranges())
      # Compute means for local samples
      avgs[local_samples] <- colMeans(local_pred_mat)[local_samples]
    }
    avgs
  })
  
  # Disease mean and normalized mean tables
  disease_mean <- reactiveVal()
  disease_normalized_mean <- reactiveVal()
  
  # Run disease SNP analysis
  observeEvent(input$disease_run_analysis, {
    gbins_names <- paste0(disease_gbins_table()$chromosome, 
                          ' (', disease_gbins_table()$covered_bin_start, '-', 
                          disease_gbins_table()$covered_bin_end, ')')
    sel_disease <- unique(disease_gbins_table()$disease_trait)
    mean_table <- sapply(sel_disease, function(disease) {
      disease_gbin_names <- gbins_names[disease_gbins_table()$disease_trait == disease]
      colMeans(disease_pred_mat()[disease_gbin_names, , drop=F])
    })
    colnames(mean_table) <- sel_disease
    disease_mean(mean_table)
    sample_all_means <- sample_avgs()[colnames(disease_pred_mat())]
    names(sample_all_means) <- colnames(disease_pred_mat())
    normalized_mean_table <- t(sapply(colnames(disease_pred_mat()), function(sample) {
      mean_table[sample, ] / sample_all_means[sample]
    }))
    if (length(sel_disease) == 1) {
      normalized_mean_table <- matrix(normalized_mean_table, ncol = 1)
      rownames(normalized_mean_table) <- colnames(disease_pred_mat())
    } 
    colnames(normalized_mean_table) <- sel_disease
    disease_normalized_mean(normalized_mean_table)
  })
  
  # Render table for single disease/trait sample means
  output$disease_single_res_table <- DT::renderDataTable(data.frame(sample = rownames(disease_mean()), 
                                                                    snps_accessibility = disease_mean()[, 1], 
                                                                    normalized_snps_accessibility = disease_normalized_mean()[, 1]) %>% 
                                                           datatable(rownames = FALSE,
                                                                     filter = list(position = 'top', clear = FALSE), 
                                                                     selection = "none") %>%
                                                           formatRound(columns=c("snps_accessibility", "normalized_snps_accessibility"), digits=4))
  
  # Render table of disease/trait sample means
  output$disease_res_mean_table <- DT::renderDataTable(data.frame(sample = rownames(disease_mean()), 
                                                                  disease_mean()) %>%
                                                         datatable(rownames = FALSE,
                                                                   filter = list(position = 'top', clear = FALSE), 
                                                                   selection = "none", 
                                                                   options = list(scrollX = TRUE, 
                                                                                  autoWidth = TRUE, 
                                                                                  columnDefs = list(list(width = '200px', targets = "_all")))) %>%
                                                         formatRound(columns=2:(ncol(disease_mean()) + 1), digits=4))
  
  # Render table of disease/trait sample normalized means
  output$disease_res_normalized_mean_table <- DT::renderDataTable(data.frame(sample = rownames(disease_normalized_mean()), 
                                                                             disease_normalized_mean()) %>%
                                                                    datatable(rownames = FALSE,
                                                                              filter = list(position = 'top', clear = FALSE), 
                                                                              selection = "none", 
                                                                              options = list(scrollX = TRUE, 
                                                                                             autoWidth = TRUE,
                                                                                             columnDefs = list(list(width = '200px', targets = "_all")))) %>%
                                                                    formatRound(columns=2:(ncol(disease_normalized_mean()) + 1), digits=4))
  
  # Render UI panel for disease SNP analysis results
  output$disease_res_ui <- renderUI({
    if ((! is.null(input$disease_run_analysis)) && (input$disease_run_analysis > 0)) {
      isolate({
        if (length(unique(disease_gbins_table()$disease_trait)) == 1) {
          # For single disease/trait selection
          tabsetPanel(
            tabPanel(
              style = "margin-bottom:50px; margin-top:50px;",
              title = "Result table", 
              div(style = "display: inline-block;vertical-align: middle;", h4("Disease SNP accessibility table")), 
              div(style = "display: inline-block;vertical-align: middle;", bsButton("disease_single_res_table_info", 
                                                                                    label = "", 
                                                                                    icon = icon("info"), 
                                                                                    style = "info", 
                                                                                    size = "extra-small")), 
              bsPopover(
                id = "disease_single_res_table_info",
                title = "<h4>Disease SNP accessibility table</h4>",
                content = do.call(paste0,
                                  popover_contents()$disease_single_res_table_info),
                placement = "right",
                trigger = "focus",
                options = list(container = "body",
                               html = TRUE)
              ),
              br(),
              downloadButton("download_disease_single_res", "Download result table", 
                             class = "regular-btn"),
              DT::dataTableOutput("disease_single_res_table")
            ), 
            tabPanel(
              style = "margin-bottom:50px; margin-top:50px;",
              title = "Bar plot", 
              radioButtons(
                "disease_barplot_var", 
                "", 
                choices = list("Normalized mean log2 predicted accessibility" = "normalized_mean",
                               "Mean log2 predicted accessibility" = "mean")
              ), 
              fluidRow(
                column(
                  width = 4, 
                  radioButtons(
                    "disease_barplot_sort_by", 
                    label = "Sort bar plot rows by: ", 
                    choices = c("Default order" = "default", 
                                "Decreasing accessibility" = "decrease", 
                                "Increasing accessibility" = "increase", 
                                "Custom order" = "custom")
                  )
                ), 
                column(
                  width = 8, 
                  uiOutput("disease_barplot_sort_details_ui")
                )
              ), 
              h4("Disease SNPs accessibility bar plot"),
              plotlyOutput("disease_barplot"), 
              #actionButton("disease_barplot_download", "Download plot")
            ),
            tabPanel(
              style = "margin-bottom:50px; margin-top:50px;",
              title = "Heat map", 
              uiOutput("disease_heatmap_ui")
            )
          )
        } else {
          # For multiple disease/traits
          tabsetPanel(
            tabPanel(
              style = "margin-bottom:50px; margin-top:50px;",
              title = "Result table", 
              div(style = "display: inline-block;vertical-align: middle;", h4("Disease SNP mean accessibility table")), 
              div(style = "display: inline-block;vertical-align: middle;", bsButton("disease_multi_res_table_info", 
                                                                                    label = "", 
                                                                                    icon = icon("info"), 
                                                                                    style = "info", 
                                                                                    size = "extra-small")), 
              bsPopover(
                id = "disease_multi_res_table_info",
                title = "<h4>Disease SNP mean accessibility table</h4>",
                content = do.call(paste0,
                                  popover_contents()$disease_multi_res_table_info),
                placement = "right",
                trigger = "focus",
                options = list(container = "body",
                               html = TRUE)
              ),
              br(),
              downloadButton("download_disease_res_mean", "Download mean table", 
                             class = "regular-btn"),
              DT::dataTableOutput("disease_res_mean_table"),
              hr(),
              div(style = "display: inline-block;vertical-align: middle;", h4("Disease SNP normalized mean accessibility table")), 
              div(style = "display: inline-block;vertical-align: middle;", bsButton("disease_multi_norm_res_table_info", 
                                                                                    label = "", 
                                                                                    icon = icon("info"), 
                                                                                    style = "info", 
                                                                                    size = "extra-small")), 
              bsPopover(
                id = "disease_multi_norm_res_table_info",
                title = "<h4>Disease SNP normalized mean accessibility table</h4>",
                content = do.call(paste0,
                                  popover_contents()$disease_multi_norm_res_table_info),
                placement = "right",
                trigger = "focus",
                options = list(container = "body",
                               html = TRUE)
              ),
              br(),
              downloadButton("download_disease_res_normalized_mean", "Download normalized mean table", 
                             class = "regular-btn"),
              DT::dataTableOutput("disease_res_normalized_mean_table")
            ), 
            tabPanel(
              style = "margin-bottom:50px; margin-top:50px;",
              title = "Disease/trait heat map", 
              radioButtons(
                "disease_heatmap_var", 
                "", 
                choices = list("Normalized mean log2 predicted accessibility" = "normalized_mean",
                               "Mean log2 predicted accessibility" = "mean")
              ), 
              uiOutput("disease_heatmap_ui")
            )
          )
        }
      })
    }
  })
  
  # Render UI for bar plot sort details
  output$disease_barplot_sort_details_ui <- renderUI({
    if (input$disease_barplot_sort_by == "custom") {
      fluidRow(
        column(
          width = 6, 
          radioButtons(
            "disease_barplot_custom_sort_method", 
            "Input custom order by: ", 
            choices = c("Text input", 
                        "Drag to sort")
          )
        ), 
        column(
          width = 6, 
          uiOutput("disease_barplot_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for disease bar plot custom sorting options
  output$disease_barplot_custom_sort_ui <- renderUI({
    if (input$disease_barplot_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "disease_barplot_custom_sort_text", 
          "Input sample names separated by line breaks: "
        ),
        fileInput(
          "disease_barplot_custom_sort_txt_file", 
          "Upload txt file indicating sort order", 
          accept = "text/plain"
        ),
        actionButton("submit_disease_barplot_custom_sort", "Confirm order", 
                     class = "regular-btn"), 
        textOutput("disease_barplot_custom_sort_submission_text")
      )
    } else if (input$disease_barplot_custom_sort_method == "Drag to sort") {
      actionButton("disease_barplot_custom_sort_drag_button", "Sort samples", 
                   class = "regular-btn")
    }
  })
  
  # Update disease bar plot custom sort text area input value based on uploaded file
  observeEvent(input$disease_barplot_custom_sort_txt_file, {
    if (! is.null(input$disease_barplot_custom_sort_txt_file)) {
      sample_sort_text <- paste(readLines(input$disease_barplot_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "disease_barplot_custom_sort_text", 
        value = sample_sort_text
      )
    }
  })
  
  # Disease bar plot custom order value
  disease_barplot_custom_order <- reactiveVal()
  
  # Update default custom order when disease mean is calculated
  observeEvent(disease_mean(), {
    disease_barplot_custom_order(rownames(disease_mean()))
  })
  
  # Render pop-up modal for disease bar plot custom drag sort
  observeEvent(input$disease_barplot_custom_sort_drag_button, {
    if (is.null(disease_barplot_custom_order())) {
      samples_order <- rownames(disease_mean())
    } else {
      samples_order <- disease_barplot_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = samples_order,
      input_id = "samples_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("submit_disease_barplot_custom_sort", "Confirm order", 
                     class = "regular-btn"), 
        textOutput("disease_barplot_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for disease bar plot custom sort
  output$disease_barplot_custom_sort_submission_text <- renderText({
    disease_barplot_custom_sort_submission_text()
  })
  
  # Process disease bar plot custom sort request
  disease_barplot_custom_sort_submission_text <- eventReactive(input$submit_disease_barplot_custom_sort, {
    if (input$disease_barplot_custom_sort_method == "Text input") {
      # Read samples from submitted text
      samples <- unlist(strsplit(input$disease_barplot_custom_sort_text, split = "\n"))
      samples <- sapply(samples, function(sample) {
        sample <- gsub(" ", "", sample)
        sample <- gsub("\t", "", sample)
        sample
      })
      samples <- samples[samples != ""]
      # Check for non-selected samples
      extra <- samples[! (samples %in% rownames(disease_mean()))]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected samples:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated samples
      counts <- sapply(rownames(disease_mean()), function(sample) {
        sum(samples %in% sample)
      })
      if (any(counts > 1)) {
        return(paste("The following samples are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing samples
      if (any(counts == 0)) {
        return(paste("The following samples are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      disease_barplot_custom_order(samples)
      return(paste("Sorting complete!"))
    } else if (input$disease_barplot_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      disease_barplot_custom_order(input$samples_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  # Download single disease means table
  output$download_disease_single_res <- downloadHandler(
    filename = paste0(colnames(disease_mean()), "_means.txt"), 
    content = function(file) {
      write.table(data.frame(sample = rownames(disease_normalized_mean()), 
                             snps_accessibility = disease_mean()[, 1], 
                             normalized_snps_accessibility = disease_normalized_mean()[, 1]), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Download disease means table
  output$download_disease_res_mean <- downloadHandler(
    filename = "disease_trait_means.txt", 
    content = function(file) {
      write.table(data.frame(sample = rownames(disease_mean()), 
                             disease_mean()), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  # Download disease normalized means table
  output$download_disease_res_normalized_mean <- downloadHandler(
    filename = "disease_trait_normalized_means.txt", 
    content = function(file) {
      write.table(data.frame(sample = rownames(disease_normalized_mean()), 
                             disease_normalized_mean()), 
                  file, 
                  row.names = FALSE, 
                  quote = FALSE, 
                  sep = "\t")
    }
  )
  
  disease_barplot <- reactive({
    if (input$disease_barplot_var == "mean") {
      df <- data.frame(sample = rownames(disease_normalized_mean()), 
                       accessibility = disease_mean()[, 1])
    } else {
      df <- data.frame(sample = rownames(disease_normalized_mean()), 
                       accessibility = disease_normalized_mean()[, 1])
    }
    if (input$disease_barplot_sort_by == "decrease") {
      df$sample <- factor(df$sample, levels = df$sample[order(df$accessibility)])
    } else if (input$disease_barplot_sort_by == "increase") {
      df$sample <- factor(df$sample, levels = df$sample[order(df$accessibility, decreasing = TRUE)])
    } else if (input$disease_barplot_sort_by == "custom") {
      df$sample <- factor(df$sample, levels = rev(disease_barplot_custom_order()))
    }
    g <- ggplot(df, aes(x = sample, y = accessibility, fill = accessibility))
    if (input$disease_barplot_var == "mean") {
      g <- g + ylab('Mean log<sub>2</sub> accessibility')
      g <- g + labs(fill = 'Mean log<sub>2</sub> accessibility')
      g <- g + geom_bar(stat = 'identity', width = 0.5) + coord_flip() + theme_bw()
    } else if (input$disease_barplot_var == "normalized_mean") {
      g <- g + ylab('Normalized mean log<sub>2</sub> accessibility')
      g <- g + labs(fill = 'Normalized mean <br>log<sub>2</sub> accessibility')
      g <- g + geom_bar(stat = 'identity', width = 0.5) + coord_flip() + theme_bw()
    }
    g <- g + theme(strip.background = element_rect(colour = "white", fill = "white")) + 
      theme(panel.border = element_blank(), axis.line = element_line()) + 
      theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) + 
      theme(panel.background = element_rect(fill = "white"))
    p <- ggplotly(g) %>% style(hoverinfo = 'none')
    p
  })
  
  # Render disease bar plot
  output$disease_barplot <- renderPlotly({disease_barplot()})
  
  # Update download_plot value on download plot button click
  observeEvent(input$disease_barplot_download, {
    download_plotly(disease_barplot())
  })
  
  # Render UI panel for disease SNP heatmap results
  output$disease_heatmap_ui <- renderUI({
    if (nrow(selected_samples()) < 2) {
      p("You must select at least 2 samples to display a heatmap. ")
    } else {
      if (length(unique(disease_gbins_table()$disease_trait)) == 1) {
        # Single disease/trait heat map
        if (length(disease_gbins()) < 2) {
          p("There must be at least 2 genomic bins covered by SNP windows to display a heatmap. ")
        } else {
          tagList(
            sliderInput(
              "disease_heatmap_top_var", 
              label = "Number of top variance rows to include in heat map", 
              min = 1000, 
              max = 10000, 
              value = 2000, 
              step = 100
            ),
            radioButtons(
              "disease_heatmap_sort_by", 
              label = "Sort heat map rows by: ", 
              choices = c("Row clusters", 
                          "Decreasing variance", 
                          "Genomic position")
            ), 
            h4("Sample vs. disease genomic bins heatmap"),
            actionButton("disease_show_interactive_gbins_heatmap", "Show interactive heat map", 
                         class = "regular-btn"),
            plotOutput("disease_gbins_heat_map"), 
            actionButton("disease_gbins_heat_map_download", "Download plot", 
                         class = "regular-btn")
          )
        }
      } else {
        # Multiple disease/traits heat map
        sort_choices <- list("default", "decrease", "increase", "custom")
        if (input$disease_heatmap_var == "mean") {
          names(sort_choices) <- c("Sample clusters", 
                                   "Decreasing mean accessibility", 
                                   "Increasing mean accessibility", 
                                   "Custom order")
        } else {
          names(sort_choices) <- c("Sample clusters", 
                                   "Decreasing normalized mean accessibility", 
                                   "Increasing normalized mean accessibility", 
                                   "Custom order")
        }
        tagList(
          fluidRow(
            column(
              width = 4, 
              radioButtons(
                "disease_heatmap_sort_by", 
                label = "Sort heat map rows by: ", 
                choices = sort_choices
              )
            ), 
            column(
              width = 8, 
              uiOutput("disease_heatmap_sort_details_ui")
            )
          ), 
          h4("Sample vs. trait heatmap"),
          actionButton("disease_show_interactive_heatmap", "Show interactive heat map", 
                       class = "regular-btn"),
          plotOutput("disease_heat_map"), 
          actionButton("disease_heat_map_download", "Download plot", 
                       class = "regular-btn")
        )
      }
    }
  })
  
  # Render UI for heat map sort details
  output$disease_heatmap_sort_details_ui <- renderUI({
    if ((input$disease_heatmap_sort_by == "decrease") || (input$disease_heatmap_sort_by == "increase")) {
      selectInput(
        "disease_heatmap_sort_trait_sel", 
        "Sort heat map rows by accessibility for this trait: ", 
        choices = colnames(disease_mean())
      )
    } else if (input$disease_heatmap_sort_by == "custom") {
      fluidRow(
        column(
          width = 6, 
          radioButtons(
            "disease_heatmap_custom_sort_method", 
            "Input custom order by: ", 
            choices = c("Text input", 
                        "Drag to sort")
          )
        ), 
        column(
          width = 6, 
          uiOutput("disease_heatmap_custom_sort_ui")
        )
      )
    }
  })
  
  # Render UI for disease heat map custom sorting options
  output$disease_heatmap_custom_sort_ui <- renderUI({
    if (input$disease_heatmap_custom_sort_method == "Text input") {
      tagList(
        textAreaInput(
          "disease_heatmap_custom_sort_text", 
          "Input sample names separated by line breaks: "
        ),
        fileInput(
          "disease_heatmap_custom_sort_txt_file", 
          "Upload txt file indicating sort order", 
          accept = "text/plain"
        ),
        actionButton("submit_disease_heatmap_custom_sort", "Confirm order", 
                     class = "regular-btn"), 
        textOutput("disease_heatmap_custom_sort_submission_text")
      )
    } else if (input$disease_heatmap_custom_sort_method == "Drag to sort") {
      actionButton("disease_heatmap_custom_sort_drag_button", "Sort samples", 
                   class = "regular-btn")
    }
  })
  
  # Update disease heat map custom sort text area input value based on uploaded file
  observeEvent(input$disease_heatmap_custom_sort_txt_file, {
    if (! is.null(input$disease_heatmap_custom_sort_txt_file)) {
      sample_sort_text <- paste(readLines(input$disease_heatmap_custom_sort_txt_file$datapath), collapse = "\n")
      updateTextAreaInput(
        session, 
        "disease_heatmap_custom_sort_text", 
        value = sample_sort_text
      )
    }
  })
  
  # Disease heat map custom order value
  disease_heatmap_custom_order <- reactiveVal()
  
  # Update default custom order when disease mean is calculated
  observeEvent(disease_mean(), {
    disease_heatmap_custom_order(rownames(disease_mean()))
  })
  
  # Render pop-up modal for disease heat map custom drag sort
  observeEvent(input$disease_heatmap_custom_sort_drag_button, {
    if (is.null(disease_heatmap_custom_order())) {
      samples_order <- rownames(disease_mean())
    } else {
      samples_order <- disease_heatmap_custom_order()
    }
    samples_rank_list <- rank_list(
      text = "Drag to desired order (You can select multiple items, then drag as a group): ",
      labels = samples_order,
      input_id = "samples_rank_list",
      options = sortable_options(multiDrag = TRUE)
    )
    showModal(
      modalDialog(
        samples_rank_list,
        actionButton("submit_disease_heatmap_custom_sort", "Confirm order", 
                     class = "regular-btn"), 
        textOutput("disease_heatmap_custom_sort_submission_text"),
        size = 'l',
        easyClose = TRUE
      )
    )
  })
  
  # Render submission text for disease heat map custom sort
  output$disease_heatmap_custom_sort_submission_text <- renderText({
    disease_heatmap_custom_sort_submission_text()
  })
  
  # Process disease heat map custom sort request
  disease_heatmap_custom_sort_submission_text <- eventReactive(input$submit_disease_heatmap_custom_sort, {
    if (input$disease_heatmap_custom_sort_method == "Text input") {
      # Read samples from submitted text
      samples <- unlist(strsplit(input$disease_heatmap_custom_sort_text, split = "\n"))
      samples <- sapply(samples, function(sample) {
        sample <- gsub(" ", "", sample)
        sample <- gsub("\t", "", sample)
        sample
      })
      samples <- samples[samples != ""]
      # Check for non-selected samples
      extra <- samples[! (samples %in% rownames(disease_mean()))]
      if (length(extra) > 0) {
        return(paste("The following lines do not match any selected samples:", paste0(extra, collapse = ', ')))
      }
      # Check for repeated samples
      counts <- sapply(rownames(disease_mean()), function(sample) {
        sum(samples %in% sample)
      })
      if (any(counts > 1)) {
        return(paste("The following samples are repeated:", paste0(names(counts)[counts > 1]), collapse = ', '))
      }
      # Check for missing samples
      if (any(counts == 0)) {
        return(paste("The following samples are missing:", paste0(names(counts)[counts == 0]), collapse = ', '))
      }
      disease_heatmap_custom_order(samples)
      return(paste("Sorting complete!"))
    } else if (input$disease_heatmap_custom_sort_method == "Drag to sort") {
      # Read sample order from drag and drop list
      disease_heatmap_custom_order(input$samples_rank_list)
      return(paste("Sorting complete!"))
    }
  })
  
  # Render UI for showing specific SNPs in heat map
  output$disease_heatmap_snp_subset_ui <- renderUI({
    if (input$disease_heatmap_snp_subset) {
      snp_counts <- table(disease_gbins_table()$snp_id)
      selectInput(
        'disease_heatmap_snp_sel', 
        'Select a SNP:', 
        choices = c(names(snp_counts[snp_counts > 1]))
      )
    }
  })
  
  # Create genomic bins heat map object
  disease_gbins_heat_map <- reactive({
    if (length(disease_gbins()) < 2) {
      return(NULL)
    }
    filtered_pred_mat <- disease_pred_mat()
    if (! is.null(input$disease_heatmap_snp_sel)) {
      snp_gbins_info <- disease_gbins_table()[as.character(disease_gbins_table()$snp_id) == input$disease_heatmap_snp_sel, ]
      sel_gbins <- paste0(snp_gbins_info$chromosome, ' (', snp_gbins_info$covered_bin_start, '-', snp_gbins_info$covered_bin_end, ')')
      filtered_pred_mat <- filtered_pred_mat[sel_gbins, ,drop=F]
    }
    disease_pred_hypervar <- hypervar_bulk(filtered_pred_mat)
    n_top_var <- min(input$disease_heatmap_top_var, nrow(disease_pred_hypervar))
    top_var_idx <- base::sort(disease_pred_hypervar$hypervar, 
                              decreasing=TRUE, 
                              index.return=TRUE)$ix[1:n_top_var]
    
    # Filter prediction matrix by top variance rows
    pred_mat_sorted <- filtered_pred_mat[disease_pred_hypervar$feature[top_var_idx], ] # This is sorted by decreasing variance
    pred_mat_sorted_gbins <- rownames(pred_mat_sorted)
    
    # Make heat map
    showModal(modalDialog("Making heat map...", footer = NULL, easyClose = TRUE, size = "s"))
    if (input$disease_heatmap_sort_by == "Decreasing variance") {
      row.order <- order(1:nrow(pred_mat_sorted))
      cluster.rows <- FALSE
    } else if (input$disease_heatmap_sort_by == "Genomic position") {
      sorted_gbins <- disease_pred_hypervar$feature[base::sort(top_var_idx)] # Genomic bins sorted by genomic position
      row.order <- sapply(pred_mat_sorted_gbins, function(x) {
        which(sorted_gbins == x)
      })
      row.order <- order(row.order)
      cluster.rows <- FALSE
    } else {
      row.order <- NULL
      cluster.rows <- TRUE
    }
    ht <- Heatmap(pred_mat_sorted, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = "log2 predicted \nchromatin \naccessibility"))
    removeModal()
    return(draw(ht))
  })
  
  # Render genomic bins heat map
  output$disease_gbins_heat_map <- renderPlot({
    disease_gbins_heat_map()
  })
  
  observeEvent(input$disease_gbins_heat_map_download, {
    download_plot(disease_gbins_heat_map())
  })
  
  # Interactive heat map
  observeEvent(input$disease_show_interactive_gbins_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, disease_gbins_heat_map())
  })
  
  # Create disease heat map object
  disease_heat_map <- reactive({
    if (input$disease_heatmap_var == "mean") {
      df <- disease_mean()
      legend_title <- "Mean log2 predicted \naccessibility"
    } else {
      df <- disease_normalized_mean()
      legend_title <- "Normalized mean log2 \npredicted accessibility"
    }
    if (input$disease_heatmap_sort_by == "default") {
      cluster.rows <- TRUE
    } else {
      cluster.rows <- FALSE
    }
    row.order <- NULL
    if (input$disease_heatmap_sort_by == "custom") {
      row.order <- sapply(disease_heatmap_custom_order(), function(sample) {
        which(rownames(disease_mean()) == sample)
      })
    } else if ((! is.null(input$disease_heatmap_sort_trait_sel)) && 
               ((input$disease_heatmap_sort_by == "decrease") || 
                (input$disease_heatmap_sort_by == "increase"))) {
      decreasing <- input$disease_heatmap_sort_by == "decrease"
      row.order <- sort(df[, input$disease_heatmap_sort_trait_sel], 
                        decreasing = decreasing, 
                        index.return = TRUE)$ix
    }
    ht <- Heatmap(df, 
                  row_order = row.order, 
                  cluster_rows = cluster.rows,
                  heatmap_legend_param = list(title = legend_title))
    return(draw(ht))
  })
  
  # Render disease heat map
  output$disease_heat_map <- renderPlot({
    disease_heat_map()
  })
  
  observeEvent(input$disease_heat_map_download, {
    download_plot(disease_heat_map())
  })
  
  # Interactive heat map
  observeEvent(input$disease_show_interactive_heatmap, {
    InteractiveComplexHeatmapModal(input, output, session, disease_heat_map())
  })
  
  # Tutorial page
  output$tut_page_ui <- renderUI({
    if (input$tut_page_sel == "input_sel_tut") {
      uiOutput("tut_page_input_sel")
    } else if (input$tut_page_sel == "pca_pt_tut") {
      uiOutput("tut_page_pca_pt")
    } else if (input$tut_page_sel == "diff_group_tut") {
      uiOutput("tut_page_group_diff")
    } else if (input$tut_page_sel == "disease_snp_tut") {
      uiOutput("tut_page_disease_snp")
    } else if (input$tut_page_sel == "gtex_snp_tut") {
      uiOutput("tut_page_gtex_snp")
    }
  })
  
  # Input selection tutorial
  output$tut_page_input_sel <- renderUI({
    sidebarLayout(
      sidebarPanel(
        h3("Contents"), 
        hr(),
        a(href="#input_sel_sample_sel", class="content_link", h4("Sample selection")), 
        div(
          style = "margin-left:20px", 
          a(href="#input_sel_sample_sel_db", class="content_link", "Select from database"), 
          br(),
          a(href="#input_sel_sample_sel_loc", class="content_link", "Select from local path"), 
          br(),
          a(href="#input_sel_sample_sel_manage", class="content_link", "Manage current selection"), 
        ), 
        a(href="#input_sel_bin_sel", class="content_link", h4("Genomic ranges selection")), 
        div(
          style = "margin-left:20px", 
          a(href="#input_sel_bin_sel_default", class="content_link", "Default selection"), 
          br(),
          a(href="#input_sel_bin_sel_all", class="content_link", "Full genome selection"), 
          br(),
          a(href="#input_sel_bin_sel_manual", class="content_link", "Manual selection"), 
          br(),
          a(href="#input_sel_bin_sel_bed", class="content_link", "BED input selection")
        ),
        a(href="#input_sel_restriction", class="content_link", h4("Online server restrictions")),
        a(href="#pred_download", class="content_link", h4("Prediction download")),
        div(
          style = "margin-left:20px", 
          a(href="#pred_download_rds", class="content_link", "RDS download"), 
          br(),
          a(href="#pred_download_bw_ucsc", class="content_link", "BigWig and UCSC Genome Browser session file download"), 
          br(),
          a(href="#pred_download_txt", class="content_link", "Text download")
        ),
      ), 
      mainPanel(
        a(name = "input_sel_sample_sel"), 
        h2("Sample Selection"), 
        p("Go to Input Selection from navigation bar, and go to Select or upload sample tab. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_sample_sel_db"),
        h3("Select from database"),
        p("To select sample from database, select Select from prediction database from 
          the drop-down in the sidebar. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_db1.svg")
          )
        ),
        p("You need to first select projects from the database, and then select the samples 
          that you want to use as input to the prediction model. To select projects, 
          go to Step 1: Project Selection tab. "),
        p("You can either select projects from a table or input a text listing your interested 
          projects. To select projects from table, use Select from table as your project 
          selection method, and then click on rows below to select projects from the table. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_db2.svg")
          )
        ),
        p("Another way to select projects is via text input. Use Select with text input 
        as your project selection method. Either paste or upload the 
          project list in the specified format, and click on Confirm project selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_db3.svg")
          )
        ),
        p("Once you have selected your projects, go to Step 2: Sample Selection to 
          now select samples from the selected projects. "),
        p("There are again two ways to select samples. The first method is to select from 
          table. Click on the table to select samples. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_db4.svg")
          )
        ),
        p("Click on Confirm sample selection to add these samples to your current selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_db5.svg")
          )
        ),
        p("To select samples with text input, use Select with text input. Then, input 
          sample selection text in the specified format and click on Confirm sample selection 
          to add these samples to current selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_db6.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_sample_sel_loc"),
        h3("Select from local path"),
        p("When running this app from local host, you can also choose to select projects and 
          samples from a local path. To do this, select Select from local path from 
          drop-down in sidebar, and click on Select a local directory button. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_loc1.svg")
          )
        ),
        p("In the modal pop-up, first choose a root directory to select from. Then, 
          from the children directories shown in the left panel, find and choose the 
          directory containing the project prediction RDS files. Finally, click on 
          Select to select this directory. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_loc2.svg")
          )
        ),
        p("All RDS files from the selected directory with a valid project name will be 
          displayed in the Local project selection table. Select the projects you want, 
          and click on Check project RDS file. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_loc3.svg")
          )
        ),
        p("Click on Okay to allow the app to read and check the selected RDS files. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_loc4.svg")
          )
        ),
        p("Now the app will read and check each RDS file. After the file checking is complete, 
          go to Step 2: Sample Selection tab, where you can select any samples from 
          valid project files. "),
        p("To select samples from table, choose Select from table. All samples from valid project files 
          will show up in the table below. Select the desired samples from the table, and click on 
          Confirm sample selection to add these samples to your current selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_loc5.svg")
          )
        ),
        p("To select samples with text, choose Select with text input. Input the text in 
          specified format, and click on Confirm sample selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_loc6.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_sample_sel_manage"),
        h3("Manage current selection"),
        p("You can view and manage your current selection by clicking on Show selected 
          samples table button from the left sidebar. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_manage1.svg")
          )
        ),
        p("A pop-up modal will show, and you can view information about all currently selected 
          samples in a table. You can also select samples from table and remove them from selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_sample_sel_manage2.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "input_sel_bin_sel"), 
        h2("Genomic ranges selection"), 
        p("To select genomic ranges, go to the Sample range selection tab. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_bin_sel.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_bin_sel_default"),
        h3("Default selection"),
        p("The default genomic range is all bins in chromosome 1. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_bin_sel_default.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_bin_sel_all"),
        h3("Full genome selection"),
        p("The default genomic range is all bins in chromosome 1. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_bin_sel_all.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_bin_sel_manual"),
        h3("Manual selection"),
        p("For manual selection, select Manual from drop-down, and select chromosomes 
          by choosing in the side panel. Then, for each selected chromosome, you may 
          select a custom region of the chromosome using the sliders on the right or 
          entering the start and end positions of the desired genomic regions. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_bin_sel_manual.svg")
          )
        ),
        br(),
        
        a(name = "input_sel_bin_sel_bed"),
        h3("BED input selection"),
        p("You can also upload a BED file to indicate desired genomic region. Select BED input 
          from drop-down and upload your BED file. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_bin_sel_bed.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "input_sel_restriction"),
        h2("Online server restrictions"),
        p("There are many restrictions to online server sessions due to RAM limitations 
          of shinyapps.io. Namely, you can only select up to 200 samples coming from 
          moderate size studies (these studies must contain no more than 200 samples in 
          total); you can only select up to 120,000 genomic bins; you can select up 
          to 3,000 top variance bins for PCA computation; and you may select up to 
          10,000 bins for disease SNP analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_restriction1.svg")
          )
        ),
        br(),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_restriction2.svg")
          )
        ),
        br(),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_restriction3.svg")
          )
        ),
        br(),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/input_sel_restriction4.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "pred_download"),
        h2("Prediction download"),
        p("You may download predictions in RDS, BigWig, and txt formats, and you can 
          visualize selected predictions on UCSC Genome Browser by downloading the 
          session files. "),
        p("While text download has its own page and requires input samples and genomic 
          range selection prior to download, the other prediction download functionalities 
          are integrated into the Input Selection section. "),
        br(),
        
        a(name = "pred_download_rds"),
        h3("RDS download"),
        p("RDS format is intended for project prediction download, where all predictions 
          for a project are stored in a numeric matrix written to an RDS file. "),
        p("To download RDS files, go to Input Selection, go to Select or upload samples tab, and choose Select 
          from database predictions. Under Step 1: Project Selection, choose Select from table."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pred_download_rds1.svg")
          )
        ),
        p("Select the projects that you want to download from the table, and click 
          on Download RDS file(s). "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pred_download_rds2.svg")
          )
        ),
        br(),
        
        a(name = "pred_download_bw_ucsc"),
        h3("BigWig and UCSC Genome Browser session file download"),
        p("A BigWig file is used for visualization of prediction for an individual sample. 
          An UCSC Genome Browser session file can be used to display a session on 
          UCSC Genome Browser, showing prediction for multiple samples at the same time. "),
        p("To download BigWig files, you need to go to the panel for selecting samples from 
          prediction database and go to Step 2: Sample Selection. Choose Select from table. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pred_download_bw_ucsc1.svg")
          )
        ),
        p("Select samples from table, and use the buttons on the bottom of the page to download 
          BigWig file(s) and UCSC Genome Browser session file. "), 
        p("The instructions for uploading session files on UCSC Genome Browser can be 
          viewed by clicking on the information button next to the Download session file button. 
          Please note that including more samples (tracks) in a single session may cause the Genome 
          Browser page to load slower. Please try to keep the number of samples reasonable. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pred_download_bw_ucsc2.svg")
          )
        ),
        br(),
        
        a(name = "pred_download_txt"),
        h3("Text download"),
        p("To download prediction text file, you are required to select at least 1 sample 
          and at least 1 genomic bin first. Go to txt download under Prediction Download 
          and click the download buttons to either download a single txt file containing 
          all predictions or a zip file containing predictions for each sample in 
          separate text files. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pred_download_txt.svg")
          )
        ),
        br()
      )
    )
  })
  
  # PCA Pseudotime analysis tutorial
  output$tut_page_pca_pt <- renderUI({
    sidebarLayout(
      sidebarPanel(
        h3("Contents"), 
        hr(),
        a(href="#pca_pt_req", class="content_link", h4("Before analysis")), 
        a(href="#pca_pt_hypervar", class="content_link", h4("1 Hypervariance bins selection")), 
        a(href="#pca_pt_pca", class="content_link", h4("2 Perform PCA")), 
        a(href="#pca_pt_pt", class="content_link", h4("3 Pseudo-time analysis")), 
        div(
          style = "margin-left:20px", 
          a(href="#pca_pt_pt_param", class="content_link", "3.1 Choose parameters"), 
          br(),
          a(href="#pca_pt_pt_traj", class="content_link", "3.2 View trajectory"), 
          br(),
          a(href="#pca_pt_pt_chracc_along", class="content_link", "3.3 Accessibility along pseudo-time"), 
          div(
            style = "margin-left:20px", 
            a(href="#pca_pt_pt_chracc_along_gbin_clu", class="content_link", 
              "3.3.1 Genomic bin clusters accessibility along pseudo-time"), 
            br(),
            a(href="#pca_pt_pt_chracc_along_gbin", class="content_link", 
              "3.3.2 Individual bins accessibility along pseudo-time"), 
            br(),
            a(href="#pca_pt_pt_chracc_along_gene", class="content_link", 
              "3.3.3 Gene average accessibility along pseudo-time")
          ), 
          a(href="#pca_pt_pt_expr_along", class="content_link", "3.4 Expression along pseudo-time"), 
          div(
            style = "margin-left:20px", 
            a(href="#pca_pt_pt_expr_along_gbin_clu", class="content_link", 
              "3.4.1 Genomic bin clusters expression along pseudo-time"), 
            br(),
            a(href="#pca_pt_pt_expr_along_gbin", class="content_link", 
              "3.4.2 Individual bins expression along pseudo-time"), 
            br(),
            a(href="#pca_pt_pt_expr_along_gene", class="content_link", 
              "3.4.3 Gene average expression along pseudo-time")
          ), 
        ), 
        a(href="#pca_pt_diff", class="content_link", h4("4 Differential test along pseudo-time")), 
        div(
          style = "margin-left:20px", 
          a(href="#pca_pt_diff_subject", class="content_link", "4.1 Select test subject"), 
          br(),
          a(href="#pca_pt_diff_table", class="content_link", "4.2 Test result table"), 
          br(),
          a(href="#pca_pt_diff_summary", class="content_link", "4.3 Test summary")
        ), 
        a(href="#pca_pt_go", class="content_link", h4("5 GO analysis on significant hits")), 
        div(
          style = "margin-left:20px", 
          a(href="#pca_pt_go_map", class="content_link", "5.1 Map significant hits to genes"), 
          div(
            style = "margin-left:20px", 
            a(href="#pca_pt_go_map_gbin_clu", class="content_link", 
              "5.1.1 Map significant bin clusters"), 
            br(),
            a(href="#pca_pt_go_map_gbin", class="content_link", 
              "5.1.2 Map significant bins"), 
            br(),
            a(href="#pca_pt_go_map_gene", class="content_link", 
              "5.1.3 Map genes")
          ), 
          a(href="#pca_pt_go_options", class="content_link", "5.2 GO analysis options"),
          br(),
          a(href="#pca_pt_go_res", class="content_link", "5.3 Result tables and graphs")
        )
      ), 
      mainPanel(
        a(name = "pca_pt_req"), 
        h2("Before analysis"), 
        div(
          HTML("At least <b>2 samples and 2 genomic bins</b> need to be selected before you 
          perform PCA and pseudo-temporal analysis. For instructions on how to
          select input samples and genomic bins, see the "), 
          actionLink("input_sel_tut_link", "Input Selection Tutorial"), 
          HTML(". ")
        ),
        div(
          HTML("This tutorial is a detailed guide. If you want a quick walkthrough of 
               an example pseudo-temporal analysis, please go to the "), 
          actionLink("demo_link", "pseudo-temporal analysis application demo"), 
          HTML(". ")
        ),
        br(), 
        
        hr(),
        
        a(name = "pca_pt_hypervar"),
        h2("1 Hypervariance bins selection"),
        p("Select the number of top variance bins that will be used in PCA computation, 
        The default number of top variance bins is 2000. The max limit is 10,000 in 
          local host session and 3,000 in server session."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_hypervar.svg")
          )
        ),
        br(),
        
        hr(),
        
        a(name = "pca_pt_pca"),
        h2("2 Perform PCA"),
        p("PCA is automatically performed on the top variance bins once you go to 
        the Pseudo-time Analysis tab. However, you may choose to see the PCA plot 
          alone without doing the pseudo-time analysis by choosing to display PCA plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pca.svg")
          )
        ),
        br(),
        
        hr(),
        
        a(name = "pca_pt_pt"),
        h2("3 Pseudo-time analysis"),
        p("Go to the Pseudo-time Analysis tab."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_param"),
        h3("3.1 Choose parameters"),
        p("On the sidebar are the parameters for constructing pseudo-time trajectory. 
          First select the number of principal components to use, as the anchoring sample clusters 
          will be computed with the PCA-reduced matrix. Next, select the range of 
          desired number of anchoring clusters. Lastly, select the desired trajectory path. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_param.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_traj"),
        h3("3.2 View trajectory"),
        p("Select Pseudo-Time Trajectory in the drop-down to view plot of anchoring clusters and trajectory. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_traj.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_chracc_along"),
        h3("3.3 Accessibility along pseudo-time"),
        p("Select Accessibility along pseudotime to see the accessibility of 
          genomic bins, bin clusters, or genes along the selected pseudotime."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_chracc_along_gbin_clu"),
        h4("3.3.1 Genomic bin clusters accessibility along pseudo-time"),
        p("To show genomic bins accessibility along pseudotime, select Genomic bin 
          clusters in the drop-down, and select the desired number of genomic bin clusters
          in the options panel. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin_clu1.svg")
          )
        ),
        p("You may choose to show a scatter plot with trend or a heat map. To show 
          the scatter plot, you need to select Scatterplot and select one cluster to 
          view its average accessibility along pseudotime. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin_clu2.svg")
          )
        ),
        p("To see the heatmap, select Heatmap instead. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin_clu3.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_chracc_along_gbin"),
        h4("3.3.2 Individual bins accessibility along pseudo-time"),
        p("To show individual genomic bins accessibility along pseudotime, select 
          Individual genomic bin from the drop-down. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin1.svg")
          )
        ),
        p("The scatter plot visualization can be shown if you select Scatter plot and 
          click on the desired genomic bin from the table. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin2.svg")
          )
        ),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin3.svg")
          )
        ),
        p("You can also see the heatmap if you select Heatmap as your visualization method. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gbin4.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_chracc_along_gene"),
        h4("3.3.3 Gene average accessibility along pseudo-time"),
        p("To see gene average accessibility along pseudotime, first select 
          Gene average from the drop-down, and then select a maximum mapping distance 
          between the genomic bins and their nearest genes. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gene1.svg")
          )
        ),
        p("The nearest genes mapped are shown in a table. Select the gene that you want to 
          view accessibility for, and the plot will show up below the table. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gene2.svg")
          )
        ),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_chracc_along_gene3.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_expr_along"),
        h3("3.4 Expression along pseudo-time"),
        p("To view genomic bins/bin clusters/genes expression along pseudotime, 
          select Nearest gene expression along pseudotime as your chosen result panel. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_expr_along_gbin_clu"),
        h4("3.4.1 Genomic bin clusters expression along pseudo-time"),
        p("To show genomic bin clusters average expression, select Genomic bin clusters, 
          and then choose the number of genomic bin clusters you want."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin_clu1.svg")
          )
        ),
        p("Same as before, you can choose whether you want to see the scatter plot 
          or heatmap visualization. For scatter plot, select Scatterplot from drop-down, 
          and choose whether you want the average expression to be computed across the bins or 
          their nearest genes. Since many bins may map to the same gene, the weight 
          of each gene's expression pattern (expression is in terms of ensembl genes) 
          will be different in the average calculation. You also need to select the 
          specific bin cluster that you want to see as well as the mapping distance 
          limit of genomic bin to nearest gene mapping. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin_clu2.svg")
          )
        ),
        p("Scroll down to the the plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin_clu3.svg")
          )
        ),
        p("To see the heat map visualization, select Heatmap and whether you want to 
          compute the average expression across bins or genes. Choose a mapping distance 
          limit, and the heat map will show up on the bottom of the page. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin_clu4.svg")
          )
        ),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin_clu5.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_expr_along_gbin"),
        h4("3.4.2 Individual bins expression along pseudo-time"),
        p("To show individual genomic bins expression along pseudotime, first select 
          Individual genomic bin from drop-down, and then select a maximum bin-to-gene 
          mapping distance."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin1.svg")
          )
        ),
        p("To view the scatterplot representation, select Scatterplot as your visualization 
          method. Then, select one genomic bin from the table. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin2.svg")
          )
        ),
        p("lastly, scroll down to see the scatter plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin3.svg")
          )
        ),
        p("To view a heatmap representation of each bin's expression along pseudotime, 
          select Heatmap. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gbin4.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_pt_expr_along_gene"),
        h4("3.4.3 Gene average expression along pseudo-time"),
        p("To see gene average expression along pseudo-time, first select Gene average 
          from drop-down, and then select the maximum bin-to-gene mapping distance. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gene1.svg")
          )
        ),
        p("To view the scatter plot, select Scatterplot and click on the target gene in 
          the table. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gene2.svg")
          )
        ),
        p("Scroll down to see the plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gene3.svg")
          )
        ),
        p("To look at the heat map visualization, select heat map. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_pt_expr_along_gene4.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "pca_pt_diff"), 
        h2("4 Differential test along pseudo-time"), 
        p("You can perform a differential analysis to see whether there is a significant 
          accessibility pattern along the selected pseudotime. Go to the Pseudo-time Differential Test tab."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_diff_subject"),
        h3("4.1 Select test subject"),
        p("You need to select the subject of the differential test in the sidebar. 
          The differential test will test whether the selected subject's (average) accessibility 
          has a significant pattern along pseudotime. For genomic bins subjects, 
          you do not need to do any further parameter selections, and you can click on 
          Perform Test to start running the test."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_subject1.svg")
          )
        ),
        p("For genomic bin clusters subjects, you need to select Genomic bin clusters 
          from the drop-down first, then select the desired number of clusters by k-means, 
          and finally click on Perform Test to run the analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_subject2.svg")
          )
        ),
        p("For gene subjects, you need to select Gene average accessibility 
          from the drop-down first, then set the bin-to-gene mapping distance limit, 
          and finally click on Perform Test to run the analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_subject3.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_diff_table"),
        h3("4.2 Test result table"),
        p("Test results will show in the main panel on the right. The Result tab shows 
          the differential test result table, where each row is a test subject (a bin, 
          a bin cluster, or a gene). "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_table.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_diff_summary"),
        h3("4.3 Test summary"),
        p("To see the test summary plots, you can go to the Summary tab. You may adjust 
          the FDR threshold for defining significant subjects. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_summary1.svg")
          )
        ),
        p("Scroll down to see the FDR or p-value histograms. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_summary2.svg")
          )
        ),
        p("Scroll down again to see the p-value adjustment line plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_diff_summary3.svg")
          )
        ),
        br(),
        
        hr(),
        
        a(name = "pca_pt_go"),
        h2("5 GO analysis on significant hits"),
        p("You can click on the Gene ontology tab to perform a GO enrichment analysis 
          on the significant subjects from differential test. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_go.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_go_map"),
        h3("5.1 Map significant hits to genes"),
        p("First, you need to map the significant subjects to genes. This mapping is 
          different for each type of subject (bin, bin cluster, gene). "),
        br(),
        
        a(name = "pca_pt_go_map_gbin_clu"),
        h4("5.1.1 Map significant bin clusters"),
        p("For genomic bin cluster subjects, the significant clusters need to be first 
          defined with your choice of significance level, and the significant clusters found 
          will automatically show up in the selection bar, where you may choose to 
          exclude any significant clusters of your choice. Lastly, you need to define the 
          genomic bin to gene mapping distance limit to map all bins in selected 
          significant clusters to their nearest genes. "),
        p("You may also choose to perform other analyses with external tools such as 
          EnrichR or GREAT. The bins and genes from your selected significant clusters 
          are available for download and copy. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_go_map_gbin_clu.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_go_map_gbin"),
        h4("5.1.2 Map significant bins"),
        p("For genomic bin subjects, the significant bins need to be first 
          defined with your choice of significance level. Next, you need to define the 
          genomic bin to gene mapping distance limit to map all significant bins to their nearest genes. "),
        p("You may also choose to perform other analyses with external tools such as 
          EnrichR or GREAT. The significant bins and genes 
          are available for download and copy. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_go_map_gbin.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_go_map_gene"),
        h4("5.1.3 Map genes"),
        p("For gene subjects, the significant genes need to be 
          defined with your choice of significance level. "),
        p("You may also choose to perform other analyses with external tools such as 
          EnrichR. The significant genes are available for download and copy. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_go_map_gene.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_go_options"),
        h3("5.2 GO analysis options"),
        p("You may choose to adjust the GO enrichment analysis parameters and the number 
          of top terms to return. Click on Find top GO terms button to run GO enrichment analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_go_options.svg")
          )
        ),
        br(),
        
        a(name = "pca_pt_go_res"),
        h3("5.3 Result tables and graphs"), 
        p("There are a range of different visualizations available for the top GO terms returned. 
          Use the drop-down to select which one you want to see. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/pca_pt_go_res.svg")
          )
        ),
      )
    )
  })
  
  # Group differential test tutorial
  output$tut_page_group_diff <- renderUI({
    sidebarLayout(
      sidebarPanel(
        h3("Contents"), 
        hr(),
        a(href="#group_diff_req", class="content_link", h4("Before analysis")), 
        a(href="#group_diff_group", class="content_link", h4("1 Grouping samples")), 
        div(
          style = "margin-left:20px", 
          a(href="#group_diff_group_kmeans", class="content_link", "1.1 Group by k-means clustering"), 
          br(),
          a(href="#group_diff_group_text", class="content_link", "1.2 Group by text input"), 
          br(),
          a(href="#group_diff_group_drag", class="content_link", "1.3 Group by drag-and-drop"), 
          br(),
          a(href="#group_diff_group_plotsel", class="content_link", "1.4 Group by selecting from plot"), 
        ), 
        a(href="#group_diff_test", class="content_link", h4("2 Differential test")), 
        div(
          style = "margin-left:20px", 
          a(href="#group_diff_test_param", class="content_link", "2.1 Test parameters"), 
          br(),
          a(href="#group_diff_test_table", class="content_link", "2.2 Result table"), 
          br(),
          a(href="#group_diff_test_summary", class="content_link", "2.3 Result summary"), 
          br(),
          a(href="#group_diff_test_volcano", class="content_link", "2.4 Volcano plot"), 
        ),
        a(href="#group_diff_go", class="content_link", h4("3 GO analysis")), 
        div(
          style = "margin-left:20px", 
          a(href="#group_diff_go_map", class="content_link", "3.1 Mapping significant bins to genes"), 
          br(),
          a(href="#group_diff_go_options", class="content_link", "3.2 Test options"), 
          br(),
          a(href="#group_diff_go_res", class="content_link", "3.3 Result tables and graphs"),
        )
      ), 
      mainPanel(
        a(name = "group_diff_req"), 
        h2("Before analysis"), 
        div(
          HTML("At least <b>3 samples and 2 genomic bins</b> need to be selected to 
          perform differential analysis between sample groups. For instructions on how to
          select input samples and genomic bins, see the "), 
          actionLink("input_sel_tut_link", "Input Selection Tutorial"), 
          HTML(". ")
        ),
        p("To navigate to group differential analysis, go to Data Exploration Tools 
          and go to Group differential analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group.svg")
          )
        ),
        br(),
        
        hr(),
        
        a(name = "group_diff_group"),
        h2("1 Grouping samples"),
        p("You need to first divide selected samples into groups to perform differential test. 
        To do this, go to the Group samples tab. There are multiple ways to group samples. "),
        br(),
        
        a(name = "group_diff_group_kmeans"),
        h3("1.1 Group by k-means clustering"),
        p("To group samples by k-means clustering, select k-means clustering as your 
          grouping method. Select the number of top variance bins that you want to include 
          in PCA computation, and then select the number of PCs you want to use for k-means. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_kmeans1.svg")
          )
        ),
        p("Next, select the number of clusters you want for k-means clustering. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_kmeans2.svg")
          )
        ),
        p("Finally, click on Confirm groups button to confirm this sample grouping. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_kmeans3.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_group_text"),
        h3("1.2 Group by text input"),
        p("To group by text input, use manual selection and select Text input. Then, 
          either paste or upload the text indicating sample groups in the specified format. 
          Lastly, click on Confirm groups to submit grouping. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_text.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_group_drag"),
        h3("1.3 Group by drag-and-drop"),
        p("To group by drag-and-drop, use manual selection and select Drag and drop. Then, 
          on the right side panel, drag the sample tags to the buckets (groups). The screenshot 
          shows an incomplete grouping. You must drag all samples out of the source bucket for 
          a valid sample grouping, as no samples should remain ungrouped. "),
        p("Once you have finished dragging samples to their assigned groups, click on Confirm groups 
          to record this grouping. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_drag.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_group_plotsel"),
        h3("1.4 Group by selecting from plot"),
        p("To group by selection from plot, use manual selection and select Select from plot. Then, 
          adjust the number of top variance bins that will be used in generating the PCA plot for group selection. 
          On the generated PCA plot on the right, hover on the plot to make the plot interaction 
          tools bar to appear, and use either lasso select or box select to select the samples that you would like 
          to put in the same group on the plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_plotsel1.svg")
          )
        ),
        p("Once you have selected samples from the plot, you may view the selected samples in a table. 
          Use the buttons on the bottom of the page to assign a group to the selected samples or 
          add all remaining samples (all points in PCA plot) to a new group. "),
        p("Once you have completed assigning all samples to groups, click on Confirm group selection 
          button in the left panel to confirm this grouping. You may also view the currently selected groups by 
          clicking on the View selected groups in the left panel. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_group_plotsel2.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "group_diff_test"), 
        h2("2 Differential test"), 
        p("Go to the next tab (Differential testing) to adust parameters and perform 
          differential test. Please note that tests are run for all selected genomic bins. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_test.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_test_param"),
        h3("2.1 Test parameters"),
        p("Now, select the groups that you want to compare. Select a test method, 
          and lastly click Perform Test to run the differential test with selected 
          parameters. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_test_param.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_test_table"),
        h3("2.2 Result table"),
        p("The result panel contains several tabs. The first one (Results) shows a 
          result table, in which each row is a selected genomic bin, and columns show 
          result attributes such as p-value, FDR, and statistics. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_test_table.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_test_summary"),
        h3("2.3 Result summary"),
        p("The second panel shows a summary of the number of significant bins found, a 
          p-value or FDR histogram, and a p-value adjustment line plot. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_test_summary.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_test_volcano"),
        h3("2.4 Volcano plot"),
        p("To make a volcano plot of tested groups, go to Volcano plot tab, select the 
          2 groups that you want to compare and compute fold changes for, and then choose the 
          y-axis variable (either p-value or FDR). Lastly, click on Make volcano plot to 
          generate the plot. The volcano plot will show up below the parameters panel. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_test_volcano.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "group_diff_go"),
        h2("3 GO analysis"),
        p("Go to the Gene ontology tab to perform GO enrichment analysis on significantly 
          differential bins. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_go.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_go_map"),
        h3("3.1 Mapping significant bins to genes"),
        p("You need to first identify the significant bins by defining the significance 
          criteria. Then, set the maximum distance for bins to genes mapping, and the 
          nearest genes will be found and used to perform GO enrichment analysis. "),
        p("You may also use external tools like EnrichR or GREAT to perform more in-depth 
          analysis on the significant gene set or the significant genomic regions. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_go_map.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_go_options"),
        h3("3.2 Test options"),
        p("Next, select the parameters for GO enrichment analysis, such as which control 
          genes to use, the Gene ontology category, and the number of top GO terms to return. 
          Finally, click on Find top GO terms to perform the analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_go_options.svg")
          )
        ),
        br(),
        
        a(name = "group_diff_go_res"),
        h3("3.3 Result tables and graphs"),
        p("The GO enrichment analysis results include a variety of tables and graphs. You 
          may use the drop-down to select the ones you want to see. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/group_diff_go_res.svg")
          )
        ),
        br(),
      )
    )
  })
  
  # Disease snp tutorial
  output$tut_page_disease_snp <- renderUI({
    sidebarLayout(
      sidebarPanel(
        h3("Contents"), 
        hr(),
        a(href="#disease_snp_req", class="content_link", h4("Before analysis")), 
        a(href="#disease_snp_disease_sel", class="content_link", h4("1 Disease selection")), 
        a(href="#disease_snp_subset_snp", class="content_link", h4("2 Subset SNPs")), 
        a(href="#disease_snp_window", class="content_link", h4("3 Choose SNPs window size")), 
        a(href="#disease_snp_res", class="content_link", h4("4 SNP analysis results")), 
        div(
          style = "margin-left:20px", 
          a(href="#disease_snp_res_table", class="content_link", "4.1 Result table"), 
          br(),
          a(href="#disease_snp_res_barplot", class="content_link", "4.2 Result bar plot"), 
          br(),
          a(href="#disease_snp_res_heatmap", class="content_link", "4.3 Result heatmap"), 
          br()
        )
      ), 
      mainPanel(
        h2("Before analysis"), 
        div(
          HTML("At least <b>2 samples</b> need to be selected to 
          perform disease SNP analysis. For instructions on how to
          select input samples, see the "), 
          actionLink("input_sel_tut_link", "Input Selection Tutorial"), 
          HTML(". ")
        ),
        br(), 
        
        hr(), 
        
        a(name = "disease_snp_disease_sel"), 
        h2("1 Disease selection"), 
        p("Navigate to the disease SNP analysis page. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_disease_sel1.svg")
          )
        ),
        p("Select desired disease(s)/trait(s) in the sidebar. You may type in the search 
          box to search for disease/trait. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_disease_sel2.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "disease_snp_subset_snp"), 
        h2("2 Subset SNPs"), 
        p("Each selected disease/trait is associated with a set of SNPs. You can view and 
          edit the associated SNPs by clicking on the Show disease associated SNPs table button. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_subset_snp1.svg")
          )
        ),
        p("In the pop-up modal, you can select the SNPs that you want to keep and click on the 
          Confirm SNP subset button to subset the SNPs. If you do not subset the SNPs, all 
          associated SNPs will be selected. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_subset_snp2.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "disease_snp_window"), 
        h2("3 Choose SNPs window size"), 
        p("Set a SNP window size to find bins that are covered by the SNP windows. 
          Please note that in session run on shinyapps.io server, the maximum number of 
          bins that can be selected (covered by SNP windows) is 10,000. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_window.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "disease_snp_res"), 
        h2("4 SNP analysis results"), 
        p("The result panels will be different for multiple diseases and for a single disease selection. 
          Namely, There will be an additional bar plot for the single disease results, and the tables and 
          heatmaps are formatted differently for single and multiple diseases results. "),
        br(),
        
        a(name = "disease_snp_res_table"),
        h3("4.1 Result table"),
        p("The first result page contains result tables. If you selected a single disease, 
          the columns of the result table will be the average disease SNPs accessibility and the normalized 
          disease SNPs accessibility. The rows will be samples. If you selected multiple 
          diseases, there will be two tables, one containing average disease SNPs accessibilities, and the 
          other containing normalized average accessibilities. The columns will be diseases, and 
          the rows will be samples. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_res_table.svg")
          )
        ),
        br(),
        
        a(name = "disease_snp_res_barplot"),
        h3("4.2 Result bar plot"),
        p("The bar plot is only available for single disease analysis. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_res_barplot.svg")
          )
        ),
        br(),
        
        a(name = "disease_snp_res_heatmap"),
        h3("4.3 Result heatmap"),
        p("The heatmap for single disease result has genomic bins covered by the disease SNP 
          windows on the rows and the diseases/traits on the columns. You will be able 
          to select the number of top variance bins to include in the heatmap. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_res_heatmap1.svg")
          )
        ),
        p("The heatmap for multiple diseases result has diseases/traits on the columns and samples 
          on the rows. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/disease_snp_res_heatmap2.svg")
          )
        ),
        br(),
      )
    )
  })
  
  # GTEx snp tutorial
  output$tut_page_gtex_snp <- renderUI({
    sidebarLayout(
      sidebarPanel(
        h3("Contents"), 
        hr(),
        a(href="#gtex_snp_param", class="content_link", h4("1 Adjust heatmap parameters")), 
        div(
          style = "margin-left:20px", 
          a(href="#gtex_snp_param_tissue", class="content_link", "1.1 Select tissues"), 
          br(),
          a(href="#gtex_snp_param_trait", class="content_link", "1.2 Select traits"), 
          br(),
          a(href="#gtex_snp_param_other", class="content_link", "1.3 Other parameters"), 
          br()
        ),
        a(href="#gtex_snp_res", class="content_link", h4("2 Result heatmap"))
      ), 
      mainPanel(
        p("The GTEx tissues SNPs page includes a pre-computed normalized tissue and 
          trait-average accessibility matrix for all GTEx tissues and GWAS traits 
          from GWAS Catalog all associations v1.0. You may set several parameters 
          to generate an interactive heat map. "),
        p("First, navigate to GTEx tissues SNPs from the navigation bar."),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_navi.svg")
          )
        ),
        
        a(name = "gtex_snp_param"), 
        h2("1 Adjust heatmap parameters"), 
        p("You can adjust the heat map parameters in the side panel. "),
        br(),
        
        a(name = "gtex_snp_param_tissue"), 
        h3("1.1 Select tissues"), 
        p("To adjust the tissues (columns) displayed on the heat map, click on Subset GTEx tissues 
          to open a modal for tissues selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_param_tissue1.svg")
          )
        ),
        p("Edit the selection by clicking rows in the table, and click Confirm selection 
          to record this selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_param_tissue2.svg")
          )
        ),
        br(),
        
        a(name = "gtex_snp_param_trait"), 
        h3("1.2 Select traits"), 
        p("To adjust the traits (columns) displayed on the heat map, click on Subset traits 
          to open a modal for traits selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_param_trait1.svg")
          )
        ),
        p("Edit the selection by clicking rows in the table, and click Confirm selection 
          to record this selection. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_param_trait2.svg")
          )
        ),
        br(),
        
        a(name = "gtex_snp_param_other"), 
        h3("1.3 Other parameters"), 
        p("You can also adjust the other parameters for row and column appearance. 
          Click on Apply setting and update heatmap to reflect all changes on the 
          heat map. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_param_other.svg")
          )
        ),
        br(),
        
        hr(), 
        
        a(name = "gtex_snp_res"), 
        h2("2 Result heatmap"), 
        p("You can hover on heat map elements to see the tissue and trait, and you 
          can brush on the heat map to zoom in. You may also download the heat map data. "),
        tags$div(
          style = "width:100%;",
          div(
            style = "width:75%; margin:0 auto; border:solid grey 1px;",
            includeHTML("www/tut/gtex_snp_res.svg")
          )
        ),
        br(),
      )
    )
  })
  
  # Go to input selection tutorial page on link click
  observeEvent(input$input_sel_tut_link, {
    updateSelectInput(inputId = "tut_page_sel", selected = "input_sel_tut")
  })
  
  # Go to tutorial, then input selection tutorial page on link click
  observeEvent(input$tut_input_sel_tut_link, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
    updateSelectInput(inputId = "tut_page_sel", selected = "input_sel_tut")
  })
  
  # Go to tutorial page on link click
  observeEvent(input$tut_link, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Tutorial")
  })
  
  # Go to demo page on link click
  observeEvent(input$demo_link, {
    updateNavbarPage(session, inputId = "chrombird_nav", selected = "Application Examples")
  })
  
  # Remove temporary directory on session end
  session$onSessionEnded(function() {
    unlink(tmp_dir, recursive = TRUE)
  })
}

shiny::shinyApp(ui = ui, server = server)

# [END]